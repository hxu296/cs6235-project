!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.humanseg=n():(e.buzzstream=e.buzzstream||{},e.buzzstream.humanseg=n())}(this,(function(){return function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="/",t(t.s=2)}([function(e,n,t){e.exports=(()=>{var e={911:(e,n)=>{"use strict";var t=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==t)return t;throw new Error("unable to locate global object")}();e.exports=n=t.fetch,t.fetch&&(n.default=t.fetch.bind(t)),n.Headers=t.Headers,n.Request=t.Request,n.Response=t.Response},994:(e,n,t)=>{"use strict";t.r(n),t.d(n,{PaddlejsBackend:()=>me,Runner:()=>ve,Transformer:()=>F,coreUtils:()=>o,env:()=>f,interfaces:()=>r,registerBackend:()=>b,registerOp:()=>P});var o={};t.r(o),t.d(o,{AddItemToVars:()=>u,delUselessData:()=>c,findVarByKey:()=>s,getGlobalInterface:()=>i,getOrMakeGlobalProperty:()=>a,traverseVars:()=>l});var r={};function i(){var e;if("undefined"!=typeof window)e=window;else if(void 0!==t.g)e=t.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}return e}function a(e,n){var t=i();return t[e]||(t[e]=n),t[e]}function s(e,n){return Array.isArray(e)?e.find((function(e){return e.name===n})):e[n]}function u(e,n){var t=Array.isArray(e),o=Array.isArray(n)?n:[n];t?o.forEach((function(n){for(var t=null,o=0;o<e.length;o++)if(e[o].name===n.name){t=o;break}null!==t?e[t]=n:e.push(n)})):o.forEach((function(n){e[n.name]=n}))}function l(e,n){Array.isArray(e)?e.forEach((function(e){n(e)})):Object.keys(e).forEach((function(t){n(e[t])}))}function c(e){if(e.ops=null,e.vars instanceof Array)for(var n=0;n<e.vars.length;n++)e.vars[n].data&&delete e.vars[n].data;else for(var t in e.vars)e.vars[t].data&&delete e.vars[t].data}t.r(r),t.d(r,{BufferType:()=>g,GraphType:()=>m,UniformType:()=>v,WasmMemoryType:()=>_});const f=a("env",new(function(){function e(){this.ENV={}}return e.prototype.set=function(e,n){this.ENV[e]=n},e.prototype.get=function(e){return this.ENV[e]},e}()));var h=function(e,n,t,o){return new(t||(t=Promise))((function(r,i){function a(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,s)}u((o=o.apply(e,n||[])).next())}))},p=function(e,n){var t,o,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,o=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((r=(r=a.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){a.label=i[1];break}if(6===i[0]&&a.label<r[1]){a.label=r[1],r=i;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(i);break}r[2]&&a.ops.pop(),a.trys.pop();continue}i=n.call(e,a)}catch(e){i=[6,e],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}};const d=function(){function e(e){this.urlConf={dir:"",main:""},this.separateChunk=!0,this.chunkNum=1,this.dataType="binary",this.params={type:"fetch"},this.inNode=!1,this.isLocalFile=!1,this.realFetch=function(){throw new Error("ERROR: empty fetch funciton")};var n=e,t="model.json";if(e.endsWith(".json")){var o=e.lastIndexOf("/")+1;n=e.substr(0,o),t=e.substr(o)}else"/"!==e.charAt(e.length-1)&&(n=e+"/");this.isLocalFile=0!==n.indexOf("http"),this.urlConf={dir:this.isLocalFile?"/"===n.charAt(0)?""+n:"/"+n:n,main:t},this.inNode="node"===f.get("platform")}return e.prototype.load=function(){return h(this,void 0,void 0,(function(){var n;return p(this,(function(t){switch(t.label){case 0:return[4,this.fetchModel()];case 1:return n=t.sent(),this.separateChunk=!!n.chunkNum&&n.chunkNum>0,this.chunkNum=this.separateChunk?n.chunkNum:0,this.separateChunk?"binary"!==this.dataType?[3,3]:[4,this.fetchChunks().then((function(t){return e.allocateParamsVar(n.vars,t)}))]:[3,3];case 2:t.sent(),t.label=3;case 3:return[2,n]}}))}))},e.prototype.fetchOneChunk=function(e){return h(this,void 0,void 0,(function(){return p(this,(function(n){switch(n.label){case 0:return f.get("fetch")?[4,f.get("fetch")(e,{type:"arrayBuffer"})]:[3,2];case 1:return[2,n.sent()];case 2:return[2,this.fetch(e).then((function(e){return e.arrayBuffer()}))]}}))}))},e.prototype.fetchJson=function(e){return this.fetch(e).then((function(e){return e.json()}))},e.prototype.getFileName=function(e){return"chunk_"+e+".dat"},e.prototype.fetchChunks=function(){return h(this,void 0,void 0,(function(){var e,n,t;return p(this,(function(o){for(e=this.chunkNum,n=[],t=1;t<=e;t++)n.push(this.fetchOneChunk(this.urlConf.dir+this.getFileName(t)));return[2,Promise.all(n).then((function(e){var n,t=0,o=[];e.forEach((function(e){n=new Float32Array(e),o.push(n),t+=n.length}));var r=new Float32Array(t),i=0;return o.forEach((function(e){e.forEach((function(e){r[i]=e,i+=1}))})),r}))]}))}))},e.allocateParamsVar=function(e,n){var t,o=0,r=Array.isArray(n)?n:Object.values(n);l(e,(function(e){t=e.shape.reduce((function(e,n){return e*n})),e.persistable&&(e.data=r.slice(o,o+t),o+=t)}))},e.prototype.fetch=function(e,n){if(f.get("fetch"))return f.get("fetch")(e,n||{});var o=(n||this.params).method||"get",r=new(this.inNode?t(911).Headers:Headers);return this.realFetch=this.inNode?this.isLocalFile?this.fetchLocalFile:t(911):window.fetch.bind(window),this.realFetch(e,{method:o,headers:r})},e.prototype.fetchLocalFile=function(e){var n=t(993);return new Promise((function(t,o){try{t(n.readFileSync(e,"utf8"))}catch(e){o(e)}}))},e.prototype.fetchModel=function(){var e=this,n=this.params,t=this.urlConf.dir+this.urlConf.main,o=null;return"fetch"===n.type&&(o=new Promise((function(o,r){e.fetch(t,n).then((function(n){return f.get("fetch")?n:e.isLocalFile&&e.inNode?JSON.parse(n):n.json()})).then((function(e){return o(e)})).then((function(e){return r(e)}))}))),o},e}();var g,_,v,m;!function(e){e.FrameBuffer="frameBuffer",e.ColorBuffer="colorBuffer"}(g||(g={})),function(e){e.memory100="100",e.memory200="200",e.memory300="300",e.memory400="400",e.memory500="500",e.memory600="600",e.memory700="700",e.memory800="800",e.memory900="900"}(_||(_={})),function(e){e.uniform1f="1f",e.uniform1fv="1fv",e.uniform1i="1i",e.uniform1iv="1iv",e.uniform2f="2f",e.uniform2fv="2fv",e.uniform2i="2i",e.uniform2iv="2iv",e.uniform3f="3f",e.uniform3fv="3fv",e.uniform3i="3i",e.uniform3iv="3iv",e.uniform4f="4f",e.uniform4fv="4fv",e.uniform4i="4i",e.uniform4iv="4iv"}(v||(v={})),function(e){e.SingleOutput="single",e.MultipleOutput="multiple",e.MultipleInput="multipleInput"}(m||(m={}));var x={opRegistry:{ops:{}},backend:"",backendInstance:null};function P(e,n){var t=e.conf,o=e.params,r=e.main,i=e.mainFunc,a=e.textureFuncConf,s=e.commonFuncConf,u=e.behaviors,l=void 0===u?[]:u,c=x.backend+"_"+n;x.opRegistry.ops[c]||(x.opRegistry.ops[c]={name:n,conf:t,params:o,main:r,mainFunc:i,textureFuncConf:a,commonFuncConf:s,behaviors:l})}function b(e,n,t){e&&(x.backend=e),n&&(x.backendInstance=n),t&&Object.keys(t).forEach((function(e){P(t[e],e)}))}x=a("GLOBALS",x);var T=i();T.ImageBitmap||(T.ImageBitmap=function(){});const y=function(){function e(e,n){this.id="",this.type="",this.inputs={},this.outputs={},this.attrs={},this.subAttrs=[],this.next="",this.opData=null,this.isPacked=!1,this.bufferType=g.FrameBuffer,this.uniform=null;var t=e.inputs,o=e.outputs,r=e.attrs,i=void 0===r?{}:r,a=e.type,s=e.isPacked,u=void 0!==s&&s,l=e.bufferType,c=void 0===l?g.FrameBuffer:l,f=e.uniform,h=void 0===f?null:f;this.id=a+"_"+ +new Date+"_"+n,this.inputs=t,this.outputs=o,this.attrs=i,this.subAttrs=e["sub-attrs"]||[],this.uniform=h,this.type=a,this.isPacked=u,this.bufferType=c,this.next="",this.opData=null}return Object.defineProperty(e.prototype,"inputsName",{get:function(){var e=this,n=[];return Object.keys(this.inputs).forEach((function(t){n.push(e.inputs[t][0])})),n},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"outputsName",{get:function(){return this.outputs.Output||this.outputs.Out||this.outputs.Y},enumerable:!1,configurable:!0}),e.prototype.execute=function(e){x.backendInstance.runProgram(this.opData,e)},e}(),F=function(e){this.name=e};var w,E=(w=function(e,n){return(w=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}w(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),A={conv2d:function(e,n){var t=e.attrs.strides,o=e.inputs.Input[0],r=e.inputs.Filter[0];if("image"===o)return!1;var i=s(n,o).shape,a=s(n,r).shape;return!t.find((function(e){return e>1}))&&i[i.length-1-2]%4==0&&4===a.length&&a[0]%4==0&&a[1]%4==0}};function O(e){return{type:"packed_2_unpacked",attrs:{},inputs:{Input:[e.inputName]},outputs:{Output:[e.outputName]}}}function V(e){return{type:"unpacked_2_packed",attrs:{},inputs:{Input:[e.inputName]},outputs:{Output:[e.outputName]}}}function C(e,n){Object.keys(e.inputs).forEach((function(n){e.inputs[n]=[e.inputs[n]+"_packed"]})),Object.keys(e.outputs).forEach((function(n){e.outputs[n]=[e.outputs[n]+"_packed"]})),e.type=e.type+"_packing",e.id=e.type+"_"+ +new Date+"_"+n.length,e.isPacked=!0}const R=function(e){function n(){return e.call(this,"TexturePacking")||this}return E(n,e),n.prototype.transform=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];if("webgl"===x.backend&&f.get("webgl_pack_channel")){var t=e[0],o=e[1],r=e[2],i="depthwise_conv2d"===t.type?"conv2d":t.type,a=A[i];if(a&&a(t,o)){var s=t.inputs,u=t.outputs,l=s.Input[0],c=u.Output?u.Output[0]:u.Out[0],h=V({inputName:l,outputName:l+"_packed"}),p=r.length;r.push(new y(h,p)),C(t,r);var d=O({inputName:c+"_packed",outputName:c}),g=r.length+1;r.push(new y(d,g))}}},n}(F);var S=function(){var e=function(n,t){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(n,t)};return function(n,t){function o(){this.constructor=n}e(n,t),n.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}();const I=function(e){function n(){return e.call(this,"FormatInputsX")||this}return S(n,e),n.prototype.transform=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];var t=e[0],o=["concat","connect","fc","rnn_origin","rnn_matmul","stack"];if(o.includes(t.type)){var r=t.inputs;if(("rnn_origin"===t.type||"rnn_matmul"===t.type)&&r.WeightList.length>0)r.WeightList.forEach((function(e,n){r["weightlist_"+n]=[e]}));else{var i=r.X||r.Input;if("wasm"!==f.get("backend"))i.length>1&&(i.forEach((function(e,n){r["origin"+(n>0?"_"+n:"")]=[e]})),delete r.X,delete r.Input);else{if(i.length>4)throw Error("Not yet supporting concat input tensors more than 4.");if(i.length>1){var a=i[0],s=i[1],u=i[2],l=i[3];r.X=[a],s&&(r.Y=[s]),u&&(r.Z=[u],t.type+="_mul"),l&&(r.M=[l])}}}}},n}(F);var k=function(){var e=function(n,t){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(n,t)};return function(n,t){function o(){this.constructor=n}e(n,t),n.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),D=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o};function M(e,n){var t=s(n,e);return t?t.shape:[]}function L(e,n,t,o){for(var r=D(n),i=0,a=0,s=e;a<s.length;a++)i+=M(s[a],o)[t];return r[t]=i,{name:e[e.length-1]+"_out",shape:r}}const U=function(e){function n(){return e.call(this,"splitOp")||this}return k(n,e),n.prototype.transform=function(){for(var e,n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];for(var o=n[0],r=n[1],i=0,a=o.length;i<a;i++){var s=o[i];if("concat"===s.type&&(null===(e=s.inputs)||void 0===e?void 0:e.X)&&!(s.inputs.X.length<=4)){var l=s.attrs,c=s.inputs,f=s.outputs,h=c.X,p=h.length,d=Math.ceil((p-4)/3)+1,g=f.Out[0],_=M(g,r),v=l.axis||0;v=v>-1?v:_.length+v;for(var m=[],x=[],P=h.slice(0,4),b=void 0,T=0;T<d;T++){var y=0===T?P:h.slice(3*T+1,3*(T+1)+1),F=L(y,_,v,r);0!==T&&y.splice(0,0,b.name),F.shape[v]+=b?b.shape[v]:0;var w={Out:[F.name]};x.push({attrs:l,inputs:{X:y},outputs:w,type:"concat"}),m.push(F),b=F}x[d-1].outputs.Out=[g],o.splice.apply(o,D([i,1],x)),u(r,m)}}},n}(F);var j=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o};function N(e){if(e.length<4){for(var n=[],t=0;t<4-e.length;t++)n.push(1);return n.concat(e)}return j(e)}function B(e){return e.reduce((function(e,n){return e+n}))}function G(e,n){var t=e.length;return 4-t+(n>-1?n:t+n)}function X(e,n){for(var t=n[0],o=n[1],r=n[2],i=n[3],a=r*i,s=o*r*i,u=[],l=0;l<t;l++)for(var c=0;c<i;c++)for(var f=0;f<o;f++)for(var h=0;h<r;h++)u.push(e[l*s+f*a+h*i+c]);return new Float32Array(u)}function H(e){for(var n,t=e.data,o=e.shape,r=j(o).reverse(),i=0,a=r.length-1;i<a;i++)n=W(n||t,r[i]);return n}function W(e,n){for(var t=[],o=0,r=e.length;o<r;o+=n)t.push(e.slice(o,o+n));return t}var z=function(){var e=function(n,t){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(n,t)};return function(n,t){function o(){this.constructor=n}e(n,t),n.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),Y="fetch_pack";const q=function(e){function n(){return e.call(this,"PackOut")||this}return z(n,e),n.prototype.transform=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];if(f.get("webgl_pack_output")&&1!==f.get("webglVersion")){var t=e[0],o=e[1],r=t.find((function(e){return"fetch"===e.type})),i=r.inputs.X[0],a=s(o,i),l=N(a.shape),c=l[0],h=l[1],p=l[2],d=l[3],g={attrs:{},inputs:{X:[i]},outputs:{Y:[Y]},type:"pack_out"},_=h*d,v=Math.ceil(c*p/4),m={name:Y,shape:[1,1,v,_],persistable:!1};r.inputs.X=[Y],r.attrs.origin_shape=[c,h,p,d],t.push(g),u(o,[m])}},n}(F);var K=function(){var e=function(n,t){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(n,t)};return function(n,t){function o(){this.constructor=n}e(n,t),n.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),Z="img_pre_processed",J="img_origin";const Q=function(e){function n(){return e.call(this,"FeedProcess")||this}return K(n,e),n.prototype.transform=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];var t=e[0],o=e[1],r=e[2];if(r.webglFeedProcess||f.get("webgl_gpu_pipeline")){var i=r.mean,a=void 0===i?[0,0,0]:i,l=r.std,c=void 0===l?[1,1,1]:l,h=r.scale,p=void 0===h?[1,1]:h,d=r.pos,g=void 0===d?[0,0]:d,_=r.feedShape,m=s(o,"image"),x=m.shape,P=x[2],b=x[3];m.shape=[1,1,P,b];var T=Object.assign({},m);T.name=Z,T.shape=[1,3,_.fh,_.fw],T.persistable=!1,delete T.data;var y=Object.assign({},m);y.name=J,y.shape=[1,1,_.fh,_.fw],y.persistable=!1,delete y.data,u(o,[y,T]);var F=t.find((function(e){var n=e.inputs;return Object.keys(n).find((function(e){return"image"===n[e][0]}))})),w=F.inputs;Object.keys(w).forEach((function(e){"image"===w[e][0]&&(w[e][0]=Z)}));var E={attrs:{mean:a,std:c},inputs:{X:[J]},outputs:{Y:[Z]},type:"feedPost"},A={attrs:{mean:a,std:c,scale:p,pos:g},inputs:{X:["image"]},outputs:{Y:[J]},type:"imgFeed",uniform:{u_scale:{type:v.uniform2fv,value:[1,1]},u_pos:{type:v.uniform2fv,value:[0,0]},u_keep_ratio:{type:v.uniform1i,value:1}},isPacked:!0};t.splice(1,0,E),t.splice(1,0,A)}},n}(F),$={preTransforms:[new U,new q,new Q],transforms:[new I,new R],postTransforms:[]};var ee,ne=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o};function te(e,n){return e&&e[n]||[]}!function(e){e.PreTransforms="preTransforms",e.Transforms="transforms",e.PostTransforms="postTransforms"}(ee||(ee={}));const oe=function(){function e(e,n){this.weightMap=[],this.ops=[],this.vars=[],this.config={},this.type=m.SingleOutput,this.plugins=null,this.ops=e.ops,this.vars=e.vars,this.type=n.type||this.type,this.plugins=n.plugins,this.config=n,e.feedShape&&(this.config.feedShape=e.feedShape)}return e.prototype.createGraph=function(){return this.preTransforms(),this.createOpsMap(),this.arrangeMap(),this.postTransforms(),this.weightMap},e.prototype.preTransforms=function(){var e=this;ne($.preTransforms,te(this.plugins,ee.PreTransforms)).forEach((function(n){n.transform(e.ops,e.vars,e.config)}))},e.prototype.transforms=function(e,n){var t=this;ne($.transforms,te(this.plugins,ee.Transforms)).forEach((function(o){o.transform(e,t.vars,n)}))},e.prototype.postTransforms=function(){var e=this;ne($.postTransforms,te(this.plugins,ee.PostTransforms)).forEach((function(n){n.transform(e.weightMap,e.vars,e.type)}))},e.prototype.createOpsMap=function(){for(var e=[],n=0;n<this.ops.length;n++){var t=e.length,o=this.ops[n],r=new y(o,t);this.transforms(r,e),e.push(r)}this.weightMap=e},e.prototype.arrangeMap=function(){for(var e={},n=[],t={},o=function(o){for(var i=r.weightMap[o],a=0;a<i.outputsName.length;a++){var s=i.outputsName[a];e[s]=!0}n[o]=0,t[i.id]=o,i.inputsName.length>1?i.inputsName.forEach((function(t){!0===e[t]&&n[o]++})):n[o]=i.inputsName.length},r=this,i=0;i<this.weightMap.length;i++)o(i);this.topoSort(this.weightMap,n,t)},e.prototype.topoSort=function(e,n,t){var o=[];o.push(e[0]);for(var r=e.slice(0),i=null,a=e[0];o.length>0;){null!=i&&(e[t[i.id]].next=a.id),i=a,a=o.pop()||{};for(var s=0;s<a.outputsName.length;s++)for(var u=0;u<r.length;u++)for(var l=0;l<r[u].inputsName.length;l++)if(r[u].inputsName[l]===a.outputsName[s]&&(n[t[r[u].id]]--,0===n[t[r[u].id]])){o.push(e[t[r[u].id]]),r.splice(u,1),u--;break}}},e.prototype.getFeedExecutor=function(){return this.weightMap.find((function(e){return"feed"===e.type}))},e.prototype.getFetchExecutor=function(){return this.weightMap.find((function(e){return"fetch"===e.type}))},e.prototype.getExecutorById=function(e){return this.weightMap.find((function(n){return n.id===e}))},e}(),re=function(){function e(e){this.opts={},this.isPacked=!1,this.name="",this.tensorId="",this.total=1,this.shape=[],this.unformattedShapeLength=0,this.shape_texture=[],this.exceedMax=!1,this.data=null,this.persistable=!1,this.interpType="NEAREST",this.dataLayout="",this.runtime=0,this.binding=0;var n=e.isPacked,t=void 0!==n&&n,o=e.name,r=e.runtime,i=void 0===r?0:r,a=e.persistable,s=void 0!==a&&a,u=e.type,l=e.dataLayout,c=e.interpType,f=void 0===c?"NEAREST":c,h=e.shape,p=e.data,d=e.binding,g=void 0===d?0:d;this.opts=e,this.isPacked=t,this.name=o,this.runtime=i,this.binding=g,this.persistable=s,this.interpType=f,this.tensorId=u,this.dataLayout=l,this.unformattedShapeLength=h.length,this.shape=N(h),this.total=this.shape.reduce((function(e,n){return e*n})),e.noLayout||p&&p.length&&(this.data=function(e,n,t,o){if("nhwc"===n){var r=t[0],i=t[1],a=X(e,[r,t[2],t[3],i*(o?4:1)]);return new Float32Array(a)}return new Float32Array(e)}(p,this.dataLayout,this.shape,this.isPacked),e.data=null)}return Object.defineProperty(e.prototype,"width_texture",{get:function(){var e=this.shape_texture.length;return this.shape_texture[e-1]||1},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height_texture",{get:function(){var e=this.shape_texture.length;return this.shape_texture[e-2]||1},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"width_shape",{get:function(){var e=this.shape.length;return this.shape[e-1]},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height_shape",{get:function(){var e=this.shape.length;return this.shape[e-2]},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"channel",{get:function(){var e=this.shape.length;return this.shape[e-3]},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"length_shape",{get:function(){return this.shape.length||0},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"length_unformatted_shape",{get:function(){return this.unformattedShapeLength||0},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"total_shape",{get:function(){return this.total},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"numbers_shape",{get:function(){for(var e=[],n=this.shape.length,t=0;t<n-1;t++){var o=this.shape.slice(t+1).reduce((function(e,n){return e*n}));e.push(o)}return e.push(1),e},enumerable:!1,configurable:!0}),e}(),ie={adaptPaddings:function(){for(var e in this.processedAttrs)if(Object.prototype.hasOwnProperty.call(this.processedAttrs,e)&&"paddings"===e){var n=this.processedAttrs[e],t=n[0],o=n[1];return void(0===t&&1===o&&(this.processedAttrs[e][1]=0))}},setAdaptive:function(){this.processedAttrs.adaptive&&2===this.processedAttrs.ksize.length&&1===this.processedAttrs.ksize[0]&&1===this.processedAttrs.ksize[1]&&(this.processedAttrs.adaptive=!1,this.processedAttrs.global_pooling=!0)},isGlobalPooling:function(){var e,n=this.tensorDataMap.origin,t=(null===(e=null==n?void 0:n.shape)||void 0===e?void 0:e.length)||0;t>2&&this.processedAttrs.global_pooling&&(this.processedAttrs.ksize=[n.shape[t-2],n.shape[t-1]])},setPacked:function(){var e=this.processedAttrs.ispacked;this.tensorDataMap.origin&&e&&this.name.indexOf("pool")>-1&&(this.name+="_winograd")},mergeAttrs:function(){this.processedAttrs=this.subAttrs.reduce((function(e,n){return Object.assign(e,n)}),{})},isApplySeparableConv:function(){if(!this.isPackedOp){var e=this.processedAttrs.groups,n=this.tensorDataMap.filter;if("depthwise_conv2d"===this.name&&(this.name="conv2d"),n){var t=n.shape,o=t[0],r=t[1];o===e&&1===r&&(this.name+="_depthwise")}}},batchComputeConv2d:function(){var e=this.tensorDataMap.filter.shape[1];this.processedAttrs.filter_nearest_vec4=4*Math.floor(e/4),this.processedAttrs.filter_remainder_vec4=e%4},processBias:function(){var e=this.tensorDataMap.bias;if(e&&this.isPackedOp){e.packed=!0;var n=e.shape,t=[n[n.length-1]/4,1,1];e.shape=t}},isAdaptiveAvg:function(){var e=this.processedAttrs,n=e.adaptive,t=e.pooling_type;n&&"avg"===t&&(this.name+="_avg_adaptive")},isMax:function(){var e="max"===this.processedAttrs.pooling_type?1:0;this.processedAttrs.pooling_type=e,1===e&&(this.name+="_max")},transToPrelu:function(){this.processedAttrs.multi_value="0.0",this.processedAttrs.active_function="prelu"},transToRelu6:function(){this.processedAttrs.multi_value=this.processedAttrs.threshold,this.processedAttrs.active_function="relu6"},transToHardSigmoid:function(){this.processedAttrs.multi_value=this.processedAttrs.slope||.2,this.processedAttrs.bias_value=this.processedAttrs.offset||.5,this.processedAttrs.active_function="hardSigmoid"},transToLeakyrelu:function(){this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu",this.name="relu"},transToPow:function(){this.processedAttrs.multi_value=this.processedAttrs.factor||2,this.processedAttrs.active_function="pow_func",this.name="pow"},transToSigmoid:function(){this.processedAttrs.active_function="sigmoid"},transToSqrt:function(){this.processedAttrs.active_function="sqrt"},transToTanh:function(){this.processedAttrs.active_function="tanh_func"},transToExp:function(){this.processedAttrs.active_function="exp"},transToScale:function(){var e=this.processedAttrs.scale;this.processedAttrs.multi_value=void 0!==e?e:1,this.processedAttrs.bias_value=this.processedAttrs.bias||0;var n=this.processedAttrs.bias_after_scale;this.processedAttrs.active_function=n||void 0===n?"scale":"scaleWidthBias"},setActiveFunc:function(){var e=this.name.replace("conv2d-elementwise_add-","");this.processedAttrs=Object.assign({active_function:"scale",multi_value:"1.0",bias_value:"0.0",fuse_relu:!1},this.processedAttrs),"leaky_relu"===e&&(this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu")},normalizePerm:function(){var e=this.tensorDataMap.origin.shape.length,n=this.processedAttrs.axis,t=n.length;if(t-e>0&&(t=(n=n.map((function(e){return e-1})).filter((function(e){return e>=0}))).length),t>4)throw Error("op transpoes2 axis length exceeds maximum length 4, get "+t);for(var o=new Array(t).fill(0),r=0;r<t;r++)o[n[r]]=r;var i=[];for(r=0;r<4;r++)i[r]=o[r]||0;this.processedAttrs.perm_arr=i,this.processedAttrs.perm_size=t},normalizeDim:function(){for(var e=this.tensorDataMap.origin.shape,n=N(e),t=G(e,this.processedAttrs.axis),o=[],r=0;r<n[t];r++)o[r]=r;if(this.processedAttrs.target_length=o.length,this.processedAttrs.target_value=o,this.processedAttrs.inputs_dim=n[t],this.processedAttrs.dim=t,0===this.processedAttrs.num&&(this.processedAttrs.num=Object.values(this.tensorDataMap).filter((function(e){return"out"===e.tensorName})).length||1),"wasm"===f.get("backend")){this.processedAttrs.fourInputs=!1;var i=this.tensorDataMap.counter;if(i){var a=N(i.shape);this.processedAttrs.counter_num=a[t]}var s=this.tensorDataMap.appender;if(s){var u=N(s.shape);this.processedAttrs.append_num=u[t]}var l=this.tensorDataMap.fourth;if(l){this.processedAttrs.fourInputs=!0;var c=N(l.shape);this.processedAttrs.fourth_num=c[t]}}},processElementwiseAxis:function(){var e=this.tensorDataMap.origin.shape,n=this.tensorDataMap.counter.shape,t=void 0===this.processedAttrs.axis?-1:this.processedAttrs.axis;this.processedAttrs.counterLen=n.length,B(e)===B(n)?(this.processedAttrs.axis=0,this.processedAttrs.counterLen=4):(-1===t&&(t=e.length-n.length),this.processedAttrs.axis=G(e,t))},genElementwiseCounterPos:function(){for(var e=this.processedAttrs,n=e.counterLen,t=["0","0","0","0"],o=e.axis,r=4-n;r<4;r++)t[r]="oPos["+o+++"]";this.processedAttrs.counterPos=t.join(",")},flattenShape:function(){var e=Object.values(this.tensorDataMap).find((function(e){return e.shape.length>2}));if(e){var n=N(e.shape);e.shape=[n[0]*n[2],n[1]*n[3]]}},reshape:function(){var e=this.tensorDataMap.origin,n=this.tensorDataMap.counter,t=this.tensorDataMap.out;if(n.shape.length>e.shape.length){var o=n;n=e,e=o}if(e.shape.length>2&&2===n.shape.length){var r=function(e,n){void 0===e&&(e=[]),void 0===n&&(n=[]);var t=e.reduce((function(e,n){return e*n}));return 1===n.length?[1,t]:[n[0],t/n[0]]}(e.shape,t.shape);e.shape=r}},checkIsMerge:function(){var e=this.name.replace("conv2d-elementwise_add-","");this.name="conv2d_elementwise_add","leaky_relu"===e&&(this.processedAttrs.alpha&&(this.processedAttrs.multi_value=this.processedAttrs.alpha),this.processedAttrs.active_function="leakyRelu")}};var ae=function(){return(ae=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var r in n=arguments[t])Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);return e}).apply(this,arguments)};const se=function(){function e(e,n,t,o,r){this.name="",this.isPackedOp=!1,this.processedAttrs={},this.subAttrs=[],this.uniform=null,this.inputTensors=[],this.outputTensors=[],this.dataLayout="",this.iLayer=0,this.program=[],this.isFinalOp=!1,this.bufferType=g.FrameBuffer,this.tensorDataMap={},this.tensorData=[];var i=e.type,a=e.inputs,s=e.outputs,u=e.attrs,l=e.isPacked,c=e.bufferType,f=void 0===c?g.FrameBuffer:c,h=e.uniform,p=void 0===h?null:h;this.modelName=r,this.subAttrs=e.subAttrs,this.name=i,this.isPackedOp=l,this.bufferType=f,this.dataLayout=t.dataLayout||"",this.iLayer=n,this.isFinalOp=o,this.uniform=p,this.initExtendedAttrs(u),this.constructTensorData(a,s,t.vars),this.buildTensor();var d=this.buildShaderParams();this.buildProgram(d)}return e.prototype.initExtendedAttrs=function(e){for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var t=e[n];this.processedAttrs[n]=t}},e.prototype.constructTensorData=function(e,n,t){var o=this;Object.keys(n).forEach((function(e){n[e].forEach((function(r,i){n[e][i]=o.getTensorVar(r,t)}))})),Object.keys(e).forEach((function(n){e[n]=[o.getTensorVar(e[n][0],t)]}));var r=function(e){if(Object.prototype.hasOwnProperty.call(n,e))try{var t=n[e]||[{}],r=i.getExactTensorName(e,"output");r&&t.forEach((function(e,n){e.tensorName=r,o.tensorDataMap[r+"_"+n]=ae(ae({},e),{tensorName:r,runtime:n})}))}catch(e){console.error(e)}},i=this;for(var a in n)r(a);for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var s=e[a].length>0?e[a]:[{}],u=this.getExactTensorName(a,"input");if(u){var l=s[0];l.tensorName=u,this.tensorDataMap[u]=ae(ae({},l),{tensorName:u})}}},e.prototype.getExactTensorName=function(e,n){return"input"===n?{input:"origin",x:"origin",y:"counter",w:"weight"}[e.toLowerCase()]||e.toLowerCase():{output:"out",y:"out",out:"out",scale:"scale",bias:"bias",mean:"mean",variance:"variance",mask:"out",boxes:"out",variances:"out"}[e.toLowerCase()]},e.prototype.getTensorVar=function(e,n){var t=s(n,e.replace(/_packed$/,""));return t&&e.endsWith("_packed")?function(e,n){var t=3===e.shape.length?j([1],e.shape):e.shape,o=t[0],r=t[1],i=t[2],a=t[3],s=Object.assign({},e);if(s.name=n,s.packed=!1,r%4==0){var u=r/4;s.packed=!0,s.shape=[o,u,i,a]}return s}(t,e):t},e.prototype.buildProgram=function(e){var n=this,t=this.name,o=x.backend+"_"+t,r=x.opRegistry.ops[o];try{if(!r&&"wasm"!==f.get("backend"))throw new Error("[unregistered op] "+t);var i=this.inputTensors;this.program=this.outputTensors.map((function(t,o){return x.backendInstance.createProgram({op:r,outTensor:t,inputTensors:i,shaderParams:e[o],runtime:o,isFinalOp:n.isFinalOp})}))}catch(e){console.error(e)}},e.prototype.processTensorDataAndAttrs=function(){var e=this;try{this.name.indexOf("conv2d-elementwise_add")>-1?this.name="conv2d_elementwise_add":this.name.indexOf("max_pool2d_with_index")>-1&&(this.name="pool2d_max");var n=x.backend+"_"+this.name;(x.opRegistry.ops[n]&&x.opRegistry.ops[n].behaviors||[]).forEach((function(n){try{ie[n].call(e)}catch(e){console.error(e)}}))}catch(e){console.error(e)}},e.prototype.buildTensor=function(){var e=this;this.processTensorDataAndAttrs();var n=Object.values(this.tensorDataMap);n.forEach((function(n,t){var o,r=n.tensorName,i=new re({type:e.modelName+"_"+n.name,name:r,shape:n.shape,data:n.data||null,persistable:n.persistable||!1,interpType:n.interpType||"NEAREST",isPacked:e.isPackedOp||n.packed||!1,binding:t,noLayout:null===(o=x.backendInstance)||void 0===o?void 0:o.noLayout,dataLayout:e.dataLayout,runtime:n.runtime||0});"out"===r?e.outputTensors.push(i):e.inputTensors.push(i),n.shape=i.shape,n.total=i.total})),this.tensorDataMap=null,this.tensorData=n},e.prototype.buildShaderParams=function(){var e=this,n=[];return this.outputTensors.forEach((function(){var t=JSON.parse(JSON.stringify(e.processedAttrs));n.push(t)})),n},e}();var ue=function(){return(ue=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var r in n=arguments[t])Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);return e}).apply(this,arguments)};const le=function(){function e(){this.targetContext={},this.gapFillWith="#fff",this.mean=[0,0,0],this.std=[1,1,1],this.bgr=!1,this.pixelWidth=1,this.pixelHeight=1,this.inputFeed=[],this.targetCanvas=f.get("canvas2d")||document.createElement("canvas"),this.targetContext=this.targetCanvas.getContext("2d")}return e.prototype.process=function(e,n,t){var o=n.fill,r=n.mean,i=n.std,a=n.bgr,s=n.keepRatio,u=void 0===s||s,l=n.scale,c=void 0===l?0:l,f=t.fc,h=void 0===f?3:f,p=t.fh,d=t.fw,g=e,_={gapFillWith:o||this.gapFillWith,mean:r||this.mean,std:i||this.std,bgr:a||this.bgr,keepRatio:u,scale:c,targetSize:{width:d,height:p},targetShape:[1,h,p,d]};return this.fromPixels(g,_)||[]},e.prototype.fromPixels=function(e,n){var t=[],o={gapFillWith:n.gapFillWith,dx:0,dy:0,dWidth:n.targetSize.width,dHeight:n.targetSize.height},r=e,i=e.path&&e.width&&e.height;if(!i&&!(e instanceof ImageBitmap||e instanceof HTMLVideoElement||e instanceof HTMLImageElement||e instanceof HTMLCanvasElement))return[{data:t,shape:n.shape||n.targetShape,name:"image",persistable:!0}];this.pixelWidth=e.naturalWidth||e.width,this.pixelHeight=e.naturalHeight||e.height;var a=f.get("webgl_gpu_pipeline")||n.webglFeedProcess;return this.fitToTargetSize(i?r.path:r,o,ue(ue({},n),{inGPU:a})),t=this.getImageData(o),a?[{data:t=Float32Array.from(t.data),shape:[1,1,o.dHeight,o.dWidth],name:"image",persistable:!0}]:[{data:t=this.allReshapeToRGB(t,n),shape:n.targetShape||n.shape,name:"image",persistable:!0}]},e.prototype.allReshapeToRGB=function(e,n){for(var t=n.mean,o=n.std,r=n.targetShape,i=n.bgr,a=n.normalizeType,s=void 0===a?0:a,u=r[1],l=r[2],c=r[3],f=e.data||e,h=new Float32Array(l*c*u),p=0,d=0;d<l;++d)for(var g=d*c,_=0;_<c;++_)for(var v=g+_,m=0;m<u;++m){var x=i?4*v+(2-m):4*v+m;h[p]=0===s?f[x]/255:(f[x]-128)/128,h[p]-=t[m],h[p]/=o[m],p++}return X(h,[1,l,c,u])},e.prototype.fitToTargetSize=function(e,n,t){var o=t||{},r=o.keepRatio,i=void 0===r||r,a=o.inGPU,s=void 0!==a&&a,u=o.scale,l=void 0===u?0:u,c=n.dWidth,f=n.dHeight,h=s?this.pixelWidth:c,p=s?this.pixelHeight:f,d=s?this.pixelWidth:c,g=s?this.pixelHeight:f,_=0,v=0;if(l){if(d-c<0||g-f<0)throw new Error("scale size smaller than target size");this.pixelWidth>this.pixelHeight?(g=l,d=Math.round(g*this.pixelWidth/this.pixelHeight)):(d=l,g=Math.round(d*this.pixelHeight/this.pixelWidth)),this.targetCanvas.width=h=d,this.targetCanvas.height=p=g,n.dx=(d-c)/2,n.dy=(g-f)/2}else i&&(c/f*this.pixelHeight/this.pixelWidth>=1?s?(h=Math.round(g*c/f),_=Math.floor((h-d)/2)):(d=Math.round(g*this.pixelWidth/this.pixelHeight),_=Math.floor((c-d)/2)):s?(p=Math.round(d*f/c),v=Math.floor((p-g)/2)):(g=Math.round(d*this.pixelHeight/this.pixelWidth),v=Math.floor((f-g)/2))),this.targetCanvas.width=n.dWidth=h,this.targetCanvas.height=n.dHeight=p;this.targetContext.fillStyle=n.gapFillWith,this.targetContext.fillRect(0,0,this.targetCanvas.width,this.targetCanvas.height),this.targetContext.drawImage(e,_,v,d,g)},e.prototype.getImageData=function(e){var n=e.dx,t=e.dy,o=e.dWidth,r=e.dHeight;return this.targetContext.getImageData(n,t,o,r)},e.prototype.cover=function(e,n,t,o){var r=t,i=o;return t/o*n/e>=1?r=Math.round(i*e/n):i=Math.round(r*n/e),[r/t,i/o]},e}();var ce=function(){return(ce=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var r in n=arguments[t])Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);return e}).apply(this,arguments)};function fe(e,n,t){for(var o=[],r=0,i=e.length;r<i;r++){var a=e[r];a>n&&o.push({score:a,i:r})}return o.sort((function(e,n){return n.score-e.score})).slice(0,t)}function he(e){var n=e[0],t=e[1],o=e[2],r=e[3];return o<n||r<t?0:(o-n)*(r-t)}function pe(e,n){if(n[0]>e[2]||n[2]<e[0]||n[1]>e[3]||n[3]<e[1])return 0;var t=he(e),o=he(n),r=function(e,n){var t=e[0],o=e[1],r=e[2],i=e[3],a=n[0],s=n[1],u=n[2],l=n[3],c=Math.max(t,a),f=Math.max(o,s);return(Math.min(r,u)-c)*(Math.min(i,l)-f)}(e,n);return r/(t+o-r)}const de={multiclass_nms:function(e,n){var t=e[0],o=void 0===t?[]:t,r=e[1],i=void 0===r?[]:r,a=H(o),s=H(i);if(!a||!s)return[];if(a=a[0],s=s[0],!(a&&a.length&&s&&s.length))return[];for(var u=n.nms_top_k,l=void 0===u?100:u,c=n.nms_eta,f=void 0===c?1:c,h=n.keep_top_k,p=void 0===h?100:h,d=n.background_label,g=void 0===d?0:d,_=n.nms_threshold,v=void 0===_?.3:_,m=n.score_threshold,x=void 0===m?0:m,P=[],b=0,T=s.length;b<T;b++){var y=[];if(b!==g){var F=fe(s[b],x,l);if(F&&F.length){var w=F.shift(),E=a[w.i];for(y.push(ce(ce({},w),{box:E,label:b}));F.length;){var A=F.shift();E=a[A.i];for(var O=!0,V=0,C=y;V<C.length;V++)if(pe(E,C[V].box)>v){O=!1;break}O&&y.push(ce(ce({},A),{box:E,label:b})),O&&f<1&&v>.5&&(v*=f)}P=P.concat(y)}}}var R=P.sort((function(e,n){return n.score-e.score})).slice(0,p).sort((function(e,n){return e.label-n.label})).map((function(e){return function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}([e.label,e.score],e.box)}));return R&&R.length?R:[]}};var ge=function(e,n,t,o){return new(t||(t=Promise))((function(r,i){function a(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,s)}u((o=o.apply(e,n||[])).next())}))},_e=function(e,n){var t,o,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,o=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((r=(r=a.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){a.label=i[1];break}if(6===i[0]&&a.label<r[1]){a.label=r[1],r=i;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(i);break}r[2]&&a.ops.pop(),a.trys.pop();continue}i=n.call(e,a)}catch(e){i=[6,e],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}};const ve=function(){function e(e){this.runnerConfig={},this.isPaused=!1,this.model={},this.weightMap=[],this.isExecuted=!1,this.test=!1,this.graphGenerator={},this.mediaProcessor=null,this.needPreheat=!0,this.feedShape={},this.runnerConfig=Object.assign({},e),this.needPreheat=void 0===e.needPreheat||e.needPreheat,this.modelName=e.modelName||Date.now().toString(),this.weightMap=[],f.set("ns",i()),"node"!==f.get("platform")&&(this.mediaProcessor=new le)}return e.prototype.init=function(){return ge(this,void 0,void 0,(function(){var e;return _e(this,(function(n){switch(n.label){case 0:return x.backendInstance?(this.isExecuted=!1,"wasm"!==f.get("backend")?[3,2]:[4,Promise.all([this.load(),x.backendInstance.init()])]):(console.error("ERROR: Haven't register backend"),[2]);case 1:return n.sent(),[3,5];case 2:return[4,x.backendInstance.init()];case 3:return n.sent(),[4,this.load()];case 4:n.sent(),n.label=5;case 5:return this.genFeedData(),this.genGraph(),this.genOpData(),"wasm"!==f.get("backend")?[3,7]:(this.model=Object.assign(this.model,this.runnerConfig),e=this.model,[4,x.backendInstance.initWasm(this.model,this.weightMap)]);case 6:return e.index=n.sent(),[2,[]];case 7:return this.needPreheat?[4,this.preheat()]:[3,9];case 8:return[2,n.sent()];case 9:return[2]}}))}))},e.prototype.load=function(){return ge(this,void 0,void 0,(function(){var e,n,t,o,r,i,a,s;return _e(this,(function(u){switch(u.label){case 0:return e=this.runnerConfig,n=e.modelPath,t=e.modelObj,o=void 0===t?null:t,n?(r=new d(n),i=this,[4,r.load()]):[3,2];case 1:return i.model=u.sent(),[3,3];case 2:(null==o?void 0:o.model)&&(null==o?void 0:o.params)&&(a=o.model,s=o.params,d.allocateParamsVar(a.vars,s),this.model=a),u.label=3;case 3:return[2]}}))}))},e.prototype.genGraph=function(){this.graphGenerator=new oe(this.model,this.runnerConfig),this.weightMap=this.graphGenerator.createGraph()},e.prototype.genOpData=function(){var e=this,n=0;this.weightMap.forEach((function(t,o){var r=t.type;if("feed"!==r&&"fetch"!==r){n++;var i=o===e.weightMap.length-2,a=new se(t,n,e.model,i,e.modelName);t.opData=a}})),c(this.model)},e.prototype.preheat=function(){return ge(this,void 0,void 0,(function(){var e;return _e(this,(function(n){switch(n.label){case 0:return[4,this.checkModelLoaded()];case 1:return n.sent(),[4,this.execute()];case 2:return e=n.sent(),this.isExecuted=!0,[2,e]}}))}))},e.prototype.checkModelLoaded=function(){return ge(this,void 0,void 0,(function(){return _e(this,(function(e){switch(e.label){case 0:return 0!==this.weightMap.length?[3,2]:(console.info("It's better to preheat the model before running."),[4,this.load()]);case 1:e.sent(),this.genFeedData(),this.genGraph(),this.genOpData(),this.isExecuted=!1,e.label=2;case 2:return[2]}}))}))},e.prototype.predict=function(e,n){return ge(this,void 0,void 0,(function(){var t,o,r;return _e(this,(function(i){switch(i.label){case 0:return this.isPaused||!this.mediaProcessor?[2]:(t=[],t=this.runnerConfig.webglFeedProcess?[e]:this.mediaProcessor.process(e,this.runnerConfig,this.feedShape),o=[],"wasm"!==f.get("backend")?[3,3]:[4,x.backendInstance.predict(t[0].data,this.model.index)]);case 1:return i.sent(),[4,this.read()];case 2:return r=i.sent(),o=this.postProcess(r),[3,5];case 3:return this.updateFeedData(t),[4,this.execute()];case 4:o=i.sent(),i.label=5;case 5:return this.isExecuted=!0,[2,n?n(o):o]}}))}))},e.prototype.predictWithFeed=function(e,n,t){var o;return ge(this,void 0,void 0,(function(){var r,i,a,s,u,l,c,h,p,d,g,_;return _e(this,(function(v){switch(v.label){case 0:return r=this.feedShape,i=r.fc,a=void 0===i?3:i,s=r.fw,u=r.fh,Array.isArray(e)?(null===(o=e[0])||void 0===o?void 0:o.data)?((d=e[0].data)instanceof Float32Array||(e[0].data=new Float32Array(d)),l=e):l=[{data:new Float32Array(e),shape:t||[1,a,u,s],name:"image",persistable:!0}]:(h=(c=e).width,p=c.height,d=c.data,l=[{data:new Float32Array(d),shape:t||[1,a,p||u,h||s],name:"image",persistable:!0}]),g=[],"wasm"!==f.get("backend")?[3,3]:[4,x.backendInstance.predict(l[0].data,this.model.index)];case 1:return v.sent(),[4,this.read()];case 2:return _=v.sent(),g=this.postProcess(_),[3,5];case 3:return this.updateFeedData(l),[4,this.execute()];case 4:g=v.sent(),v.label=5;case 5:return this.isExecuted=!0,[2,n?n(g):g]}}))}))},e.prototype.genFeedData=function(){var e,n=this.runnerConfig,t=n.type,o=n.feedShape,r=n.webglFeedProcess;this.feedShape=this.model.feedShape||o;var i,a=this.feedShape,l=a.fc,c=void 0===l?3:l,h=a.fh,p=a.fw,d=this.model.vars;if(t===m.MultipleInput){var g=this.model.ops&&this.model.ops[0]&&(null===(e=this.model.ops[0].inputs)||void 0===e?void 0:e.X);g.length>1&&(i=g.map((function(e){var n=s(d,e),t=n.shape.reverse(),o=t[0],r=t[1],i=t[2],a=t[3],u=void 0===a?1:a;return n.data=new Float32Array(u*i*r*o),n})))}else{var _="wasm"!==f.get("backend")&&r?4:c;i=s(d,"image");var v={name:"image",shape:[1,_,h,p]};i=Object.assign(v,i,{data:new Float32Array(_*h*p).fill(1),persistable:!0})}u(d,i)},e.prototype.updateFeedData=function(e){var n=e[0],t=this.weightMap.find((function(e){return e.opData?e.opData.inputTensors.find((function(e){return e.tensorId.endsWith("_image")})):null})),o=t.opData.inputTensors.find((function(e){return e.tensorId.endsWith("_image")}));o.data=n.data;var r=this.runnerConfig,i=r.webglFeedProcess,a=void 0!==i&&i,s=r.keepRatio,u=void 0===s||s;if(a||f.get("webgl_gpu_pipeline")){var l=n.shape||[1,1,n.height,n.width],c=new Uint8Array(n.data||[]);if(n.width&&n.height&&!n.data){var h=n.naturalWidth||n.width;l=[1,1,n.naturalHeight||n.height,h],c=n}var p=o.opts;p.shape=l;var d=t.opData,g=new re(p);g.data=c,d.inputTensors=[g];var _=l.slice(-2),v=_[0],m=_[1],x=d.outputTensors[0].shape.slice(-2),P=x[0],b=x[1],T=this.mediaProcessor.cover(m,v,b,P);t.uniform.u_scale.value=T,t.uniform.u_keep_ratio.value=+u}},e.prototype.execute=function(){return ge(this,void 0,void 0,(function(){var e,n;return _e(this,(function(t){switch(t.label){case 0:return e=this.graphGenerator.getFeedExecutor(),this.executeOp(e),[4,this.read()];case 1:return n=t.sent(),[2,this.postProcess(n)]}}))}))},e.prototype.postProcess=function(e){var n="wasm"===f.get("backend");if(f.get("debug"))return e;var t=e,o=this.model,r=o.multiOutputs,i=o.postOps;if(r)if(n)t=r.map((function(n,t){var o;return(o={})[n.name]=e[t],o}));else{var a=0;t=r.map((function(n){var t,o=n.shape.reduce((function(e,n){return e*n})),r=e.slice(a,o+a);return a+=o,(t={})[n.name]=r,t}))}if(r&&i&&i.length)for(var s=function(e,n){var o=i[e],r=o.type,a=o.attrs,s=o.inputs,u=de[r];if(!u)return{value:void 0};var l=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}(t),c=Object.keys(s).map((function(e){var n=s[e],t=n.name,o=n.shape,r=l.filter((function(e){return e[t]}));return r&&r[0]&&r[0][t]?{name:e,tensorId:t,data:r[0][t],shape:o}:(console.error("未获取到"+t+"的数据"),null)}));t=u(c,a)},u=0,l=i.length;u<l;u++){var c=s(u);if("object"==typeof c)return c.value}return t},e.prototype.executeOp=function(e){var n;if("fetch"!==e.type)if("feed"!==e.type&&e.execute(this.isExecuted),f.get("debug")&&(null===(n=e.opData)||void 0===n?void 0:n.outputTensors)&&e.opData.outputTensors[e.opData.outputTensors.length-1]&&e.opData.outputTensors[e.opData.outputTensors.length-1].tensorId===this.modelName+"_"+(f.get("ns").layerName||f.get("layerName")))console.info(e.opData.name+"_"+e.opData.iLayer,"runner op");else if(e.next){var t=e.next,o=this.graphGenerator.getExecutorById(t);this.executeOp(o)}},e.prototype.read=function(){return ge(this,void 0,void 0,(function(){var e,n,t;return _e(this,(function(o){switch(o.label){case 0:return e=this.graphGenerator.getFetchExecutor(),n=s(this.model.vars,e.inputs.X[0]),t={name:n.name,shape:e.attrs.origin_shape||n.shape,index:this.model.index},[4,x.backendInstance.read(t)];case 1:return[2,o.sent()]}}))}))},e.prototype.stopPredict=function(){this.isPaused=!0},e}(),me=function(){}},993:()=>{}},n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={exports:{}};return e[o](r,r.exports,t),r.exports}return t.d=(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t(994)})()},function(e,n,t){e.exports=(()=>{"use strict";var e={400:(e,n,t)=>{t.r(n),t.d(n,{GLHelper:()=>T,glInstance:()=>Fe,ops:()=>ye,webgl_types:()=>o});var o={};t.r(o),t.d(o,{UniformType:()=>f});var r={};t.r(r),t.d(r,{exp_func:()=>N,hardSigmoid:()=>M,leakyRelu:()=>S,pow_func:()=>U,prelu:()=>C,relu6:()=>R,scale:()=>I,scaleWidthBias:()=>k,sigmoid:()=>D,sqrt:()=>L,tanh_func:()=>j,transferFromNHWCtoNCHW:()=>V});var i={};function a(){var e;if("undefined"!=typeof window)e=window;else if(void 0!==t.g)e=t.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}return e}function s(e,n){var t=a();return t[e]||(t[e]=n),t[e]}t.r(i),t.d(i,{getPixelsFromTexturePos:()=>H,getSamplerCode:()=>z,getTensorPosFromArrayIndex:()=>X,getValueFromTensorPos:()=>B,getValueFromTensorPosPacking:()=>G,moveTexture2PosToReal:()=>W});var u={opRegistry:{ops:{}},backend:"",backendInstance:null};u=s("GLOBALS",u);var l=a();l.ImageBitmap||(l.ImageBitmap=function(){});const c=s("env",new(function(){function e(){this.ENV={}}return e.prototype.set=function(e,n){this.ENV[e]=n},e.prototype.get=function(e){return this.ENV[e]},e}()));var f,h,p,d;function g(e){for(var n=e.length,t=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}(e),o=[];n>1;)t.splice(0,1),o.push(t.reduce((function(e,n){return e*n}))),n--;return o}function _(e,n){if(1===e.length)return"float "+n+" = float("+e[0]+");";for(var t=e.length,o="\n        vec"+t+" "+n+" = vec"+t+"(\n    ",r=0;r<t;r++)o+="float("+e[r]+"),";return o.slice(0,-1)+");"}function v(e,n,t){if(0===e.length)return"";if(2===c.get("webglVersion"))return e.reduce((function(n,o,r){return n+(r<e.length-1?t+"("+o+"), ":t+"("+o+"));")}),t+" "+n+"[] = "+t+"[](");var o=e.reduce((function(e,o,r){return e+"\n            "+n+"["+r+"] = "+t+"("+o+");"}),"");return"\n        "+t+" "+n+"["+e.length+"];\n        "+o+"\n    "}function m(e,n,t){if(0===e.length)return"";var o=e.reduce((function(e,n,o){return e+(0===o?"\n            "+t+" res = "+t+"(0);\n            if (index == "+o+") {\n                res = arr["+o+"];\n            }":"\n            else if (index == "+o+") {\n                res = arr["+o+"];\n            }")}),"");return"\n    "+t+" getValueFromArrByIndex_"+n+"("+t+"["+e.length+"] arr, int index) {\n        "+(2===c.get("webglVersion")?t+" res = arr[index];":o)+"\n        return res;\n    }\n    "}!function(e){e.uniform1f="1f",e.uniform1fv="1fv",e.uniform1i="1i",e.uniform1iv="1iv",e.uniform2f="2f",e.uniform2fv="2fv",e.uniform2i="2i",e.uniform2iv="2iv",e.uniform3f="3f",e.uniform3fv="3fv",e.uniform3i="3i",e.uniform3iv="3iv",e.uniform4f="4f",e.uniform4fv="4fv",e.uniform4i="4i",e.uniform4iv="4iv"}(f||(f={})),function(e){e.INT_TYPE="int",e.FLOAT_TYPE="float"}(h||(h={})),function(e){e[e.VS_SHADER=0]="VS_SHADER",e[e.FS_SHADER=1]="FS_SHADER"}(p||(p={})),function(e){e[e.FLOAT_VEC2=35664]="FLOAT_VEC2",e[e.FLOAT_VEC3=35665]="FLOAT_VEC3",e[e.FLOAT_VEC4=35666]="FLOAT_VEC4",e[e.INT_VEC2=35667]="INT_VEC2",e[e.INT_VEC3=35668]="INT_VEC3",e[e.INT_VEC4=35669]="INT_VEC4",e[e.BOOL=35670]="BOOL",e[e.BOOL_VEC2=35671]="BOOL_VEC2",e[e.BOOL_VEC3=35672]="BOOL_VEC3",e[e.BOOL_VEC4=35673]="BOOL_VEC4",e[e.FLOAT_MAT2=35674]="FLOAT_MAT2",e[e.FLOAT_MAT3=35675]="FLOAT_MAT3",e[e.FLOAT_MAT4=35676]="FLOAT_MAT4",e[e.SAMPLER_2D=35677]="SAMPLER_2D",e[e.SAMPLER_CUBE=35678]="SAMPLER_CUBE",e[e.FLOAT=5126]="FLOAT",e[e.INT=5124]="INT"}(d||(d={}));var x,P=function(e,n,t){this.size=e,this.type=n,this.location=t},b=function(e,n,t){this.size=e,this.type=n,this.location=t},T=function(){function e(){}return e.getWebglVersion=function(){return c.get("webglVersion")},e.createCanvas=function(){return c.get("canvas")||document&&document.createElement("canvas")},e.setWebglVersion=function(e){c.set("webglVersion",e)},e.setWebGLRenderingContext=function(e){return this.gl=e,e},e.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},e.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var e=this.createCanvas();if(!e)return null;e.addEventListener&&e.addEventListener("webglcontextlost",(function(e){throw e.preventDefault(),Error("webgl context is lost~")}),!1);var n=e.getContext("webgl2",this.WEBGL_ATTRIBUTES);return n?c.set("webglVersion",2):(c.set("webglVersion",1),n=e.getContext("webgl",this.WEBGL_ATTRIBUTES)||e.getContext("experimental-webgl",this.WEBGL_ATTRIBUTES)),n},e.printStates=function(e){console.log("1. isBlendEnable = "+e.isEnabled(e.BLEND)),console.log("2. isCullFaceEnable = "+e.isEnabled(e.CULL_FACE)),console.log("3. isDepthTestEnable = "+e.isEnabled(e.DEPTH_TEST)),console.log("4. isDitherEnable = "+e.isEnabled(e.DITHER)),console.log("5. isPolygonOffsetFillEnable = "+e.isEnabled(e.POLYGON_OFFSET_FILL)),console.log("6. isSampleAlphtToCoverageEnable = "+e.isEnabled(e.SAMPLE_ALPHA_TO_COVERAGE)),console.log("7. isSampleCoverageEnable = "+e.isEnabled(e.SAMPLE_COVERAGE)),console.log("8. isScissorTestEnable = "+e.isEnabled(e.SCISSOR_TEST)),console.log("9. isStencilTestEnable = "+e.isEnabled(e.STENCIL_TEST))},e.printWebGLInfo=function(e){console.log("renderer = "+e.getParameter(e.RENDERER)),console.log("version = "+e.getParameter(e.VERSION)),console.log("vendor = "+e.getParameter(e.VENDOR)),console.log("glsl version = "+e.getParameter(e.SHADING_LANGUAGE_VERSION))},e.printWebGLTextureInfo=function(e){console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ",e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_IMAGE_UNITS = ",e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_SIZE = ",e.getParameter(e.MAX_TEXTURE_SIZE)),console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ",e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE))},e.triggerContextLostEvent=function(e){var n=e.getExtension("WEBGL_lose_context");null!==n&&n.loseContext()},e.checkGLError=function(e){var n=e.getError();return 0!==n&&(console.log("WebGL Error NO: ",n),!0)},e.setDefaultState=function(e){e.clearColor(0,0,0,0),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.enable(e.SCISSOR_TEST)},e.setViewport=function(e,n){e.viewport(n[0],n[1],n[2],n[3])},e.initShader=function(e,n,t){var o=this.createShader(e,n);return this.compileShader(e,t,o),o},e.createShader=function(e,n){var t;if(null===(t=n===p.VS_SHADER?e.createShader(e.VERTEX_SHADER):e.createShader(e.FRAGMENT_SHADER)))throw new Error("WebGLShader创建失败！");return t},e.compileShader=function(e,n,t){return e.shaderSource(t,n),e.compileShader(t),!1!==e.getShaderParameter(t,e.COMPILE_STATUS)||(console.error(e.getShaderInfoLog(t)),e.deleteShader(t),!1)},e.createProgram=function(e){var n=e.createProgram();if(null===n)throw new Error("WebGLProgram创建失败！");return n},e.linkProgram=function(e,n,t,o,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),e.attachShader(n,t),e.attachShader(n,o),null!==r&&r(e,n),e.linkProgram(n),!1===e.getProgramParameter(n,e.LINK_STATUS)?(console.error(e.getProgramInfoLog(n)),e.deleteShader(t),e.deleteShader(o),e.deleteProgram(n),!1):(e.validateProgram(n),!1===e.getProgramParameter(n,e.VALIDATE_STATUS)?(console.error(e.getProgramInfoLog(n)),e.deleteShader(t),e.deleteShader(o),e.deleteProgram(n),!1):(null!==i&&i(e,n),!0))},e.getProgramActiveAttribs=function(e,n,t){for(var o=e.getProgramParameter(n,e.ACTIVE_ATTRIBUTES),r=0;r<o;r++){var i=e.getActiveAttrib(n,r);i&&(t[i.name]=new b(i.size,i.type,e.getAttribLocation(n,i.name)))}},e.getProgramAtciveUniforms=function(e,n,t){for(var o=e.getProgramParameter(n,e.ACTIVE_UNIFORMS),r=0;r<o;r++){var i=e.getActiveUniform(n,r);if(i){var a=e.getUniformLocation(n,i.name);null!==a&&(t[i.name]=new P(i.size,i.type,a))}}},e.createBuffer=function(e){var n=e.createBuffer();if(null===n)throw new Error("WebGLBuffer创建失败！");return n},e.getColorBufferData=function(e){var n=new Uint8Array(e.drawingBufferWidth*e.drawingBufferHeight*4);return e.readPixels(0,0,e.drawingBufferWidth,e.drawingBufferHeight,e.RGBA,e.UNSIGNED_BYTE,n),n},e.setUniformParam=function(e,n,t,o){switch(t){case f.uniform1f:e.uniform1f(n,o);break;case f.uniform1fv:e.uniform1fv(n,o);break;case f.uniform1i:e.uniform1i(n,o);break;case f.uniform1iv:e.uniform1iv(n,o);break;case f.uniform2f:e.uniform2f(n,o[0],o[1]);break;case f.uniform2fv:e.uniform2fv(n,o);break;case f.uniform2i:e.uniform2i(n,o[0],o[1]);break;case f.uniform2iv:e.uniform2iv(n,o);break;case f.uniform3f:e.uniform3f(n,o[0],o[1],o[2]);break;case f.uniform3fv:e.uniform3fv(n,o);break;case f.uniform3i:e.uniform3i(n,o[0],o[1],o[2]);break;case f.uniform3iv:e.uniform3iv(n,o);break;case f.uniform4f:e.uniform4f(n,o[0],o[1],o[2],o[3]);break;case f.uniform4fv:e.uniform4fv(n,o);break;case f.uniform4i:e.uniform4i(n,o[0],o[1],o[2],o[3]);break;case f.uniform4iv:e.uniform4iv(n,o);break;default:console.error("["+t+"]: unknown uniform type")}},e.genTextureInfoFromTensorShape=function(e,n){var t=e||4096,o=n.shape,r=void 0===o?[]:o,i=r[0],a=r[1],s=r[2],u=r[3];if(i*s<=t&&a*u<=t)n.shape_texture=[i*s,a*u];else{var l=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}(r).sort((function(e,n){return e-n})),f=l[0],h=l[1],p=l[2],d=f*l[3],g=h*p;if(d>t||g>t){var _=[d,g].sort((function(e,n){return e-n})),v=_[0],m=_[1],x=function(e,n){var t=n;if(e%t==0)return t;for(;t<e&&e%t!=0;)t++;return t}(m,Math.ceil(m/t));if(d=v*x,g=Math.ceil(m/x),c.get("debug")&&console.error("大小超限",r,[g,d]),d>t||g>t)throw new Error("Requested texture size ["+d+"x"+g+"] greater than WebGL maximum on this browser / GPU ["+t+"x"+t+"].")}n.shape_texture=[g,d]}},e.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"high-performance"},e.gl=null,e}();!function(e){e[e.GL_REPEAT=0]="GL_REPEAT",e[e.GL_MIRRORED_REPEAT=1]="GL_MIRRORED_REPEAT",e[e.GL_CLAMP_TO_EDGE=2]="GL_CLAMP_TO_EDGE"}(x||(x={}));var y=function(){function e(){}return e.getTextureConfig=function(e){var n,t,o,r,i,a,s,u,l=e,f=!0,h=!0;return 2===c.get("webglVersion")?(n=l.getExtension("EXT_color_buffer_float"),o=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,a=l.R16F,s=l.RGBA16F,t=l.RED,u=l.RGBA32F):(r=l.RGBA,a=l.RGBA,s=l.RGBA,i=l.RGBA,t=l.RGBA,u=l.RGBA,n=l.getExtension("OES_texture_float"),o=l.getExtension("OES_texture_half_float").HALF_FLOAT_OES,f=this.isDownloadFloatTextureEnabled(l,u),h=this.isFloatTextureReadPixelsEnabledMethod(l,1,f)),{textureFloat:n,textureHalfFloat:o,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,textureFormat:t,downloadInternalFormat:u,frameBufferSupportFloat:f,isFloatTextureReadPixelsEnabled:h}},e.isFloatTextureReadPixelsEnabledMethod=function(e,n,t){var o=e;if(0===n)return!1;if(1===n){if(null==o.getExtension("OES_texture_float"))return!1}else if(null==o.getExtension("EXT_color_buffer_float")||null==o.getExtension("EXT_color_buffer_half_float"))return!1;var r=o.createFramebuffer(),i=o.createTexture();o.bindTexture(o.TEXTURE_2D,i);var a=2===n?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,a,1,1,0,o.RGBA,t?o.FLOAT:o.getExtension("OES_texture_half_float").HALF_FLOAT_OES,null),o.bindFramebuffer(o.FRAMEBUFFER,r),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,i,0);var s=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;o.readPixels(0,0,1,1,o.RGBA,o.FLOAT,new Float32Array(4));var u=o.getError()===o.NO_ERROR;return s&&u},e.isDownloadFloatTextureEnabled=function(e,n){var t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,e.RGBA,e.FLOAT,null);var o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);var r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(o),r},e.uploadDataToTexture=function(e,n,t,o){e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);var r=t.width_texture,i=t.height_texture,a=t.data,s=e.RGBA,u=e.RGBA,l=e.FLOAT,f=a;if(a instanceof Uint8Array||a instanceof Uint8ClampedArray)l=e.UNSIGNED_BYTE;else{if(!(a instanceof Float32Array||a instanceof Array))return void e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a);if(2===c.get("webglVersion")){var h=c.get("webgl_force_half_float_texture");s=o?h?n.internalFormatPackedHalfFloat:n.internalFormatPacked:h?n.internalFormatHalfFloat:n.internalFormat,u=o?e.RGBA:n.textureFormat}else{for(var p=new Float32Array(r*i*4),d=0;d<a.length;d++)o?p[d]=a[d]:(p[4*d]=a[d],p[4*d+1]=0,p[4*d+2]=0,p[4*d+3]=0);f=p}}e.texImage2D(e.TEXTURE_2D,0,s,r,i,0,u,l,f)},e.genOutputTexture=function(e,n,t,o){var r=t.interpType,i=t.width_texture,a=t.height_texture,s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,"LINEAR"===r?e.LINEAR:e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,"LINEAR"===r?e.LINEAR:e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);var u=c.get("webgl_force_half_float_texture"),l=u?n.internalFormatPackedHalfFloat:n.internalFormatPacked,f=2===c.get("webglVersion")?u?e.HALF_FLOAT:e.FLOAT:n.frameBufferSupportFloat?e.FLOAT:n.textureHalfFloat,h=o?n.isFloatTextureReadPixelsEnabled?f:e.UNSIGNED_BYTE:null;return e.texImage2D(e.TEXTURE_2D,0,l,i,a,0,e.RGBA,o?h:f,null),e.bindTexture(e.TEXTURE_2D,null),s},e}(),F=["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ","#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],w=new Float32Array([-1,1,-1,-1,1,1,1,-1]),E=["length_shape","length_unformatted_shape","width_shape","height_shape","width_texture","height_texture","offset_x","offset_y","channel","total_shape","numbers_shape"],A={float:["multi_value","bias_value"],bool:["fuse_relu"]};function O(){return"\n    "+(c.get("useModAdaptor")?"\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        ":"\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ")+"\n    "+(c.get("useDivisionAdaptor")?"\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        ":"\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ")+"\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    "}const V="\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n";var C="\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",R="\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",S="\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",I="\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",k="\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",D="\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",M="\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",L="\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",U="\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",j="\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}",N="\nfloat exp_func(float x, float y, float z) {\n    float result = exp(x);\n    return result;\n}";function B(e,n){var t=n.width_shape,o=n.height_shape,r=n.channel,i=n.width_texture;return"\n    float getValueFromTensorPos_"+e+"(int n, int c, int h, int w) {\n        int index = n * "+t*o*r+" + c * "+t*o+" + h * "+t+" + w;\n        // 0.01 hack: 在 PC/WISE 机器上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+i+")));\n        int pos_h = index / int("+i+");\n        vec4 pixels = TEXTURE2D(texture_"+e+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+i+"),\n                (float(pos_h) + 0.5) / float("+n.height_texture+")\n            )\n        );\n        return pixels.r;\n    }"}function G(e,n){var t=n.channel,o=n.height_shape,r=n.width_texture,i=n.height_texture,a=n.width_shape;return"\n    vec4 getValueFromTensorPosPacking_"+e+"(int n, int c, int h, int w) {\n        int index = n * "+a*o*t+" + c * "+a*o+" + h * "+a+" + w;\n        // 0.01 hack: 在 PC/WISE 设备上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+r+")));\n        int pos_h = index / int("+r+");\n        vec4 pixels = TEXTURE2D(texture_"+e+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+r+"),\n                (float(pos_h) + 0.5) / float("+i+")\n            )\n        );\n        return pixels;\n    }"}function X(e,n){var t=n.numbers_shape,o=n.length_shape;if(1===o)return"\n            int getTensorPosFromArrayIndex_"+e+"(int n) {\n                return calMod(n, "+t[0]+");\n            }\n        ";for(var r="ivec"+o+"("+t.join(", ")+")",i="pos[0] = n / "+t[0]+";",a=1;a<o;a++)i+="\n            n = calMod(n, "+t[a-1]+");\n            pos["+a+"] = calDivision(n, "+t[a]+");\n        ";return"\n    ivec"+o+" shapeVec_"+e+" = "+r+";\n    ivec"+o+" getTensorPosFromArrayIndex_"+e+"(int n) {\n        ivec"+o+" pos;\n        "+i+"\n        return pos;\n    }\n    "}function H(e){return"\n    #define getPixelsFromTexturePos_"+e+"(pos) TEXTURE2D(texture_"+e+", pos)\n    "}function W(e,n){return"\n    vec2 moveTexture2PosToReal_"+e+"(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float("+n.width_texture+");\n        v2.y = v.y * float("+n.height_texture+");\n        return v2;\n    }\n    "}function z(e){return"uniform sampler2D texture_"+e+";"}function Y(e,n,t,o,a){var s,u,l="",f=n.name,h=n.mainFunc,p=n.textureFuncConf,d=void 0===p?{}:p,g=n.commonFuncConf;try{var _=function(e,n,t){for(var o={},r=Object.assign({},n),i=[],a=0,s=e;a<s.length;a++){for(var u=s[a],l=u.name,c={},f=0,h=E;f<h.length;f++)void 0!==u[m=h[f]]&&(c[m]=u[m]);o[l]=c,i.push(l)}for(var p=0,d=Object.keys(A);p<d.length;p++)for(var g=d[p],_=0,v=A[g];_<v.length;_++){var m;void 0!==n[m=v[_]]&&(r[m]=g+"("+n[m]+")")}return n.active_function&&(r.active_function=n.active_function),r.runtime=t,{textureParams:o,opParams:r,active_function:n.active_function}}(t,o,a),v=_.textureParams,m=_.opParams,x=_.active_function,P=2===c.get("webglVersion")?" #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        ":" #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",b=function(e){var n=e.frameBufferSupportFloat,t=e.isFinalOp,o=e.isFloatTextureReadPixelsEnabled;return 2===c.get("webglVersion")?"\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        "+O()+"\n    ":n?"\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            "+O()+"\n    ":t&&!o?"\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        "+O()+"\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        ":"\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            "+O()+"\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        "}(e),T=function(e){var n="",t="";if(e.fuse_opt)for(var o in e.fuse_opt){var i=o,a=0,s=0;switch(o){case"scale":var u=e.fuse_opt.scale.bias_after_scale;a=void 0!==(c=e.fuse_opt.scale.scale)?c:1,s=e.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i="scaleWidthBias");break;case"relu":i="prelu";break;case"relu6":a=e.fuse_opt[o].threshold;break;case"hard_sigmoid":i="hardSigmoid",a=e.fuse_opt[o].slope||.2,s=e.fuse_opt[o].offset||.5;break;case"leakyRelu":a=e.fuse_opt[o].alpha;break;case"pow":i="pow_func",a=e.fuse_opt[o].factor||2;break;case"tanh":i="tanh_func";break;case"exp":i="exp_func"}if("hard_swish"===o){var l=void 0!==e.fuse_opt.hard_swish.offset?e.fuse_opt.hard_swish.offset:3,c=void 0!==e.fuse_opt.hard_swish.scale?e.fuse_opt.hard_swish.scale:6;t+="res = res * min(max(0.0, res + float("+l+")), float("+(void 0!==e.fuse_opt.hard_swish.threshold?e.fuse_opt.hard_swish.threshold:6)+")) / float("+c+");"}else"dropout"===o?t+="\n                if ("+("downgrade_in_infer"===e.fuse_opt.dropout.dropout_implementation)+") {\n                    res = res * (1.0 - float("+e.fuse_opt.dropout.dropout_prob+"));\n                }":(n+=r[i],t+="res = "+i+"(res, float("+a+"), float("+s+"));")}return"\n        "+n+"\n        \n        float fuse_op(float x) {\n            float res = x;\n            "+t+"\n            return res;\n        }\n    "}(m),y=function(e,n,t,o){if(!e)return"";var r=Object.assign({},e);r["@all"]&&function(e,n){var t=n.filter((function(e){return"out"!==e.name})),o=e["@all"];t.forEach((function(n){var t=n.name;e[t]?e[t].concat(o):e[t]=o})),delete e["@all"]}(r,o);for(var a="",s="",u=0,l=Object.keys(r);u<l.length;u++){var c=l[u];if(n[c]){s+=z(c);for(var f=0,h=r[c];f<h.length;f++){var p=h[f];if(i[p])try{a+=i[p](c,n[c],t)}catch(e){console.error(e)}}}}return"\n    "+s+"\n    "+a+"\n    "}(d,v,m,t),F=function(e){return void 0===e?"":"\n        int layer_run_time = "+e+";\n    "}(a),w=function(e){var n,t,o,r,i;return"\n        \n    vec2 _2d_shape_texture_out = vec2(float("+e.width_texture+"), float("+e.height_texture+"));\n    \n        "+(t=(n=e).height_shape,o=n.width_shape,"\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.width_texture+");\n\n        int n1 = int(index / "+(r=o*t*n.channel)+");\n        int c1 = int(calMod(index, "+r+") / "+(i=o*t)+");\n        int h1 = int(calMod(index, "+i+") / "+o+");\n        int w1 = calMod(index, "+o+");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ")}(v.out);s=l=" "+P+"\n            "+T+"\n            "+b+"\n            "+function(e){if(!e)return"";for(var n="",t=0,o=e;t<o.length;t++){var i=o[t];r[i]&&(n+=r[i])}return n}(g)+"\n            "+(x?r[x]:"")+"\n            "+y+"\n            "+F+"\n            "+w+"\n            "+h(v,m)+"\n        ",u=1===c.get("webglVersion")?"texture2D":"texture",l=s.replace(/\bTEXTURE2D\b/g,u)}catch(e){console.error("["+f+"]: "+e)}return l}const q=function(){function e(e,n,t,o){var r=e;this.vShader=n;try{this.fShader=this.initShader(r,t,"fragment"),this.shape=o&&o.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(e){throw new Error(e)}}return e.prototype.initShader=function(e,n,t){void 0===t&&(t="vertex");var o,r="vertex"===t?e.VERTEX_SHADER:e.FRAGMENT_SHADER;if("vertex"===t&&this.vShader)o=this.vShader;else if(o=e.createShader(r),"vertex"===t&&(this.vShader=o),e.shaderSource(o,n),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))throw new Error("compile: "+e.getShaderInfoLog(o));return o},e.prototype.setProgram=function(e,n,t){e.useProgram(this.program),t||this.runVertexShader(e,n)},e.prototype.runVertexShader=function(e,n){var t=e.getAttribLocation(this.program,"position");e.enableVertexAttribArray(t),e.bindBuffer(e.ARRAY_BUFFER,n),e.vertexAttribPointer(t,2,e.FLOAT,!1,0,0)},e.Sampler="uSampler",e}();var K,Z=(K=function(e,n){return(K=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)},function(e,n){function t(){this.constructor=e}K(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),J=function(e,n,t,o){return new(t||(t=Promise))((function(r,i){function a(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,s)}u((o=o.apply(e,n||[])).next())}))},Q=function(e,n){var t,o,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,o=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((r=(r=a.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){a.label=i[1];break}if(6===i[0]&&a.label<r[1]){a.label=r[1],r=i;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(i);break}r[2]&&a.ops.pop(),a.trys.pop();continue}i=n.call(e,a)}catch(e){i=[6,e],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}};const $=function(e){function n(){var n=e.call(this)||this;return n.cacheTextures={},n.uniformLocations={},n.texturesMap={},n.queryList=[],n.currentTexture=null,n.width_shape_out=1,n.height_shape_out=1,n.width_texture_out=1,n.height_texture_out=1,n.channel=0,n.total_shape=0,n}return Z(n,e),n.prototype.init=function(){return J(this,void 0,void 0,(function(){var e;return Q(this,(function(n){return e=this.gl=T.createWebGLRenderingContext(),this.gl?(this.glVersion=T.getWebglVersion(),this.textureConf=y.getTextureConfig(e),this.MAX_TEXTURE_SIZE=c.get("MAX_TEXTURE_SIZE")||e.getParameter(e.MAX_TEXTURE_SIZE),e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),this.vertexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,w,e.STATIC_DRAW),this.vShader=T.initShader(e,p.VS_SHADER,F[this.glVersion-1]),this.frameBuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),this.pbo=e.createBuffer(),[2]):[2]}))}))},n.prototype.createProgram=function(e){var n=this,t=e.op,o=e.outTensor,r=e.inputTensors,i=e.shaderParams,a=e.runtime,s=e.isFinalOp,u=null;try{var l=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}([o],r);l.forEach((function(e){return T.genTextureInfoFromTensorShape(n.MAX_TEXTURE_SIZE,e)}));var c=Y(this.textureConf,t,l,i,a);(u=new q(this.gl,this.vShader,c,o)).fsCode=c;var f=y.genOutputTexture(this.gl,this.textureConf,o,s);this.texturesMap[o.tensorId]=f,this.program=u}catch(e){console.error("webgl createProgram: "+t.name+" -- "+e)}return u},n.prototype.runProgram=function(e,n){var t=this,o=function(e,n){if(2===n&&c.get("performance")){var t=e.getExtension("EXT_disjoint_timer_query_webgl2");if(!t)return;var o=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,o),o}return null}(this.gl,this.glVersion),r=e.isPackedOp;e.program.forEach((function(o,i){var a=e.outputTensors[i],s=a.tensorId;t.setOutProps(a),"frameBuffer"===e.bufferType?t.attachFrameBuffer(s):t.attachColorBuffer(),o.setProgram(t.gl,t.vertexBuffer,n),t.program=o,t.render(e,n,i,r)})),e.tensorData=null,o&&(this.queryList.push({name:e.name,query:o,count:1}),o=function(e,n,t){if(2===n&&c.get("performance")){var o=e.getExtension("EXT_disjoint_timer_query_webgl2");if(!o)return;e.endQuery(o.TIME_ELAPSED_EXT)}return t}(this.gl,this.glVersion,o))},n.prototype.read=function(e){return J(this,void 0,void 0,(function(){var n,t,o;return Q(this,(function(r){switch(r.label){case 0:return c.get("webgl_gpu_pipeline")?(n=this.gl,this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),[2,[]]):(t=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return r.sent(),o=e?e.shape:[],[2,this.downloadFloat32TensorFromBuffer(t,o)]}}))}))},n.prototype.createPBO=function(){var e,n=this.textureConf;if(2===this.glVersion){var t=this.gl,o=this.pbo;t.bindBuffer(t.PIXEL_PACK_BUFFER,o);var r=16*this.width_texture_out*this.height_texture_out;return t.bufferData(t.PIXEL_PACK_BUFFER,r,t.STREAM_READ),t.readPixels(0,0,this.width_texture_out,this.height_texture_out,t.RGBA,t.FLOAT,0),t.bindBuffer(t.PIXEL_PACK_BUFFER,null),o}var i=this.gl,a=i.FLOAT;return n.isFloatTextureReadPixelsEnabled?e=new Float32Array(this.width_texture_out*this.height_texture_out*4):(e=new Uint8Array(this.width_texture_out*this.height_texture_out*4),a=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,a,e),n.isFloatTextureReadPixelsEnabled?e:new Float32Array(e.buffer)},n.prototype.createAndWaitForFence=function(){return J(this,void 0,void 0,(function(){var e,n,t,o,r=this;return Q(this,(function(i){return e=this.gl,n=null!=e.fenceSync,t=function(){return!0},n&&(o=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0),e.flush(),t=function(){var n=e.clientWaitSync(o,0,0);return n===e.ALREADY_SIGNALED||n===e.CONDITION_SATISFIED}),[2,new Promise((function(e){r.pollItem(t,e)}))]}))}))},n.prototype.pollItem=function(e,n){var t=function(){e()?n():setTimeout(t,1)};t()},n.prototype.downloadFloat32TensorFromBuffer=function(e,n){var t=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var o=this.gl,r=new Float32Array(t);o.bindBuffer(o.PIXEL_PACK_BUFFER,e),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,r),o.bindBuffer(o.PIXEL_PACK_BUFFER,null);var i=[];if(c.get("webgl_pack_output"))return Array.from(r).slice(0,function(e){return e.reduce((function(e,n){return e*n}),1)}(n));for(var a=0;a<this.width_texture_out*this.height_texture_out;a++)i.push(r[4*a]);return i}var s=e,u=[];for(a=0;a<this.width_texture_out*this.height_texture_out;a++){var l=this.textureConf.isFloatTextureReadPixelsEnabled?4*a:a;u.push(s[l])}return u},n.prototype.setOutProps=function(e){var n=e.width_shape,t=void 0===n?1:n,o=e.height_shape,r=void 0===o?1:o,i=e.width_texture,a=void 0===i?1:i,s=e.height_texture,u=void 0===s?1:s,l=e.channel,c=void 0===l?0:l,f=e.total_shape,h=void 0===f?0:f;this.width_shape_out=t,this.height_shape_out=r,this.width_texture_out=a,this.height_texture_out=u,this.channel=c,this.total_shape=h},n.prototype.attachColorBuffer=function(){var e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.canvas.width=this.width_shape_out,e.canvas.height=this.height_shape_out,e.viewport(0,0,e.canvas.width,e.canvas.height),e.scissor(0,0,e.canvas.width,e.canvas.height)},n.prototype.attachFrameBuffer=function(e){this.currentTexture=this.texturesMap[e];var n=this.gl;n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,this.currentTexture,0),n.viewport(0,0,this.width_texture_out,this.height_texture_out),n.scissor(0,0,this.width_texture_out,this.height_texture_out)},n.prototype.render=function(e,n,t,o){var r=this;void 0===n&&(n=!1),void 0===o&&(o=!1);var i=e.inputTensors,a=void 0===i?[]:i,s=e.uniform,u=void 0===s?null:s,l=e.iLayer,c=void 0===l?0:l,f=e.modelName,h=this.gl,p=0;a.forEach((function(e){r.initTexture(p,e,o);var i=r.getUniformLoc("texture_"+e.name,c,n,t,f);i&&h.uniform1i(i,p++)})),u&&this.setUniform(u,c,n,t,f),h.drawArrays(h.TRIANGLE_STRIP,0,4)},n.prototype.initTexture=function(e,n,t){var o,r=this.gl,i=this.textureConf,a=n.tensorId,s=t||n.isPacked,u=n.data;if(n.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[a];l?(o=l,u&&T.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,n)):(o=r.createTexture(),this.cacheTextures[a]=o)}else o=this.texturesMap[a];r.activeTexture(r["TEXTURE"+e]),r.bindTexture(r.TEXTURE_2D,o),u&&(y.uploadDataToTexture(r,i,n,s),n.data=null)},n.prototype.setUniform=function(e,n,t,o,r){var i=this,a=Object.keys(e),s=this.gl;a.forEach((function(a){var u=e[a].type,l=e[a].value,c=i.getUniformLoc(a,n,t,o,r);T.setUniformParam(s,c,u,l)}))},n.prototype.getUniformLoc=function(e,n,t,o,r){var i=r+"_";if(t)return this.uniformLocations[i+n][e+o];var a=this.gl.getUniformLocation(this.program.program,e);return this.uniformLocations[i+n]=this.uniformLocations[i+n]||{},this.uniformLocations[i+n][e+o]=a,a},n.prototype.dispose=function(){},n}((function(){})),ee={mainFunc:function(e,n){var t=e.origin,o=e.filter,r=e.out,i=e.bias,a=n.groups,s=void 0===a?1:a,u=n.strides,l=void 0===u?[]:u,c=n.paddings,f=void 0===c?[]:c,h=n.dilations,p=void 0===h?[]:h,d=n.fuse_relu,g=n.filter_nearest_vec4,_=n.filter_remainder_vec4,v=n.act_type,m=void 0===v?"":v,x=n.padding_algorithm,P=void 0===x?"":x,b=n.hard_swish_offset,T=void 0===b?3:b,y=n.hard_swish_scale,F=void 0===y?6:y,w=n.hard_swish_threshold,E=void 0===w?6:w,A=l[0],O=void 0===A?1:A,V=l[1],C=void 0===V?1:V,R=f[0],S=void 0===R?0:R,I=f[1],k=void 0===I?0:I,D=p[0],M=void 0===D?1:D,L=p[1],U=void 0===L?1:L;return"SAME"===P&&Math.ceil((t.width_shape-o.width_shape)/O)+1!==r.width_shape&&(S=1,k=1),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+s+")) * "+o.channel+";\n        int oy = y * "+O+" - "+S+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+M+";\n                continue;\n            }\n            int ox = x * "+C+" - "+k+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+U+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+g+"; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if ("+_+" == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox));\n                } else if ("+_+" == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if ("+_+" == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += "+U+";\n            }\n            oy += "+M+";\n        }\n\n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n\n        if ("+d+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===m)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        else if ("+("hard_swish"===m)+") {\n            res = res * min(\n                max(0.0, res + float("+T+")),\n                float("+E+")\n            ) / float("+F+");\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]};function ne(e,n){var t=e[0],o=e[1],r=e[2],i=e[3];if(1===t&&1===o)return[[1,1,r],3,[i],1,[r,i]];var a=e.slice(0,n),s=e.slice(n);return[a,a.length,s,s.length,[a.reduce((function(e,n){return e*n})),s.reduce((function(e,n){return e*n}))]]}function te(e,n,t){if(1===t)return"\n            int getTensorPosFromArrayIndex_"+e+"(int n) {\n                return calMod(n, "+n[0]+");\n            }\n        ";var o=g(n);return o.push(1),"\n    ivec"+t+" shapeVec_"+e+" = ivec"+t+"("+o.join(", ")+");\n    ivec"+t+" getTensorPosFromArrayIndex_"+e+"(int n) {\n        ivec"+t+" pos;\n        pos[0] = n / shapeVec_"+e+"[0];\n        for (int i = 1; i < "+t+"; i++) {\n            n = calMod(n, shapeVec_"+e+"[i - 1]);\n            pos[i] = n / shapeVec_"+e+"[i];\n        }\n        return pos;\n    }\n    "}function oe(e){return 1===e?"int":"ivec"+e}function re(e){var n=e.total_shape,t=e.channel,o=e.height_shape,r=e.width_shape;return[n/t/o/r,t,o,r]}const ie={mainFunc:function(e,n){var t=e.origin,o=n.transpose_X,r=void 0!==o&&o,i=n.transpose_Y,a=void 0!==i&&i,s=n.trans_x,u=void 0!==s&&s,l=n.trans_y,c=r||u,f=a||void 0!==l&&l;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if ("+c+") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if ("+f+") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < "+(c?t.height_shape:t.width_shape)+"; j++) {\n            if ("+c+") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if ("+f+") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}};function ae(e,n){var t=e[0],o=e[1],r=e[2],i=e[3];if(1===t&&1===o)return[[1,1,r],3,[i],1,[r,i]];var a=e.slice(0,n),s=e.slice(n);return[a,a.length,s,s.length,[a.reduce((function(e,n){return e*n})),s.reduce((function(e,n){return e*n}))]]}function se(e,n,t){if(1===t)return"\n            int getTensorPosFromArrayIndex_"+e+"(int n) {\n                return calMod(n, "+n[0]+");\n            }\n        ";var o=g(n);return o.push(1),"\n    ivec"+t+" shapeVec_"+e+" = ivec"+t+"("+o.join(", ")+");\n    ivec"+t+" getTensorPosFromArrayIndex_"+e+"(int n) {\n        ivec"+t+" pos;\n        pos[0] = n / shapeVec_"+e+"[0];\n        for (int i = 1; i < "+t+"; i++) {\n            n = calMod(n, shapeVec_"+e+"[i - 1]);\n            pos[i] = n / shapeVec_"+e+"[i];\n        }\n        return pos;\n    }\n    "}function ue(e){return 1===e?"int":"ivec"+e}function le(e){var n=e.total_shape,t=e.channel,o=e.height_shape,r=e.width_shape;return[n/t/o/r,t,o,r]}const ce={mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+e.out.width_texture+");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getTensorPosFromArrayIndex","getValueFromTensorPos"]}},fe={mainFunc:function(e,n){var t=e.out,o=e.origin,r=n.align_mode,i=void 0===r?1:r,a=n.align_corners,s=void 0===a||a;return"\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = "+i+" == 0 && !"+s+";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+s+") {\n            scale_x = float("+t.width_shape+" - 1) / float("+o.width_shape+" - 1);\n            scale_y = float("+t.height_shape+" - 1) / float("+o.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+t.width_shape+") / float("+o.width_shape+");\n            scale_y = float("+t.height_shape+") / float("+o.height_shape+");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, "+o.width_shape+");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, "+o.height_shape+");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},he=fe;var pe={relu:["transToPrelu"],relu6:["transToRelu6"],leaky_relu:["transToLeakyrelu"],transToLeakyrelu:["transToLeakyrelu"],scale:["transToScale"],sigmoid:["transToSigmoid"],hard_sigmoid:["transToHardSigmoid"],pow:["transToPow"],exp:["transToExp"],sqrt:["transToSqrt"],tanh:["transToTanh"]};function de(e,n){var t=n.multi_value,o=void 0===t?1:t,r=n.bias_value,i=void 0===r?0:r;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = "+n.active_function+"(o, float("+o+"), float("+i+"));\n        setOutput(res);\n    }\n    "}function ge(e){return{mainFunc:de,textureFuncConf:{origin:["getPixelsFromTexturePos"]},behaviors:pe[e]}}const _e={mainFunc:function(e,n){var t=n.axes,o=Array.isArray(t)?t:[t],r=[0,1,2,3].filter((function(e){return e>=o.length}));return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+[0,1,2,3].map((function(e){return o.indexOf(e)>-1?0:"oPos["+r.splice(0,1)+"]"})).join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},ve={mainFunc:function(e,n){var t=e.origin,o=e.out,r=n.align_corners;return"\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+r+") {\n            scale_x = float("+o.width_shape+" -1) / float("+t.width_shape+" - 1);\n            scale_y = float("+o.height_shape+" - 1) / float("+t.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+o.width_shape+") / float("+t.width_shape+");\n            scale_y = float("+o.height_shape+") / float("+t.height_shape+");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, "+r+");\n        int vy = getData(float(oPos.b), scale_y, "+r+");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]};var me=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o};const xe={mainFunc:function(e,n){var t=e.origin,o=e.image,r=e.out,i=n.variances,a=void 0===i?[.1,.1,.2,.2]:i,s=n.fixed_sizes,u=n.fixed_ratios,l=n.densities,c=n.flatten_to_2d,f=n.clip,h=n.step_w,p=void 0===h?0:h,d=n.step_h,v=void 0===d?0:d,m=n.offset,x=void 0===m?.5:m,P=n.runtime,b=void 0===P?0:P,T=o.height_shape,y=o.width_shape,F=t.height_shape,w=t.width_shape,E=r.total_shape,A=r.channel,O=r.height_shape,V=r.width_shape,C=E/A/O/V,R=g([C,A,O,V]),S=p,I=v;0!==p&&0!==v||(S=y/w,I=T/F);var k=Math.round(.5*(S+I)),D=u.map((function(e){return Math.sqrt(e)})),M=1===D.length?"sqrt_fixed_ratios":"sqrt_fixed_ratios[r]",L=u.length,U=O,j=C,N=A;c&&(j=F,N=w,U=O/F/w);var B=g([j,N,U,V]),G=X("out1",{numbers_shape:me(B,[1]),length_shape:4}),H=l.map((function(e){return e*e*L})),W=H.length,z=function(e){var n="ivec2 calRemain(int remain, int curAccIndex, int s) {",t=e.length;if(1===t)n+="\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";else for(var o=0;o<t;o++)n+="\n            int accIndex"+o+" = density_acc_shape["+o+"];\n\n            if (remain >= accIndex"+o+") {\n                s++;\n                remain -= accIndex"+o+";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";return n+"\n    }\n    "}(H),Y=f?"v = min(max(v, 0.), 1.);":"",q=1===W?"density_acc_shape":"density_acc_shape[0]",K="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    "+G+"\n    \n        "+_(l,"densities")+"\n        "+_(s,"fixed_sizes")+"\n        "+_(D,"sqrt_fixed_ratios")+"\n        "+function(e,n){if(1===e.length)return"int "+n+" = int("+e[0]+");";for(var t=e.length,o="\n        ivec"+t+" "+n+" = ivec"+t+"(\n    ",r=0;r<t;r++)o+=e[r]+",";return o.slice(0,-1)+");"}(H,"density_acc_shape")+"\n    \n    "+z+"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * "+R[0]+" + gg * "+R[1]+" + bb * "+R[2]+" + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    ";return 1===b?"\n        "+_(a,"variances")+"\n        "+K+"\n        setOutput(getFloat4TensorVal(variances, aa));\n        }":"\n            "+K+"\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = "+q+";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat"+l.length+"TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float("+x+")) * float("+S+");\n            float center_y = (float(h) + float("+x+")) * float("+I+");\n            float fixed_size = getFloat"+s.length+"TensorVal(fixed_sizes, s);\n            float shift = float("+k+") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * "+M+";\n                float density_center_x = center_x - float("+k+") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float("+y+"), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float("+y+"), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / "+M+";\n                float density_center_y = center_y - float("+k+") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float("+T+"), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float("+T+"), 1.);\n                }\n            }\n\n            "+Y+"\n\n            setOutput(v);\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},Pe={mainFunc:function(e,n){var t=e.origin,o=e.image,r=e.out,i=n.variances,a=void 0===i?[.1,.1,.2,.2]:i,s=n.flip,u=n.clip,l=n.step_w,c=void 0===l?0:l,f=n.step_h,p=void 0===f?0:f,d=n.offset,g=void 0===d?.5:d,x=n.runtime,P=void 0===x?0:x,b=n.min_sizes,T=void 0===b?[]:b,y=n.max_sizes,F=void 0===y?[]:y,w=n.aspect_ratios,E=void 0===w?[]:w,A=n.min_max_aspect_ratios_order,O=void 0!==A&&A,V=o.height_shape,C=o.width_shape,R=t.height_shape,S=t.width_shape,I=r.channel,k=r.height_shape,D=c,M=p;0!==c&&0!==p||(D=C/S,M=V/R);var L=[1];E.forEach((function(e){1!==e&&(L.push(Math.sqrt(e)),s&&L.push(Math.sqrt(1/e)))}));var U=L.length,j="\n        "+v(T,"min_sizes",h.FLOAT_TYPE)+"\n        "+v(F,"max_sizes",h.FLOAT_TYPE)+"\n        "+v(L,"aspect_ratios",h.FLOAT_TYPE)+"\n    ",N=u?"res = min(max(res, 0.), 1.);":"",B="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    \n        "+m(T,"min_sizes",h.FLOAT_TYPE)+"\n        "+m(F,"max_sizes",h.FLOAT_TYPE)+"\n        "+m(L,"aspect_ratios",h.FLOAT_TYPE)+"\n    \n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        "+j+"\n\n    ";return 1===P?"\n            "+_(a,"variances")+"\n            "+B+"\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }":"\n            "+B+"\n            int idx = nn * "+I*k+" + cc * "+k+" + hh;\n            int as_num = "+U+";\n            float offset = "+g+";\n            \n            int feature_width = "+S+";\n            int num_priors = "+k+";\n            float step_width = float("+D+");\n            float step_height = float("+M+");\n\n            float im_width = float("+C+");\n            float im_height = float("+V+");\n\n            bool min_max_aspect_ratios_order = "+O+";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = calMod(idx / num_priors, feature_width);\n            int p = calMod(idx, num_priors);\n            int m = "+(F.length>0)+" ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = getValueFromArrByIndex_min_sizes(min_sizes, m);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            "+(F.length>0?"\n            int s = calMod(p, as_num + 1);\n            if ("+!O+") {\n                if (s < as_num) {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s - 1);\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }":"\n            int s = calMod(p, as_num);\n            float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ")+"\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            "+N+"\n\n            setOutput(float(res));\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:[]},be={mainFunc:function(e,n){for(var t=e.out,o=function(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&n.indexOf(o)<0&&(t[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(e);r<o.length;r++)n.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(e,o[r])&&(t[o[r]]=e[o[r]])}return t}(e,["out"]),r=o.origin,i=r.width_shape,a=r.height_shape,s=r.channel,u=r.total_shape,l=r.length_unformatted_shape,c=[u/(i*a*s),s,a,i].slice(4-l),f=Object.keys(o).length,h=n.axis<0?n.axis+c.length+1:n.axis,p=1,d=1,g=0;g<h;g++)p*=c[g];for(g=h;g<c.length;g++)d*=c[g];var _=t.total_shape/p,v="";return v=Array.from(Array(f).keys()).reduce((function(e,n){return e+(0===n?"\n            if (i == 0) {\n                ivec4 co = getTensorPosFromArrayIndex_origin(j);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (i == "+n+") {\n                ivec4 co = getTensorPosFromArrayIndex_origin_"+n+"(j);\n                o = getValueFromTensorPos_origin_"+n+"(co.r, co.g, co.b, co.a);\n            }")}),v),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n\n        int index = calMod(sumVal, "+_+");\n\n        int layer = sumVal / "+_+";\n\n        int i = index / "+d+";\n        int j = calMod(index, "+d+") + layer * "+d+";\n\n        float o = 0.0;\n        "+v+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},Te={mainFunc:function(e,n){var t=e.out,o=e.origin,r=n.axes,i=n.starts,a=n.ends,s=n.decrease_axis;if(r.length>1||i.length>1||a.length>1||s&&0===s.length)throw Error("[slice op feature]: current support one dim, support decrease_axis");var u=o.width_shape,l=o.height_shape,c=o.channel,f=o.total_shape,p=o.length_unformatted_shape,d=[f/(u*l*c),c,l,u],g=r[0];if(g<0&&(g=g+p+1),4!==(g=4-p+g))throw Error("[slice op feature]: unsupport axis value");for(var _=i[0],x=a[0],P=d[0],b=d[1],T=d[2],y=d[3],F=[],w=_;w<x;w++)for(var E=0;E<P;E++)for(var A=0;A<b;A++)for(var O=0;O<T;O++)F.push(E*b*T*y+A*T*y+O*y+w);var V=v(F,"arr",h.INT_TYPE);return"\n    "+m(F,"arr",h.INT_TYPE)+"\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        "+V+"\n\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n\n        int index = getValueFromArrByIndex_arr(arr, sumVal);\n\n        float res = 0.0;\n        ivec4 co = getTensorPosFromArrayIndex_origin(index);\n        res = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}};var ye={arg_max:{mainFunc:function(e,n){var t=e.origin,o=n.axis,r=void 0===o?-1:o,i=n.flatten,a=t.total_shape,s=t.height_shape,u=t.width_shape,l=t.channel,c=t.length_unformatted_shape,f=a/(u*s*l),h=r<0?3:4-c+r,p=[f,l,s,u][h];return"\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+h+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+f+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+s+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},arg_min:{mainFunc:function(e,n){for(var t=e.origin,o=n.axis,r=void 0===o?-1:o,i=n.flatten,a=t.total_shape,s=t.height_shape,u=t.width_shape,l=t.channel,c=a/(u*s*l),f=[c,l,s,u],h=0,p=0;p<4&&!(f[p]>1);p++)h++;var d=r<0?4-h+r:r,g=f[d=h+d];return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+d+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+d+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+d+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+c+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+s+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},conv2d:ee,conv2d_packing:{mainFunc:function(e,n){var t=e.origin,o=e.filter,r=e.out,i=e.bias,a=n.groups,s=void 0===a?1:a,u=n.strides,l=void 0===u?[]:u,c=n.paddings,f=void 0===c?[]:c,h=n.dilations,p=void 0===h?[]:h,d=n.fuse_relu,g=n.act_type,_=n.hard_swish_offset,v=void 0===_?3:_,m=n.hard_swish_scale,x=void 0===m?6:m,P=n.hard_swish_threshold,b=void 0===P?6:P,T=l[0],y=void 0===T?1:T,F=l[1],w=void 0===F?1:F,E=f[0],A=void 0===E?0:E,O=f[1],V=void 0===O?0:O,C=p[0],R=void 0===C?1:C,S=p[1],I=void 0===S?1:S;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * "+y+" - "+A+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+R+";\n                continue;\n            }\n            int ox = x * "+w+" - "+V+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+I+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+o.channel+"; j += 1) {\n                    int c0 = (c / ("+r.channel+" * 4 / "+s+")) * "+o.channel+" + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / ("+r.channel+" * 4 / "+s+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / ("+r.channel+" * 4 / "+s+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / ("+r.channel+" * 4 / "+s+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += "+I+";\n            }\n            oy += "+R+";\n        }\n\n        "+(i?"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);":"")+"\n\n        if ("+d+") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if ("+("relu6"===g)+") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        else if ("+("hard_swish"===g)+") {\n            res = res * min(\n                max(vec4(0.0, 0.0, 0.0, 0.0), res + vec4("+v+")),\n                vec4("+b+")\n            ) / vec4("+x+");\n        }\n\n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPosPacking"],origin:["getValueFromTensorPosPacking"],bias:["getValueFromTensorPosPacking"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},conv2d_transpose:{mainFunc:function(e,n){var t=e.origin,o=e.filter,r=e.out,i=e.bias,a=n.groups,s=void 0===a?1:a,u=n.strides,l=void 0===u?[]:u,c=n.paddings,f=void 0===c?[]:c,h=n.dilations,p=void 0===h?[]:h,d=n.fuse_relu,g=n.act_type,_=l[0],v=void 0===_?1:_,m=l[1],x=void 0===m?1:m,P=f[0],b=void 0===P?0:P,T=f[1],y=void 0===T?0:T;y=o.height_shape-y-1,b=o.width_shape-b-1;var F=p[0],w=void 0===F?1:F,E=p[1],A=void 0===E?1:E;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * "+s+" / "+r.channel+") * "+t.channel+";\n        int oy = y - "+y+";\n        const int groupLen = int("+t.channel+" / "+s+");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy < 0) {\n                oy += "+w+";\n                continue;\n            }\n            int ox = x - "+b+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n\n                if (ox < 0) {\n                    ox += "+A+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int("+x+")) == 0 && calMod(oy, int("+v+")) == 0) {\n                        temp_x = int(floor(float(ox) / float("+x+")));\n                        temp_y = int(floor(float(oy) / float("+v+")));\n                        if (temp_x < "+t.width_shape+" && temp_y < "+t.height_shape+") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / "+s+"),\n                                "+o.height_shape+"-1-fy,\n                                "+o.width_shape+"-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += "+A+";\n            }\n            oy += "+w+";\n        }\n        \n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n        \n        if ("+d+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===g)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        \n        setOutput(float(res));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},depthwise_conv2d:ee,conv2d_depthwise:ee,conv2d_elementwise_add:{mainFunc:function(e,n){var t=e.origin,o=e.filter,r=e.out,i=e.counter,a=n.active_function,s=n.groups,u=void 0===s?1:s,l=n.axis,c=n.strides,f=void 0===c?[]:c,h=n.paddings,p=void 0===h?[]:h,d=n.dilations,g=void 0===d?[]:d,_=n.multi_value,v=n.bias_value,m=f[0],x=void 0===m?1:m,P=f[1],b=void 0===P?1:P,T=p[0],y=void 0===T?0:T,F=p[1],w=void 0===F?0:F,E=g[0],A=void 0===E?1:E,O=g[1],V=void 0===O?1:O;return"\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float("+i.width_shape+");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos["+l+"];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+u+")) * "+o.channel+";\n        int oy = y * "+x+" - "+y+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+A+";\n                continue;\n            }\n            int ox = x * "+b+" - "+w+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+V+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+o.channel+"; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += "+V+";\n            }\n            oy += "+A+";\n        }\n        setOutput("+a+"(res,  "+_+",  "+v+"));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]},behaviors:["mergeAttrs","checkIsMerge","setActiveFunc"]},pool2d:{mainFunc:function(e,n){var t=e.origin,o=n.strides,r=void 0===o?[]:o,i=n.paddings,a=void 0===i?[]:i,s=n.pooling_type,u=n.ksize,l=r[0],c=void 0===l?1:l,f=r[1],h=void 0===f?1:f,p=a[0],d=void 0===p?0:p,g=a[1],_=void 0===g?0:g,v=u[0],m=u[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if ("+s+" == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+h+" - "+_+";\n        for (int fy = 0; fy < "+v+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+m+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+s+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+s+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_max:{mainFunc:function(e,n){var t=e.origin,o=n.strides,r=void 0===o?[]:o,i=n.paddings,a=void 0===i?[]:i,s=n.ksize,u=n.global_pooling,l=n.runtime,c=r[0],f=void 0===c?1:c,h=r[1],p=void 0===h?1:h,d=a[0],g=void 0===d?0:d,_=a[1],v=void 0===_?0:_,m=s[0],x=s[1],P=function(e){var n=e.total_shape,t=e.channel,o=e.height_shape,r=e.width_shape;return[n/t/o/r,t,o,r]}(t),b="",T="setOutput(float(res));";return 0===l&&!0===u&&(b="\n            if (curr > res) {\n                index = "+P[2]*P[3]+" * out_pos[1] + "+P[3]+" * oy + ox;\n            }\n        ",T="setOutput(float(index));"),"\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+f+" - "+g+";\n        int ox_base = out_pos[3] * "+p+" - "+v+";\n        for (int fy = 0; fy < "+m+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+x+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                "+b+"\n                res = max(res, curr);\n            }\n        }\n        "+T+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_winograd:{mainFunc:function(e,n){var t=e.origin,o=e.pool,r=n.strides,i=void 0===r?[]:r,a=n.paddings,s=void 0===a?[]:a,u=n.type_pool,l=i[0],c=void 0===l?1:l,f=i[1],h=void 0===f?1:f,p=s[0],d=void 0===p?0:p,g=s[1],_=void 0===g?0:g,v=t.height_shape,m=t.width_texture,x=t.height_texture;return"\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = "+v+" + "+t.offset_y+";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float("+m+"),\n            (float(g * height / 2 + y) + 0.5) / float("+x+"))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+h+" - "+_+";\n\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+u+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+u+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},elementwise_add:{mainFunc:function(e,n){var t=n.counterPos,o=n.Scale_y,r=void 0===o?1:o,i=n.Scale_x,a=void 0===i?1:i,s=n.Scale_out,u=void 0===s?1:s;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+u/r+") * c + float("+u/a+") * o;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_mul:{mainFunc:function(e,n){var t=e.counter,o=n.counterPos,r=n.Scale_y,i=void 0===r?1:r,a=n.Scale_x,s=void 0===a?1:a,u=n.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+t.height_texture/t.height_shape+") {\n            newN = int("+t.height_texture/t.height_shape+");\n        }\n        if (c >= "+t.channel+") {\n            newC = int("+(t.channel-1)+");\n        }\n        if (h >= "+t.height_shape+") {\n            newH = "+(t.height_shape-1)+";\n        }\n        if (w >= "+t.width_shape+") {\n            newW = "+(t.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+l/s+") * o * float("+1/i+") * c;\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_div:{mainFunc:function(e,n){var t=e.counter,o=n.counterPos,r=n.Scale_y,i=void 0===r?1:r,a=n.Scale_x,s=void 0===a?1:a,u=n.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+t.height_texture/t.height_shape+") {\n            newN = int("+t.height_texture/t.height_shape+");\n        }\n        if (c >= "+t.channel+") {\n            newC = int("+(t.channel-1)+");\n        }\n        if (h >= "+t.height_shape+") {\n            newH = "+(t.height_shape-1)+";\n        }\n        if (w >= "+t.width_shape+") {\n            newW = "+(t.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+l+") * (float("+1/s+") * o / (float("+1/i+") * c));\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_pow:{mainFunc:function(e,n){var t=n.counterPos,o=n.Scale_y,r=void 0===o?1:o,i=n.Scale_x,a=void 0===i?1:i,s=n.Scale_out,u=void 0===s?1:s;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = pow(float("+u/a+") * o, float("+u/r+") * c);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_sub:{mainFunc:function(e,n){var t=n.counterPos,o=n.Scale_y,r=void 0===o?1:o,i=n.Scale_x,a=void 0===i?1:i,s=n.Scale_out,u=void 0===s?1:s;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+u/a+") * o - float("+u/r+") * c;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},mul:{mainFunc:function(e,n){var t=e.origin,o=e.counter,r=n.x_num_col_dims,i=n.y_num_col_dims,a=re(t),s=re(o),u=ne(a,r),l=u[0],c=u[1],f=u[2],h=u[3],p=u[4],d=ne(s,i),g=d[0],_=d[1],v=d[2],m=d[3];return"\n    "+te("x1",l,c)+"\n    "+te("x2",f,h)+"\n    "+te("y1",g,_)+"\n    "+te("y2",v,m)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+oe(c)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+oe(m)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+p[1]+"; j++) {\n            "+oe(h)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+oe(_)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+oe(c)+"(x1), "+oe(h)+"(x2));\n            ivec4 yPos = ivec4("+oe(_)+"(y1), "+oe(m)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},matmul:ie,matmul_v2:ie,fc:{mainFunc:function(e,n){var t=e.origin,o=e.weight,r=n.x_num_col_dims,i=n.y_num_col_dims,a=le(t),s=le(o),u=ae(a,r),l=u[0],c=u[1],f=u[2],h=u[3],p=u[4],d=ae(s,i),g=d[0],_=d[1],v=d[2],m=d[3];return"\n    "+se("x1",l,c)+"\n    "+se("x2",f,h)+"\n    "+se("y1",g,_)+"\n    "+se("y2",v,m)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+ue(c)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+ue(m)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+p[1]+"; j++) {\n            "+ue(h)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+ue(_)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+ue(c)+"(x1), "+ue(h)+"(x2));\n            ivec4 yPos = ivec4("+ue(_)+"(y1), "+ue(m)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    "},textureFuncConf:{weight:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]}},dropout:{mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if ("+("downgrade_in_infer"===n.dropout_implementation)+") {\n            o = o * (1.0 - float("+n.dropout_prob+"));\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},concat:{mainFunc:function(e,n){var t=n.dim,o=Object.keys(e).filter((function(e){return"out"!==e})).map((function(n){return e[n]})).map((function(e){var n=e.width_shape,o=e.height_shape,r=e.channel;return[e.total_shape/(n*o*r),r,o,n][t]})),r=o.map((function(e,n){return o.slice(0,n+1).reduce((function(e,n){return e+n}),0)})),i="";return r.forEach((function(e,n){i+=0===n?"\n            if (oPos["+t+"] < "+e+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            ":"\n            else if (oPos["+t+"] < "+e+") {\n                oPos["+t+"] = oPos["+t+"] - "+r[n-1]+";\n                o = getValueFromTensorPos_origin_"+n+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},concat_mul:{mainFunc:function(e,n){var t=n.dim,o=Object.keys(e).filter((function(e){return"out"!==e})).map((function(n){return e[n]})).map((function(e){var n=e.width_shape,o=e.height_shape,r=e.channel;return[e.total_shape/(n*o*r),r,o,n][t]})),r=o.map((function(e,n){return o.slice(0,n+1).reduce((function(e,n){return e+n}),0)})),i="";return r.forEach((function(e,n){i+=0===n?"\n            if (oPos["+t+"] < "+e+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }":"\n            else if (oPos["+t+"] < "+e+") {\n                oPos["+t+"] = oPos["+t+"] - "+r[n-1]+";\n                o = getValueFromTensorPos_origin_"+n+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},split:{mainFunc:function(e,n){var t=n.target_length,o=n.num,r=n.dim,i=n.sections;return"\n    // start函数\n    void main(void) {\n        int length = int("+(i&&i.length>1?i[0]:t/o)+");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos["+r+"] = oPos["+r+"] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},softmax:{mainFunc:function(e,n){var t=e.origin,o=n.axis,r=o;return(!o||o<0)&&(r=(o||-1)+4),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int("+t.total_shape+"/"+t.channel+"/"+t.height_shape+"/"+t.width_shape+");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if ("+r+" == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if ("+r+" == 1) {\n            for (int i = 0; i < "+t.channel+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < "+t.width_shape+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},batchnorm:{mainFunc:function(e,n){var t=e.bias,o=e.scale,r=e.mean,i=e.variance,a=n.epsilon;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float("+o.width_texture+") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float("+t.width_texture+") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float("+r.width_texture+")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float("+i.width_texture+") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + "+a+");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],scale:["getPixelsFromTexturePos"],bias:["getPixelsFromTexturePos"],mean:["getPixelsFromTexturePos"],variance:["getPixelsFromTexturePos"]}},reshape:ce,reshape2:ce,bilinear_interp:fe,transpose2:{mainFunc:function(e,n){var t=n.perm_arr,o=n.perm_size,r=t[0],i=t[1],a=t[2];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if ("+o+" == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if ("+o+" == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + "+r+") > 3 ? 3 : (2 + "+r+")],\n                oPos[(2 + "+i+") > 3 ? 3 : (2 + "+i+")]\n            );\n        }\n        else if ("+o+" == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + "+r+") > 3 ? 3 : (1 + "+r+")],\n                oPos[(1 + "+i+") > 3 ? 3 : (1 + "+i+")],\n                oPos[(1 + "+a+") > 3 ? 3 : (1 + "+a+")]\n            );\n        }\n        else if ("+o+" == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos["+r+"],\n                oPos["+i+"],\n                oPos["+a+"],\n                oPos["+t[3]+"]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizePerm"]},unpacked_2_packed:{mainFunc:function(e,n){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},packed_2_unpacked:{mainFunc:function(e,n){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},unsqueeze2:{mainFunc:function(e,n){var t=e.origin,o=n.axes,r=t.length_unformatted_shape,i=Array.isArray(o)?o:[o],a=4-r-i.length,s=i.map((function(e){return e+a})),u=[0,1,2,3].filter((function(e){return-1===s.indexOf(e)})).map((function(e){return"oPos["+e+"]"})),l=Array.from(new Array(s.length),(function(){return"0"}));return u.splice.apply(u,function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var o=Array(e),r=0;for(n=0;n<t;n++)for(var i=arguments[n],a=0,s=i.length;a<s;a++,r++)o[r]=i[a];return o}([0,0],l)),"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+u.join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},flatten_contiguous_range:{mainFunc:function(e,n){var t=e.origin,o=e.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+t.channel+",\n            "+t.width_shape+",\n            "+t.height_shape+",\n            "+t.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},flatten2:ce,greater_than:{mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},reduce_sum:{mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+n.inputs_dim+"; i++) {\n            oPos["+n.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},where:{mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"],condition:["getValueFromTensorPos"]}},connect:{mainFunc:function(e,n){var t=e.out,o=t.total_shape,r=t.width_shape,i=t.height_shape,a=t.channel,s=g([o/(r*i*a),a,i,r]),u=Object.keys(e).filter((function(e){return"out"!==e})).map((function(n){return e[n].total_shape})),l=u.map((function(e,n){return u.slice(0,n+1).reduce((function(e,n){return e+n}),0)})),c="";return l.forEach((function(e,n){c+=0===n?"\n            if (sumVal < "+e+") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (sumVal < "+e+") {\n                co = getTensorPosFromArrayIndex_origin_"+n+"(sumVal - "+l[n-1]+");\n                o = getValueFromTensorPos_origin_"+n+"(co.r, co.g, co.b, co.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * "+s[2]+" + oPos.a;\n        "+c+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},reduce_mean:{mainFunc:function(e,n){var t=n.inputs_dim;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+t+"; i++) {\n            oPos["+n.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float("+t+");\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},hard_swish:{mainFunc:function(e,n){var t=n.offset,o=void 0===t?3:t,r=n.scale,i=void 0===r?6:r,a=n.threshold;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float("+o+")), float("+(void 0===a?6:a)+")) / float("+i+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},nearest_interp:ve,nearest_interp_v2:ve,cast:{mainFunc:function(e,n){var t="";switch(n.out_dtype){case 0:t="\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);";break;case 1:case 2:case 3:t="\n            int res_int = int(o);\n            setOutput(float(res_int));";break;default:t="       \n            float res_float = o;\n            setOutput(res_float);"}return"\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        "+t+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},fill_constant_batch_size_like:{mainFunc:function(e,n){return"\n    // start函数\n    void main(void) {\n        float res = float("+n.value+");\n        setOutput(res);\n    }\n"}},rnn_matmul:{mainFunc:function(e,n){var t=e.weightlist_0,o=n.input_axis,r=n.state_axis,i=n.batch,a=n.reverse,s=void 0!==a&&a?i-o-1:o;return"\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if ("+(0===o)+") {\n            res = getValueFromTensorPos_origin(out_pos[0], "+s+", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], "+s+", out_pos[2], out_pos[3]);\n        for (int j = 0; j < "+t.width_shape+"; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], "+r+", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"]}},rnn_hidden:{mainFunc:function(e,n){var t=n.state_axis,o=n.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+o+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*o+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*o+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+t+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_cell:{mainFunc:function(e,n){var t=n.state_axis,o=n.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+o+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*o+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*o+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+t+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_origin:{mainFunc:function(e,n){var t=e.weightlist_0,o=e.weightlist_1,r=n.state_axis;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < "+t.width_shape+"; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < "+o.width_shape+"; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, "+r+", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"],weightlist_1:["getValueFromTensorPos"],weightlist_2:["getValueFromTensorPos"],weightlist_3:["getValueFromTensorPos"]}},pool2d_avg:{mainFunc:function(e,n){var t=e.origin,o=n.strides,r=void 0===o?[]:o,i=n.paddings,a=void 0===i?[]:i,s=n.ksize,u=r[0],l=void 0===u?1:u,c=r[1],f=void 0===c?1:c,h=a[0],p=void 0===h?0:h,d=a[1],g=void 0===d?0:d,_=s[0],v=s[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+l+" - "+p+";\n        int ox_base = out_pos[3] * "+f+" - "+g+";\n        for (int fy = 0; fy < "+_+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+v+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float("+_+" * "+v+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["setPacked","setAdaptive","isGlobalPooling"]},prelu:ge("prelu"),relu6:ge("relu6"),leakyRelu:ge("leakyRelu"),scale:ge("scale"),sigmoid:ge("sigmoid"),relu:ge("relu"),hard_sigmoid:ge("hard_sigmoid"),pow:ge("pow"),sqrt:ge("sqrt"),tanh:ge("tanh"),exp:ge("exp"),squeeze2:_e,pad3d:{mainFunc:function(e,n){var t=e.origin,o=n.paddings,r=n.mode,i=n.value,a=function(e){var n=e.total_shape,t=e.channel,o=e.height_shape,r=e.width_shape;return[n/t/o/r,t,o,r]}(t),s={reflect:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = "+o[0]+" - oPos.a;\n            }\n            else if (oPos.a - "+o[0]+" >= "+a[3]+") {\n                a = "+a[3]+" - (oPos.a - "+o[0]+" - "+a[3]+" + 1) - 1;\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = "+o[2]+" - oPos.b;\n            }\n            else if (oPos.b - "+o[2]+" >= "+a[2]+") {\n                b = "+a[2]+" - (oPos.b - "+o[2]+" - "+a[2]+" + 1) - 1;\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",replicate:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = 0;\n            }\n            else if (oPos.a - "+o[0]+" >= "+a[3]+") {\n                a = "+a[3]+" - 1;\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = 0;\n            }\n            else if (oPos.b - "+o[2]+" >= "+a[2]+") {\n                b = "+a[2]+" - 1;\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",circular:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = int(mod(float("+o[0]+" + oPos.a - 1), float("+a[3]+")));\n            }\n            else if (oPos.a - "+o[0]+" >= "+a[3]+") {\n                a = int(mod(float(oPos.a - "+o[0]+" - "+a[3]+"), float("+a[3]+")));\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = int(mod(float("+o[2]+" + oPos.b - 1), float("+a[2]+")));\n            }\n            else if (oPos.b - "+o[2]+" >= "+a[2]+") {\n                b = int(mod(float(oPos.b - "+o[2]+" - "+a[2]+"), float("+a[2]+")));\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",constant:"",undefined:""};return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = "+(i||"0.0")+";\n        if (oPos.a - "+o[0]+" >= 0\n            && oPos.b - "+o[2]+" >= 0\n            && oPos.a - "+o[0]+" < "+a[3]+"\n            && oPos.b - "+o[2]+" < "+a[2]+"\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - "+o[2]+", oPos.a - "+o[0]+");\n        }\n        else {\n            "+s[r]+"\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},bilinear_interp_v2:he,shuffle_channel:{mainFunc:function(e,n){var t=e.out,o=n.group,r=void 0===o?2:o,i=t.total_shape,a=t.height_shape,s=t.width_shape,u=t.channel,l=[1,0,2,3];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * "+s+"\n            + oPos.g * "+a+" * "+s+"\n            + oPos.r * "+u+" * "+s+" * "+a+";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+r+",\n            "+s+",\n            "+a+",\n            "+i+"\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos["+l[0]+"],\n            transpose_out_pos["+l[1]+"], transpose_out_pos["+l[2]+"], transpose_out_pos["+l[3]+"]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * "+s+"\n            + transpose_in_pos.g * "+a+" * "+s+"\n            + transpose_in_pos.r * "+u/r+" * "+s+" * "+a+";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            "+u+",\n            "+s+",\n            "+a+",\n            "+i+"\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},pack_out:{mainFunc:function(e,n){return"\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int("+e.out.width_texture+");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},nhwc_2_nchw:{mainFunc:function(e,n){var t=e.origin,o=e.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * "+o.channel+"\n            + oPos.b * "+o.width_shape+" * "+o.channel+"\n            + oPos.g\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+t.channel+",\n            "+t.width_shape+",\n            "+t.height_shape+",\n            "+t.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},feedPost:{mainFunc:function(e,n){var t=e.out,o=n.mean,r=void 0===o?[0,0,0]:o,i=n.std,a=void 0===i?[1,1,1]:i,s=t.total_shape,u=t.height_shape,l=t.width_shape,c=t.channel;return"\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * "+l+"\n            + nhwcPos.g * "+u+" * "+l+"\n            + nhwcPos.r * "+c+" * "+l+" * "+u+";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+c+",\n            "+l+",\n            "+u+",\n            "+s+"\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float("+r[0]+")) / float("+a[0]+");\n        } else if (c == 1) {\n            res = (res - float("+r[1]+")) / float("+a[1]+");\n        } else if (c == 2) {\n            res = (res - float("+r[2]+")) / float("+a[2]+");\n        }\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]},commonFuncConf:["transferFromNHWCtoNCHW"]},imgFeed:{mainFunc:function(){return"\n    uniform vec2 u_scale;\n    uniform int u_keep_ratio;\n\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        // 支持模型不按比例拉伸\n        if (u_keep_ratio == 0) {\n            vec4 origin = TEXTURE2D(texture_origin, outCoord);\n            setPackedOutput(origin);\n            return;\n        }\n        float startX = (1.0 - u_scale.x) / 2.0;\n        float endX = startX + u_scale.x;\n        float startY = (1.0 - u_scale.y) / 2.0;\n        float endY = startY + u_scale.y;\n\n        if (outCoord.x >= startX && outCoord.x <= endX && outCoord.y >= startY && outCoord.y <= endY) {\n            vec2 newPos = (outCoord - vec2(startX, startY)) / u_scale;\n            vec4 origin = TEXTURE2D(texture_origin, newPos);\n            setPackedOutput(origin);\n        }\n        else {\n            setPackedOutput(vec4(1.0));\n        }\n    }\n    "},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(e,n){var t="decode_center_size"===n.code_type;return"\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        "+(t?"\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        ":"\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ")+"\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == "+(t?2:1)+") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        "+(t?"\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        ":"\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ")+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{targetbox:["getValueFromTensorPos"],priorbox:["getValueFromTensorPos"],priorboxvar:["getValueFromTensorPos"]},behaviors:[]},density_prior_box:xe,prior_box:Pe,stack:be,slice:Te},Fe=new $;!function(e,n,t){u.backend=e,n&&(u.backendInstance=n),t&&Object.keys(t).forEach((function(e){!function(e,n){var t=e.conf,o=e.params,r=e.main,i=e.mainFunc,a=e.textureFuncConf,s=e.commonFuncConf,l=e.behaviors,c=void 0===l?[]:l,f=u.backend+"_"+n;u.opRegistry.ops[f]||(u.opRegistry.ops[f]={name:n,conf:t,params:o,main:r,mainFunc:i,textureFuncConf:a,commonFuncConf:s,behaviors:c})}(t[e],e)}))}("webgl",Fe,ye)}},n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={exports:{}};return e[o](r,r.exports,t),r.exports}return t.d=(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t(400)})()},function(e,n,t){e.exports=t(5)},,,function(e,n,t){"use strict";t.r(n),t.d(n,"load",(function(){return d})),t.d(n,"preheat",(function(){return g})),t.d(n,"getGrayValue",(function(){return _})),t.d(n,"drawHumanSeg",(function(){return v})),t.d(n,"blurBackground",(function(){return m})),t.d(n,"drawMask",(function(){return x}));var o=t(0),r=(t(1),function(e,n,t){var o=function(e,n,t){var o=new RegExp("\\b"+n+" \\w+ (\\w+)","ig");e.replace(o,(function(e,n){return t[n]=0,e}))},r=function(e,n,t){var o=e.createShader(t);return e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.log(e.getShaderInfoLog(o)),null)};this.uniform={},this.attribute={};var i=r(e,n,e.VERTEX_SHADER),a=r(e,t,e.FRAGMENT_SHADER);for(var s in this.id=e.createProgram(),e.attachShader(this.id,i),e.attachShader(this.id,a),e.linkProgram(this.id),e.getProgramParameter(this.id,e.LINK_STATUS)||console.log(e.getProgramInfoLog(this.id)),e.useProgram(this.id),o(n,"attribute",this.attribute),this.attribute)this.attribute[s]=e.getAttribLocation(this.id,s);for(var u in o(n,"uniform",this.uniform),o(t,"uniform",this.uniform),this.uniform)this.uniform[u]=e.getUniformLocation(this.id,u)}),i=window.WebGLImageFilter=function(e){e||(e={});var n=null,t=0,o=null,i=!1,a=-1,s=[null,null],u=[],l=-1,c=-1,f=null,h=null,p=e.canvas||document.createElement("canvas"),d={};if(!(n=p.getContext("webgl")||p.getContext("experimental-webgl")))throw"Couldn't get WebGL context";this.addFilter=function(e){var n=Array.prototype.slice.call(arguments,1),t=y[e];u.push({func:t,args:n})},this.reset=function(){u=[]};var g=!1;this.dispose=function(){n.deleteTexture(o),o=null,g=!1},this.apply=function(e){if(_(e.width,e.height),t=0,o||(o=n.createTexture()),n.bindTexture(n.TEXTURE_2D,o),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),g?n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e):(n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),g=!0),0==u.length){P(T.FRAGMENT_IDENTITY);return x(),p}for(var r=0;r<u.length;r++){i=r==u.length-1;var a=u[r];a.func.apply(this,a.args||[])}return p};var _=function(e,t){if(e!=l||t!=c){if(p.width=l=e,p.height=c=t,!f){var o=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]);f=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,f),n.bufferData(n.ARRAY_BUFFER,o,n.STATIC_DRAW),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)}n.viewport(0,0,l,c),s=[null,null]}},v=function(e){return s[e]=s[e]||m(l,c),s[e]},m=function(e,t){var o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o);var r=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,r);var i=n.createTexture();return n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0),n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),{fbo:o,texture:i}},x=function(e){var r=null,s=null,u=!1;r=0==t?o:v(a).texture,t++,!i||e&b.INTERMEDIATE?s=v(a=(a+1)%2).fbo:(s=null,u=t%2==0),n.bindTexture(n.TEXTURE_2D,r),n.bindFramebuffer(n.FRAMEBUFFER,s),n.uniform1f(h.uniform.flipY,u?-1:1),n.drawArrays(n.TRIANGLES,0,6)},P=function(e){if(d[e])return h=d[e],n.useProgram(h.id),h;h=new r(n,T.VERTEX_IDENTITY,e);var t=Float32Array.BYTES_PER_ELEMENT,o=4*t;return n.enableVertexAttribArray(h.attribute.pos),n.vertexAttribPointer(h.attribute.pos,2,n.FLOAT,!1,o,0*t),n.enableVertexAttribArray(h.attribute.uv),n.vertexAttribPointer(h.attribute.uv,2,n.FLOAT,!1,o,2*t),d[e]=h,h},b={INTERMEDIATE:1},T={};T.VERTEX_IDENTITY=["precision highp float;","attribute vec2 pos;","attribute vec2 uv;","varying vec2 vUv;","uniform float flipY;","void main(void) {","vUv = uv;","gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);","}"].join("\n"),T.FRAGMENT_IDENTITY=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","void main(void) {","gl_FragColor = texture2D(texture, vUv);","}"].join("\n");var y={colorMatrix:function(e){var t=new Float32Array(e);t[4]/=255,t[9]/=255,t[14]/=255,t[19]/=255;var o=1==t[18]&&0==t[3]&&0==t[8]&&0==t[13]&&0==t[15]&&0==t[16]&&0==t[17]&&0==t[19]?y.colorMatrix.SHADER.WITHOUT_ALPHA:y.colorMatrix.SHADER.WITH_ALPHA,r=P(o);n.uniform1fv(r.uniform.m,t),x()}};y.colorMatrix.SHADER={},y.colorMatrix.SHADER.WITH_ALPHA=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform float m[20];","void main(void) {","vec4 c = texture2D(texture, vUv);","gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];","gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];","gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];","gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];","}"].join("\n"),y.colorMatrix.SHADER.WITHOUT_ALPHA=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform float m[20];","void main(void) {","vec4 c = texture2D(texture, vUv);","gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];","gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];","gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];","gl_FragColor.a = c.a;","}"].join("\n"),y.brightness=function(e){var n=(e||0)+1;y.colorMatrix([n,0,0,0,0,0,n,0,0,0,0,0,n,0,0,0,0,0,1,0])},y.saturation=function(e){var n=2*(e||0)/3+1,t=-.5*(n-1);y.colorMatrix([n,t,t,0,0,t,n,t,0,0,t,t,n,0,0,0,0,0,1,0])},y.desaturate=function(){y.saturation(-1)},y.contrast=function(e){var n=(e||0)+1,t=-128*(n-1);y.colorMatrix([n,0,0,0,t,0,n,0,0,t,0,0,n,0,t,0,0,0,1,0])},y.negative=function(){y.contrast(-2)},y.hue=function(e){e=(e||0)/180*Math.PI;var n=Math.cos(e),t=Math.sin(e);y.colorMatrix([.213+.787*n+-.213*t,.715+-.715*n+-.715*t,.072+-.072*n+.928*t,0,0,.213+-.213*n+.143*t,.715+n*(1-.715)+.14*t,.072+-.072*n+-.283*t,0,0,.213+-.213*n+-.787*t,.715+-.715*n+.715*t,.072+.928*n+.072*t,0,0,0,0,0,1,0])},y.desaturateLuminance=function(){y.colorMatrix([.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,0,0,0,1,0])},y.sepia=function(){y.colorMatrix([.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0])},y.brownie=function(){y.colorMatrix([.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0])},y.vintagePinhole=function(){y.colorMatrix([.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0])},y.kodachrome=function(){y.colorMatrix([1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0])},y.technicolor=function(){y.colorMatrix([1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0])},y.polaroid=function(){y.colorMatrix([1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0])},y.shiftToBGR=function(){y.colorMatrix([0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0])},y.convolution=function(e){var t=new Float32Array(e),o=1/l,r=1/c,i=P(y.convolution.SHADER);n.uniform1fv(i.uniform.m,t),n.uniform2f(i.uniform.px,o,r),x()},y.convolution.SHADER=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform vec2 px;","uniform float m[9];","void main(void) {","vec4 c11 = texture2D(texture, vUv - px);","vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y));","vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y));","vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) );","vec4 c22 = texture2D(texture, vUv);","vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) );","vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) );","vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) );","vec4 c33 = texture2D(texture, vUv + px );","gl_FragColor = ","c11 * m[0] + c12 * m[1] + c22 * m[2] +","c21 * m[3] + c22 * m[4] + c23 * m[5] +","c31 * m[6] + c32 * m[7] + c33 * m[8];","gl_FragColor.a = c22.a;","}"].join("\n"),y.detectEdges=function(){y.convolution.call(this,[0,1,0,1,-4,1,0,1,0])},y.sobelX=function(){y.convolution.call(this,[-1,0,1,-2,0,2,-1,0,1])},y.sobelY=function(){y.convolution.call(this,[-1,-2,-1,0,0,0,1,2,1])},y.sharpen=function(e){var n=e||1;y.convolution.call(this,[0,-1*n,0,-1*n,1+4*n,-1*n,0,-1*n,0])},y.emboss=function(e){var n=e||1;y.convolution.call(this,[-2*n,-1*n,0,-1*n,1,1*n,0,1*n,2*n])},y.blur=function(e){var t=e/7/l,o=e/7/c,r=P(y.blur.SHADER);n.uniform2f(r.uniform.px,0,o),x(b.INTERMEDIATE),n.uniform2f(r.uniform.px,t,0),x()},y.blur.SHADER=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform vec2 px;","void main(void) {","gl_FragColor = vec4(0.0);","gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;","gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;","gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;","gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;","gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;","gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;","gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;","gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;","gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;","gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;","gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;","gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;","gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;","gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;","gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;","}"].join("\n"),y.pixelate=function(e){var t=e/l,o=e/c,r=P(y.pixelate.SHADER);n.uniform2f(r.uniform.size,t,o),x()},y.pixelate.SHADER=["precision highp float;","varying vec2 vUv;","uniform vec2 size;","uniform sampler2D texture;","vec2 pixelate(vec2 coord, vec2 size) {","return floor( coord / size ) * size;","}","void main(void) {","gl_FragColor = vec4(0.0);","vec2 coord = pixelate(vUv, size);","gl_FragColor += texture2D(texture, coord);","}"].join("\n")},a=function(e,n,t,o){return new(t||(t=Promise))((function(r,i){function a(e){try{u(o.next(e))}catch(e){i(e)}}function s(e){try{u(o.throw(e))}catch(e){i(e)}}function u(e){var n;e.done?r(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,s)}u((o=o.apply(e,n||[])).next())}))},s=function(e,n){var t,o,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(i){return function(s){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,o=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(r=a.trys,(r=r.length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){a.label=i[1];break}if(6===i[0]&&a.label<r[1]){a.label=r[1],r=i;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(i);break}r[2]&&a.ops.pop(),a.trys.pop();continue}i=n.call(e,a)}catch(e){i=[6,e],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,s])}}},u=null,l=null,c=398,f=224,h=null,p=new i;function d(e,n,t){return void 0===e&&(e=!0),void 0===n&&(n=!1),void 0===t&&(t=null),a(this,void 0,void 0,(function(){var r;return s(this,(function(i){switch(i.label){case 0:return"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_398x224_fuse_activation/model.json","https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_288x160_fuse_activation/model.json",r=t||(n?"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_288x160_fuse_activation/model.json":"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_398x224_fuse_activation/model.json"),n&&(c=288,f=160),u=new o.Runner({modelPath:r,needPreheat:void 0===e||e,mean:[.5,.5,.5],std:[.5,.5,.5],webglFeedProcess:!0}),o.env.set("webgl_pack_channel",!0),o.env.set("webgl_pack_output",!0),[4,u.init()];case 1:return i.sent(),u.feedShape&&(c=u.feedShape.fw,f=u.feedShape.fh),[2]}}))}))}function g(){return a(this,void 0,void 0,(function(){return s(this,(function(e){switch(e.label){case 0:return[4,u.preheat()];case 1:return[2,e.sent()]}}))}))}function _(e){return a(this,void 0,void 0,(function(){var n;return s(this,(function(t){switch(t.label){case 0:return l=e,[4,u.predict(e)];case 1:return n=t.sent(),h=function(){var e=c,n=f,t=e/n,o=l.naturalWidth||l.width,r=l.naturalHeight||l.height,i=0,a=0,s=0,u=0,h=r,p=o,d=o/r;t/d>=1?(e=n*d,i=Math.floor((c-e)/2),p=h*t,s=Math.floor((p-o)/2)):(n=e/d,a=Math.floor((f-n)/2),h=p/t,u=Math.floor((h-r)/2));return{x:i,y:a,sw:e,sh:n,bx:s,by:u,bw:p,bh:h}}(),[2,{width:c,height:f,data:n}]}}))}))}function v(e,n,t){var o=l.naturalWidth||l.width,r=l.naturalHeight||l.height,i=n.getContext("2d");n.width=c,n.height=f;var a=document.createElement("canvas"),s=a.getContext("2d");a.width=c,a.height=f;var u=i.getImageData(0,0,c,f);s.drawImage(l,h.x,h.y,h.sw,h.sh);for(var p=s.getImageData(0,0,c,f),d=0;d<c*f;d++)255*e[d+c*f]>100&&(u.data[4*d]=p.data[4*d],u.data[4*d+1]=p.data[4*d+1],u.data[4*d+2]=p.data[4*d+2],u.data[4*d+3]=255*e[d+c*f]);s.putImageData(u,0,0),n.width=o,n.height=r,t&&i.drawImage(t,-h.bx,-h.by,h.bw,h.bh),i.drawImage(a,-h.bx,-h.by,h.bw,h.bh)}function m(e,n){var t=l.naturalWidth||l.width,o=l.naturalHeight||l.height,r=document.createElement("canvas"),i=r.getContext("2d");r.width=c,r.height=f;var a=n.getContext("2d");n.width=t,n.height=o;var s=i.getImageData(0,0,c,f);i.drawImage(l,h.x,h.y,h.sw,h.sh);var u=i.getImageData(0,0,c,f);p.dispose();for(var d=p.apply(r),g=0;g<c*f;g++)255*e[g+c*f]>150&&(s.data[4*g]=u.data[4*g],s.data[4*g+1]=u.data[4*g+1],s.data[4*g+2]=u.data[4*g+2],s.data[4*g+3]=255*e[g+c*f]);i.putImageData(s,0,0),a.drawImage(d,-h.bx,-h.by,h.bw,h.bh),a.drawImage(r,-h.bx,-h.by,h.bw,h.bh)}function x(e,n,t){var o=document.createElement("canvas"),r=o.getContext("2d");o.width=c,o.height=f,r.drawImage(t,0,0,c,f);var i=n.getContext("2d");n.width=c,n.height=f;for(var a=r.getImageData(0,0,c,f),s=0;s<c*f;s++)255*e[s+c*f]>150&&(a.data[4*s+3]=255*e[s]);r.putImageData(a,0,0),i.drawImage(o,0,0,c,f)}p.reset(),p.addFilter("blur",10)}])}));