!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.humanseg=e():(n.buzzstream=n.buzzstream||{},n.buzzstream.humanseg=e())}(this,(function(){return function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="/",t(t.s=3)}([function(n,e,t){n.exports=(()=>{var n={911:(n,e)=>{"use strict";var t=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==t)return t;throw new Error("unable to locate global object")}();n.exports=e=t.fetch,t.fetch&&(e.default=t.fetch.bind(t)),e.Headers=t.Headers,e.Request=t.Request,e.Response=t.Response},994:(n,e,t)=>{"use strict";t.r(e),t.d(e,{PaddlejsBackend:()=>Pn,Runner:()=>vn,Transformer:()=>F,coreUtils:()=>o,env:()=>f,interfaces:()=>r,registerBackend:()=>b,registerOp:()=>x});var o={};t.r(o),t.d(o,{AddItemToVars:()=>u,delUselessData:()=>c,findVarByKey:()=>a,getGlobalInterface:()=>i,getOrMakeGlobalProperty:()=>s,traverseVars:()=>l});var r={};function i(){var n;if("undefined"!=typeof window)n=window;else if(void 0!==t.g)n=t.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}return n}function s(n,e){var t=i();return t[n]||(t[n]=e),t[n]}function a(n,e){return Array.isArray(n)?n.find((function(n){return n.name===e})):n[e]}function u(n,e){var t=Array.isArray(n),o=Array.isArray(e)?e:[e];t?o.forEach((function(e){for(var t=null,o=0;o<n.length;o++)if(n[o].name===e.name){t=o;break}null!==t?n[t]=e:n.push(e)})):o.forEach((function(e){n[e.name]=e}))}function l(n,e){Array.isArray(n)?n.forEach((function(n){e(n)})):Object.keys(n).forEach((function(t){e(n[t])}))}function c(n){if(n.ops=null,n.vars instanceof Array)for(var e=0;e<n.vars.length;e++)n.vars[e].data&&delete n.vars[e].data;else for(var t in n.vars)n.vars[t].data&&delete n.vars[t].data}t.r(r),t.d(r,{BufferType:()=>g,GraphType:()=>v,UniformType:()=>m,WasmMemoryType:()=>_});const f=s("env",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,e){this.ENV[n]=e},n.prototype.get=function(n){return this.ENV[n]},n}()));var h=function(n,e,t,o){return new(t||(t=Promise))((function(r,i){function s(n){try{u(o.next(n))}catch(n){i(n)}}function a(n){try{u(o.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(s,a)}u((o=o.apply(n,e||[])).next())}))},p=function(n,e){var t,o,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,o=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const d=function(){function n(n){this.urlConf={dir:"",main:""},this.separateChunk=!0,this.chunkNum=1,this.dataType="binary",this.params={type:"fetch"},this.inNode=!1,this.isLocalFile=!1,this.realFetch=function(){throw new Error("ERROR: empty fetch funciton")};var e=n,t="model.json";if(n.endsWith(".json")){var o=n.lastIndexOf("/")+1;e=n.substr(0,o),t=n.substr(o)}else"/"!==n.charAt(n.length-1)&&(e=n+"/");this.isLocalFile=0!==e.indexOf("http"),this.urlConf={dir:this.isLocalFile?"/"===e.charAt(0)?""+e:"/"+e:e,main:t},this.inNode="node"===f.get("platform")}return n.prototype.load=function(){return h(this,void 0,void 0,(function(){var e;return p(this,(function(t){switch(t.label){case 0:return[4,this.fetchModel()];case 1:return e=t.sent(),this.separateChunk=!!e.chunkNum&&e.chunkNum>0,this.chunkNum=this.separateChunk?e.chunkNum:0,this.separateChunk?"binary"!==this.dataType?[3,3]:[4,this.fetchChunks().then((function(t){return n.allocateParamsVar(e.vars,t)}))]:[3,3];case 2:t.sent(),t.label=3;case 3:return[2,e]}}))}))},n.prototype.fetchOneChunk=function(n){return h(this,void 0,void 0,(function(){return p(this,(function(e){switch(e.label){case 0:return f.get("fetch")?[4,f.get("fetch")(n,{type:"arrayBuffer"})]:[3,2];case 1:return[2,e.sent()];case 2:return[2,this.fetch(n).then((function(n){return n.arrayBuffer()}))]}}))}))},n.prototype.fetchJson=function(n){return this.fetch(n).then((function(n){return n.json()}))},n.prototype.getFileName=function(n){return"chunk_"+n+".dat"},n.prototype.fetchChunks=function(){return h(this,void 0,void 0,(function(){var n,e,t;return p(this,(function(o){for(n=this.chunkNum,e=[],t=1;t<=n;t++)e.push(this.fetchOneChunk(this.urlConf.dir+this.getFileName(t)));return[2,Promise.all(e).then((function(n){var e,t=0,o=[];n.forEach((function(n){e=new Float32Array(n),o.push(e),t+=e.length}));var r=new Float32Array(t),i=0;return o.forEach((function(n){n.forEach((function(n){r[i]=n,i+=1}))})),r}))]}))}))},n.allocateParamsVar=function(n,e){var t,o=0,r=Array.isArray(e)?e:Object.values(e);l(n,(function(n){t=n.shape.reduce((function(n,e){return n*e})),n.persistable&&(n.data=r.slice(o,o+t),o+=t)}))},n.prototype.fetch=function(n,e){if(f.get("fetch"))return f.get("fetch")(n,e||{});var o=(e||this.params).method||"get",r=new(this.inNode?t(911).Headers:Headers);return this.realFetch=this.inNode?this.isLocalFile?this.fetchLocalFile:t(911):window.fetch.bind(window),this.realFetch(n,{method:o,headers:r})},n.prototype.fetchLocalFile=function(n){var e=t(993);return new Promise((function(t,o){try{t(e.readFileSync(n,"utf8"))}catch(n){o(n)}}))},n.prototype.fetchModel=function(){var n=this,e=this.params,t=this.urlConf.dir+this.urlConf.main,o=null;return"fetch"===e.type&&(o=new Promise((function(o,r){n.fetch(t,e).then((function(e){return f.get("fetch")?e:n.isLocalFile&&n.inNode?JSON.parse(e):e.json()})).then((function(n){return o(n)})).then((function(n){return r(n)}))}))),o},n}();var g,_,m,v;!function(n){n.FrameBuffer="frameBuffer",n.ColorBuffer="colorBuffer"}(g||(g={})),function(n){n.memory100="100",n.memory200="200",n.memory300="300",n.memory400="400",n.memory500="500",n.memory600="600",n.memory700="700",n.memory800="800",n.memory900="900"}(_||(_={})),function(n){n.uniform1f="1f",n.uniform1fv="1fv",n.uniform1i="1i",n.uniform1iv="1iv",n.uniform2f="2f",n.uniform2fv="2fv",n.uniform2i="2i",n.uniform2iv="2iv",n.uniform3f="3f",n.uniform3fv="3fv",n.uniform3i="3i",n.uniform3iv="3iv",n.uniform4f="4f",n.uniform4fv="4fv",n.uniform4i="4i",n.uniform4iv="4iv"}(m||(m={})),function(n){n.SingleOutput="single",n.MultipleOutput="multiple",n.MultipleInput="multipleInput"}(v||(v={}));var P={opRegistry:{ops:{}},backend:"",backendInstance:null};function x(n,e){var t=n.conf,o=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,u=n.behaviors,l=void 0===u?[]:u,c=P.backend+"_"+e;P.opRegistry.ops[c]||(P.opRegistry.ops[c]={name:e,conf:t,params:o,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:l})}function b(n,e,t){n&&(P.backend=n),e&&(P.backendInstance=e),t&&Object.keys(t).forEach((function(n){x(t[n],n)}))}P=s("GLOBALS",P);var T=i();T.ImageBitmap||(T.ImageBitmap=function(){});const y=function(){function n(n,e){this.id="",this.type="",this.inputs={},this.outputs={},this.attrs={},this.subAttrs=[],this.next="",this.opData=null,this.isPacked=!1,this.bufferType=g.FrameBuffer,this.uniform=null;var t=n.inputs,o=n.outputs,r=n.attrs,i=void 0===r?{}:r,s=n.type,a=n.isPacked,u=void 0!==a&&a,l=n.bufferType,c=void 0===l?g.FrameBuffer:l,f=n.uniform,h=void 0===f?null:f;this.id=s+"_"+ +new Date+"_"+e,this.inputs=t,this.outputs=o,this.attrs=i,this.subAttrs=n["sub-attrs"]||[],this.uniform=h,this.type=s,this.isPacked=u,this.bufferType=c,this.next="",this.opData=null}return Object.defineProperty(n.prototype,"inputsName",{get:function(){var n=this,e=[];return Object.keys(this.inputs).forEach((function(t){e.push(n.inputs[t][0])})),e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"outputsName",{get:function(){return this.outputs.Output||this.outputs.Out||this.outputs.Y},enumerable:!1,configurable:!0}),n.prototype.execute=function(n){P.backendInstance.runProgram(this.opData,n)},n}(),F=function(n){this.name=n};var w,E=(w=function(n,e){return(w=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}w(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),A={conv2d:function(n,e){var t=n.attrs.strides,o=n.inputs.Input[0],r=n.inputs.Filter[0];if("image"===o)return!1;var i=a(e,o).shape,s=a(e,r).shape;return!t.find((function(n){return n>1}))&&i[i.length-1-2]%4==0&&4===s.length&&s[0]%4==0&&s[1]%4==0}};function O(n){return{type:"packed_2_unpacked",attrs:{},inputs:{Input:[n.inputName]},outputs:{Output:[n.outputName]}}}function V(n){return{type:"unpacked_2_packed",attrs:{},inputs:{Input:[n.inputName]},outputs:{Output:[n.outputName]}}}function C(n,e){Object.keys(n.inputs).forEach((function(e){n.inputs[e]=[n.inputs[e]+"_packed"]})),Object.keys(n.outputs).forEach((function(e){n.outputs[e]=[n.outputs[e]+"_packed"]})),n.type=n.type+"_packing",n.id=n.type+"_"+ +new Date+"_"+e.length,n.isPacked=!0}const k=function(n){function e(){return n.call(this,"TexturePacking")||this}return E(e,n),e.prototype.transform=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];if("webgl"===P.backend&&f.get("webgl_pack_channel")){var t=n[0],o=n[1],r=n[2],i="depthwise_conv2d"===t.type?"conv2d":t.type,s=A[i];if(s&&s(t,o)){var a=t.inputs,u=t.outputs,l=a.Input[0],c=u.Output?u.Output[0]:u.Out[0],h=V({inputName:l,outputName:l+"_packed"}),p=r.length;r.push(new y(h,p)),C(t,r);var d=O({inputName:c+"_packed",outputName:c}),g=r.length+1;r.push(new y(d,g))}}},e}(F);var S=function(){var n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(e,t)};return function(e,t){function o(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}();const R=function(n){function e(){return n.call(this,"FormatInputsX")||this}return S(e,n),e.prototype.transform=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];var t=n[0],o=["concat","connect","fc","rnn_origin","rnn_matmul","stack"];if(o.includes(t.type)){var r=t.inputs;if(("rnn_origin"===t.type||"rnn_matmul"===t.type)&&r.WeightList.length>0)r.WeightList.forEach((function(n,e){r["weightlist_"+e]=[n]}));else{var i=r.X||r.Input;if("wasm"!==f.get("backend"))i.length>1&&(i.forEach((function(n,e){r["origin"+(e>0?"_"+e:"")]=[n]})),delete r.X,delete r.Input);else{if(i.length>4)throw Error("Not yet supporting concat input tensors more than 4.");if(i.length>1){var s=i[0],a=i[1],u=i[2],l=i[3];r.X=[s],a&&(r.Y=[a]),u&&(r.Z=[u],t.type+="_mul"),l&&(r.M=[l])}}}}},e}(F);var I=function(){var n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(e,t)};return function(e,t){function o(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),M=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o};function L(n,e){var t=a(e,n);return t?t.shape:[]}function j(n,e,t,o){for(var r=M(e),i=0,s=0,a=n;s<a.length;s++)i+=L(a[s],o)[t];return r[t]=i,{name:n[n.length-1]+"_out",shape:r}}const D=function(n){function e(){return n.call(this,"splitOp")||this}return I(e,n),e.prototype.transform=function(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var o=e[0],r=e[1],i=0,s=o.length;i<s;i++){var a=o[i];if("concat"===a.type&&(null===(n=a.inputs)||void 0===n?void 0:n.X)&&!(a.inputs.X.length<=4)){var l=a.attrs,c=a.inputs,f=a.outputs,h=c.X,p=h.length,d=Math.ceil((p-4)/3)+1,g=f.Out[0],_=L(g,r),m=l.axis||0;m=m>-1?m:_.length+m;for(var v=[],P=[],x=h.slice(0,4),b=void 0,T=0;T<d;T++){var y=0===T?x:h.slice(3*T+1,3*(T+1)+1),F=j(y,_,m,r);0!==T&&y.splice(0,0,b.name),F.shape[m]+=b?b.shape[m]:0;var w={Out:[F.name]};P.push({attrs:l,inputs:{X:y},outputs:w,type:"concat"}),v.push(F),b=F}P[d-1].outputs.Out=[g],o.splice.apply(o,M([i,1],P)),u(r,v)}}},e}(F);var B=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o};function N(n){if(n.length<4){for(var e=[],t=0;t<4-n.length;t++)e.push(1);return e.concat(n)}return B(n)}function U(n){return n.reduce((function(n,e){return n+e}))}function G(n,e){var t=n.length;return 4-t+(e>-1?e:t+e)}function X(n,e){for(var t=e[0],o=e[1],r=e[2],i=e[3],s=r*i,a=o*r*i,u=[],l=0;l<t;l++)for(var c=0;c<i;c++)for(var f=0;f<o;f++)for(var h=0;h<r;h++)u.push(n[l*a+f*s+h*i+c]);return new Float32Array(u)}function H(n){for(var e,t=n.data,o=n.shape,r=B(o).reverse(),i=0,s=r.length-1;i<s;i++)e=W(e||t,r[i]);return e}function W(n,e){for(var t=[],o=0,r=n.length;o<r;o+=e)t.push(n.slice(o,o+e));return t}var z=function(){var n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(e,t)};return function(e,t){function o(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),Y="fetch_pack";const q=function(n){function e(){return n.call(this,"PackOut")||this}return z(e,n),e.prototype.transform=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];if(f.get("webgl_pack_output")&&1!==f.get("webglVersion")){var t=n[0],o=n[1],r=t.find((function(n){return"fetch"===n.type})),i=r.inputs.X[0],s=a(o,i),l=N(s.shape),c=l[0],h=l[1],p=l[2],d=l[3],g={attrs:{},inputs:{X:[i]},outputs:{Y:[Y]},type:"pack_out"},_=h*d,m=Math.ceil(c*p/4),v={name:Y,shape:[1,1,m,_],persistable:!1};r.inputs.X=[Y],r.attrs.origin_shape=[c,h,p,d],t.push(g),u(o,[v])}},e}(F);var Z=function(){var n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(e,t)};return function(e,t){function o(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),K="img_pre_processed",J="img_origin";const Q=function(n){function e(){return n.call(this,"FeedProcess")||this}return Z(e,n),e.prototype.transform=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];var t=n[0],o=n[1],r=n[2];if(r.webglFeedProcess||f.get("webgl_gpu_pipeline")){var i=r.mean,s=void 0===i?[0,0,0]:i,l=r.std,c=void 0===l?[1,1,1]:l,h=r.scale,p=void 0===h?[1,1]:h,d=r.pos,g=void 0===d?[0,0]:d,_=r.feedShape,v=a(o,"image"),P=v.shape,x=P[2],b=P[3];v.shape=[1,1,x,b];var T=Object.assign({},v);T.name=K,T.shape=[1,3,_.fh,_.fw],T.persistable=!1,delete T.data;var y=Object.assign({},v);y.name=J,y.shape=[1,1,_.fh,_.fw],y.persistable=!1,delete y.data,u(o,[y,T]);var F=t.find((function(n){var e=n.inputs;return Object.keys(e).find((function(n){return"image"===e[n][0]}))})),w=F.inputs;Object.keys(w).forEach((function(n){"image"===w[n][0]&&(w[n][0]=K)}));var E={attrs:{mean:s,std:c},inputs:{X:[J]},outputs:{Y:[K]},type:"feedPost"},A={attrs:{mean:s,std:c,scale:p,pos:g},inputs:{X:["image"]},outputs:{Y:[J]},type:"imgFeed",uniform:{u_scale:{type:m.uniform2fv,value:[1,1]},u_pos:{type:m.uniform2fv,value:[0,0]},u_keep_ratio:{type:m.uniform1i,value:1}},isPacked:!0};t.splice(1,0,E),t.splice(1,0,A)}},e}(F),$={preTransforms:[new D,new q,new Q],transforms:[new R,new k],postTransforms:[]};var nn,en=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o};function tn(n,e){return n&&n[e]||[]}!function(n){n.PreTransforms="preTransforms",n.Transforms="transforms",n.PostTransforms="postTransforms"}(nn||(nn={}));const on=function(){function n(n,e){this.weightMap=[],this.ops=[],this.vars=[],this.config={},this.type=v.SingleOutput,this.plugins=null,this.ops=n.ops,this.vars=n.vars,this.type=e.type||this.type,this.plugins=e.plugins,this.config=e,n.feedShape&&(this.config.feedShape=n.feedShape)}return n.prototype.createGraph=function(){return this.preTransforms(),this.createOpsMap(),this.arrangeMap(),this.postTransforms(),this.weightMap},n.prototype.preTransforms=function(){var n=this;en($.preTransforms,tn(this.plugins,nn.PreTransforms)).forEach((function(e){e.transform(n.ops,n.vars,n.config)}))},n.prototype.transforms=function(n,e){var t=this;en($.transforms,tn(this.plugins,nn.Transforms)).forEach((function(o){o.transform(n,t.vars,e)}))},n.prototype.postTransforms=function(){var n=this;en($.postTransforms,tn(this.plugins,nn.PostTransforms)).forEach((function(e){e.transform(n.weightMap,n.vars,n.type)}))},n.prototype.createOpsMap=function(){for(var n=[],e=0;e<this.ops.length;e++){var t=n.length,o=this.ops[e],r=new y(o,t);this.transforms(r,n),n.push(r)}this.weightMap=n},n.prototype.arrangeMap=function(){for(var n={},e=[],t={},o=function(o){for(var i=r.weightMap[o],s=0;s<i.outputsName.length;s++){var a=i.outputsName[s];n[a]=!0}e[o]=0,t[i.id]=o,i.inputsName.length>1?i.inputsName.forEach((function(t){!0===n[t]&&e[o]++})):e[o]=i.inputsName.length},r=this,i=0;i<this.weightMap.length;i++)o(i);this.topoSort(this.weightMap,e,t)},n.prototype.topoSort=function(n,e,t){var o=[];o.push(n[0]);for(var r=n.slice(0),i=null,s=n[0];o.length>0;){null!=i&&(n[t[i.id]].next=s.id),i=s,s=o.pop()||{};for(var a=0;a<s.outputsName.length;a++)for(var u=0;u<r.length;u++)for(var l=0;l<r[u].inputsName.length;l++)if(r[u].inputsName[l]===s.outputsName[a]&&(e[t[r[u].id]]--,0===e[t[r[u].id]])){o.push(n[t[r[u].id]]),r.splice(u,1),u--;break}}},n.prototype.getFeedExecutor=function(){return this.weightMap.find((function(n){return"feed"===n.type}))},n.prototype.getFetchExecutor=function(){return this.weightMap.find((function(n){return"fetch"===n.type}))},n.prototype.getExecutorById=function(n){return this.weightMap.find((function(e){return e.id===n}))},n}(),rn=function(){function n(n){this.opts={},this.isPacked=!1,this.name="",this.tensorId="",this.total=1,this.shape=[],this.unformattedShapeLength=0,this.shape_texture=[],this.exceedMax=!1,this.data=null,this.persistable=!1,this.interpType="NEAREST",this.dataLayout="",this.runtime=0,this.binding=0;var e=n.isPacked,t=void 0!==e&&e,o=n.name,r=n.runtime,i=void 0===r?0:r,s=n.persistable,a=void 0!==s&&s,u=n.type,l=n.dataLayout,c=n.interpType,f=void 0===c?"NEAREST":c,h=n.shape,p=n.data,d=n.binding,g=void 0===d?0:d;this.opts=n,this.isPacked=t,this.name=o,this.runtime=i,this.binding=g,this.persistable=a,this.interpType=f,this.tensorId=u,this.dataLayout=l,this.unformattedShapeLength=h.length,this.shape=N(h),this.total=this.shape.reduce((function(n,e){return n*e})),n.noLayout||p&&p.length&&(this.data=function(n,e,t,o){if("nhwc"===e){var r=t[0],i=t[1],s=X(n,[r,t[2],t[3],i*(o?4:1)]);return new Float32Array(s)}return new Float32Array(n)}(p,this.dataLayout,this.shape,this.isPacked),n.data=null)}return Object.defineProperty(n.prototype,"width_texture",{get:function(){var n=this.shape_texture.length;return this.shape_texture[n-1]||1},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height_texture",{get:function(){var n=this.shape_texture.length;return this.shape_texture[n-2]||1},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"width_shape",{get:function(){var n=this.shape.length;return this.shape[n-1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height_shape",{get:function(){var n=this.shape.length;return this.shape[n-2]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"channel",{get:function(){var n=this.shape.length;return this.shape[n-3]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"length_shape",{get:function(){return this.shape.length||0},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"length_unformatted_shape",{get:function(){return this.unformattedShapeLength||0},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"total_shape",{get:function(){return this.total},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"numbers_shape",{get:function(){for(var n=[],e=this.shape.length,t=0;t<e-1;t++){var o=this.shape.slice(t+1).reduce((function(n,e){return n*e}));n.push(o)}return n.push(1),n},enumerable:!1,configurable:!0}),n}(),sn={adaptPaddings:function(){for(var n in this.processedAttrs)if(Object.prototype.hasOwnProperty.call(this.processedAttrs,n)&&"paddings"===n){var e=this.processedAttrs[n],t=e[0],o=e[1];return void(0===t&&1===o&&(this.processedAttrs[n][1]=0))}},setAdaptive:function(){this.processedAttrs.adaptive&&2===this.processedAttrs.ksize.length&&1===this.processedAttrs.ksize[0]&&1===this.processedAttrs.ksize[1]&&(this.processedAttrs.adaptive=!1,this.processedAttrs.global_pooling=!0)},isGlobalPooling:function(){var n,e=this.tensorDataMap.origin,t=(null===(n=null==e?void 0:e.shape)||void 0===n?void 0:n.length)||0;t>2&&this.processedAttrs.global_pooling&&(this.processedAttrs.ksize=[e.shape[t-2],e.shape[t-1]])},setPacked:function(){var n=this.processedAttrs.ispacked;this.tensorDataMap.origin&&n&&this.name.indexOf("pool")>-1&&(this.name+="_winograd")},mergeAttrs:function(){this.processedAttrs=this.subAttrs.reduce((function(n,e){return Object.assign(n,e)}),{})},isApplySeparableConv:function(){if(!this.isPackedOp){var n=this.processedAttrs.groups,e=this.tensorDataMap.filter;if("depthwise_conv2d"===this.name&&(this.name="conv2d"),e){var t=e.shape,o=t[0],r=t[1];o===n&&1===r&&(this.name+="_depthwise")}}},batchComputeConv2d:function(){var n=this.tensorDataMap.filter.shape[1];this.processedAttrs.filter_nearest_vec4=4*Math.floor(n/4),this.processedAttrs.filter_remainder_vec4=n%4},processBias:function(){var n=this.tensorDataMap.bias;if(n&&this.isPackedOp){n.packed=!0;var e=n.shape,t=[e[e.length-1]/4,1,1];n.shape=t}},isAdaptiveAvg:function(){var n=this.processedAttrs,e=n.adaptive,t=n.pooling_type;e&&"avg"===t&&(this.name+="_avg_adaptive")},isMax:function(){var n="max"===this.processedAttrs.pooling_type?1:0;this.processedAttrs.pooling_type=n,1===n&&(this.name+="_max")},transToPrelu:function(){this.processedAttrs.multi_value="0.0",this.processedAttrs.active_function="prelu"},transToRelu6:function(){this.processedAttrs.multi_value=this.processedAttrs.threshold,this.processedAttrs.active_function="relu6"},transToHardSigmoid:function(){this.processedAttrs.multi_value=this.processedAttrs.slope||.2,this.processedAttrs.bias_value=this.processedAttrs.offset||.5,this.processedAttrs.active_function="hardSigmoid"},transToLeakyrelu:function(){this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu",this.name="relu"},transToPow:function(){this.processedAttrs.multi_value=this.processedAttrs.factor||2,this.processedAttrs.active_function="pow_func",this.name="pow"},transToSigmoid:function(){this.processedAttrs.active_function="sigmoid"},transToSqrt:function(){this.processedAttrs.active_function="sqrt"},transToTanh:function(){this.processedAttrs.active_function="tanh_func"},transToExp:function(){this.processedAttrs.active_function="exp"},transToScale:function(){var n=this.processedAttrs.scale;this.processedAttrs.multi_value=void 0!==n?n:1,this.processedAttrs.bias_value=this.processedAttrs.bias||0;var e=this.processedAttrs.bias_after_scale;this.processedAttrs.active_function=e||void 0===e?"scale":"scaleWidthBias"},setActiveFunc:function(){var n=this.name.replace("conv2d-elementwise_add-","");this.processedAttrs=Object.assign({active_function:"scale",multi_value:"1.0",bias_value:"0.0",fuse_relu:!1},this.processedAttrs),"leaky_relu"===n&&(this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu")},normalizePerm:function(){var n=this.tensorDataMap.origin.shape.length,e=this.processedAttrs.axis,t=e.length;if(t-n>0&&(t=(e=e.map((function(n){return n-1})).filter((function(n){return n>=0}))).length),t>4)throw Error("op transpoes2 axis length exceeds maximum length 4, get "+t);for(var o=new Array(t).fill(0),r=0;r<t;r++)o[e[r]]=r;var i=[];for(r=0;r<4;r++)i[r]=o[r]||0;this.processedAttrs.perm_arr=i,this.processedAttrs.perm_size=t},normalizeDim:function(){for(var n=this.tensorDataMap.origin.shape,e=N(n),t=G(n,this.processedAttrs.axis),o=[],r=0;r<e[t];r++)o[r]=r;if(this.processedAttrs.target_length=o.length,this.processedAttrs.target_value=o,this.processedAttrs.inputs_dim=e[t],this.processedAttrs.dim=t,0===this.processedAttrs.num&&(this.processedAttrs.num=Object.values(this.tensorDataMap).filter((function(n){return"out"===n.tensorName})).length||1),"wasm"===f.get("backend")){this.processedAttrs.fourInputs=!1;var i=this.tensorDataMap.counter;if(i){var s=N(i.shape);this.processedAttrs.counter_num=s[t]}var a=this.tensorDataMap.appender;if(a){var u=N(a.shape);this.processedAttrs.append_num=u[t]}var l=this.tensorDataMap.fourth;if(l){this.processedAttrs.fourInputs=!0;var c=N(l.shape);this.processedAttrs.fourth_num=c[t]}}},processElementwiseAxis:function(){var n=this.tensorDataMap.origin.shape,e=this.tensorDataMap.counter.shape,t=void 0===this.processedAttrs.axis?-1:this.processedAttrs.axis;this.processedAttrs.counterLen=e.length,U(n)===U(e)?(this.processedAttrs.axis=0,this.processedAttrs.counterLen=4):(-1===t&&(t=n.length-e.length),this.processedAttrs.axis=G(n,t))},genElementwiseCounterPos:function(){for(var n=this.processedAttrs,e=n.counterLen,t=["0","0","0","0"],o=n.axis,r=4-e;r<4;r++)t[r]="oPos["+o+++"]";this.processedAttrs.counterPos=t.join(",")},flattenShape:function(){var n=Object.values(this.tensorDataMap).find((function(n){return n.shape.length>2}));if(n){var e=N(n.shape);n.shape=[e[0]*e[2],e[1]*e[3]]}},reshape:function(){var n=this.tensorDataMap.origin,e=this.tensorDataMap.counter,t=this.tensorDataMap.out;if(e.shape.length>n.shape.length){var o=e;e=n,n=o}if(n.shape.length>2&&2===e.shape.length){var r=function(n,e){void 0===n&&(n=[]),void 0===e&&(e=[]);var t=n.reduce((function(n,e){return n*e}));return 1===e.length?[1,t]:[e[0],t/e[0]]}(n.shape,t.shape);n.shape=r}},checkIsMerge:function(){var n=this.name.replace("conv2d-elementwise_add-","");this.name="conv2d_elementwise_add","leaky_relu"===n&&(this.processedAttrs.alpha&&(this.processedAttrs.multi_value=this.processedAttrs.alpha),this.processedAttrs.active_function="leakyRelu")}};var an=function(){return(an=Object.assign||function(n){for(var e,t=1,o=arguments.length;t<o;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};const un=function(){function n(n,e,t,o,r){this.name="",this.isPackedOp=!1,this.processedAttrs={},this.subAttrs=[],this.uniform=null,this.inputTensors=[],this.outputTensors=[],this.dataLayout="",this.iLayer=0,this.program=[],this.isFinalOp=!1,this.bufferType=g.FrameBuffer,this.tensorDataMap={},this.tensorData=[];var i=n.type,s=n.inputs,a=n.outputs,u=n.attrs,l=n.isPacked,c=n.bufferType,f=void 0===c?g.FrameBuffer:c,h=n.uniform,p=void 0===h?null:h;this.modelName=r,this.subAttrs=n.subAttrs,this.name=i,this.isPackedOp=l,this.bufferType=f,this.dataLayout=t.dataLayout||"",this.iLayer=e,this.isFinalOp=o,this.uniform=p,this.initExtendedAttrs(u),this.constructTensorData(s,a,t.vars),this.buildTensor();var d=this.buildShaderParams();this.buildProgram(d)}return n.prototype.initExtendedAttrs=function(n){for(var e in n)if(Object.prototype.hasOwnProperty.call(n,e)){var t=n[e];this.processedAttrs[e]=t}},n.prototype.constructTensorData=function(n,e,t){var o=this;Object.keys(e).forEach((function(n){e[n].forEach((function(r,i){e[n][i]=o.getTensorVar(r,t)}))})),Object.keys(n).forEach((function(e){n[e]=[o.getTensorVar(n[e][0],t)]}));var r=function(n){if(Object.prototype.hasOwnProperty.call(e,n))try{var t=e[n]||[{}],r=i.getExactTensorName(n,"output");r&&t.forEach((function(n,e){n.tensorName=r,o.tensorDataMap[r+"_"+e]=an(an({},n),{tensorName:r,runtime:e})}))}catch(n){console.error(n)}},i=this;for(var s in e)r(s);for(var s in n)if(Object.prototype.hasOwnProperty.call(n,s)){var a=n[s].length>0?n[s]:[{}],u=this.getExactTensorName(s,"input");if(u){var l=a[0];l.tensorName=u,this.tensorDataMap[u]=an(an({},l),{tensorName:u})}}},n.prototype.getExactTensorName=function(n,e){return"input"===e?{input:"origin",x:"origin",y:"counter",w:"weight"}[n.toLowerCase()]||n.toLowerCase():{output:"out",y:"out",out:"out",scale:"scale",bias:"bias",mean:"mean",variance:"variance",mask:"out",boxes:"out",variances:"out"}[n.toLowerCase()]},n.prototype.getTensorVar=function(n,e){var t=a(e,n.replace(/_packed$/,""));return t&&n.endsWith("_packed")?function(n,e){var t=3===n.shape.length?B([1],n.shape):n.shape,o=t[0],r=t[1],i=t[2],s=t[3],a=Object.assign({},n);if(a.name=e,a.packed=!1,r%4==0){var u=r/4;a.packed=!0,a.shape=[o,u,i,s]}return a}(t,n):t},n.prototype.buildProgram=function(n){var e=this,t=this.name,o=P.backend+"_"+t,r=P.opRegistry.ops[o];try{if(!r&&"wasm"!==f.get("backend"))throw new Error("[unregistered op] "+t);var i=this.inputTensors;this.program=this.outputTensors.map((function(t,o){return P.backendInstance.createProgram({op:r,outTensor:t,inputTensors:i,shaderParams:n[o],runtime:o,isFinalOp:e.isFinalOp})}))}catch(n){console.error(n)}},n.prototype.processTensorDataAndAttrs=function(){var n=this;try{this.name.indexOf("conv2d-elementwise_add")>-1?this.name="conv2d_elementwise_add":this.name.indexOf("max_pool2d_with_index")>-1&&(this.name="pool2d_max");var e=P.backend+"_"+this.name;(P.opRegistry.ops[e]&&P.opRegistry.ops[e].behaviors||[]).forEach((function(e){try{sn[e].call(n)}catch(n){console.error(n)}}))}catch(n){console.error(n)}},n.prototype.buildTensor=function(){var n=this;this.processTensorDataAndAttrs();var e=Object.values(this.tensorDataMap);e.forEach((function(e,t){var o,r=e.tensorName,i=new rn({type:n.modelName+"_"+e.name,name:r,shape:e.shape,data:e.data||null,persistable:e.persistable||!1,interpType:e.interpType||"NEAREST",isPacked:n.isPackedOp||e.packed||!1,binding:t,noLayout:null===(o=P.backendInstance)||void 0===o?void 0:o.noLayout,dataLayout:n.dataLayout,runtime:e.runtime||0});"out"===r?n.outputTensors.push(i):n.inputTensors.push(i),e.shape=i.shape,e.total=i.total})),this.tensorDataMap=null,this.tensorData=e},n.prototype.buildShaderParams=function(){var n=this,e=[];return this.outputTensors.forEach((function(){var t=JSON.parse(JSON.stringify(n.processedAttrs));e.push(t)})),e},n}();var ln=function(){return(ln=Object.assign||function(n){for(var e,t=1,o=arguments.length;t<o;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};const cn=function(){function n(){this.targetContext={},this.gapFillWith="#fff",this.mean=[0,0,0],this.std=[1,1,1],this.bgr=!1,this.pixelWidth=1,this.pixelHeight=1,this.inputFeed=[],this.targetCanvas=f.get("canvas2d")||document.createElement("canvas"),this.targetContext=this.targetCanvas.getContext("2d")}return n.prototype.process=function(n,e,t){var o=e.fill,r=e.mean,i=e.std,s=e.bgr,a=e.keepRatio,u=void 0===a||a,l=e.scale,c=void 0===l?0:l,f=t.fc,h=void 0===f?3:f,p=t.fh,d=t.fw,g=n,_={gapFillWith:o||this.gapFillWith,mean:r||this.mean,std:i||this.std,bgr:s||this.bgr,keepRatio:u,scale:c,targetSize:{width:d,height:p},targetShape:[1,h,p,d]};return this.fromPixels(g,_)||[]},n.prototype.fromPixels=function(n,e){var t=[],o={gapFillWith:e.gapFillWith,dx:0,dy:0,dWidth:e.targetSize.width,dHeight:e.targetSize.height},r=n,i=n.path&&n.width&&n.height;if(!i&&!(n instanceof ImageBitmap||n instanceof HTMLVideoElement||n instanceof HTMLImageElement||n instanceof HTMLCanvasElement))return[{data:t,shape:e.shape||e.targetShape,name:"image",persistable:!0}];this.pixelWidth=n.naturalWidth||n.width,this.pixelHeight=n.naturalHeight||n.height;var s=f.get("webgl_gpu_pipeline")||e.webglFeedProcess;return this.fitToTargetSize(i?r.path:r,o,ln(ln({},e),{inGPU:s})),t=this.getImageData(o),s?[{data:t=Float32Array.from(t.data),shape:[1,1,o.dHeight,o.dWidth],name:"image",persistable:!0}]:[{data:t=this.allReshapeToRGB(t,e),shape:e.targetShape||e.shape,name:"image",persistable:!0}]},n.prototype.allReshapeToRGB=function(n,e){for(var t=e.mean,o=e.std,r=e.targetShape,i=e.bgr,s=e.normalizeType,a=void 0===s?0:s,u=r[1],l=r[2],c=r[3],f=n.data||n,h=new Float32Array(l*c*u),p=0,d=0;d<l;++d)for(var g=d*c,_=0;_<c;++_)for(var m=g+_,v=0;v<u;++v){var P=i?4*m+(2-v):4*m+v;h[p]=0===a?f[P]/255:(f[P]-128)/128,h[p]-=t[v],h[p]/=o[v],p++}return X(h,[1,l,c,u])},n.prototype.fitToTargetSize=function(n,e,t){var o=t||{},r=o.keepRatio,i=void 0===r||r,s=o.inGPU,a=void 0!==s&&s,u=o.scale,l=void 0===u?0:u,c=e.dWidth,f=e.dHeight,h=a?this.pixelWidth:c,p=a?this.pixelHeight:f,d=a?this.pixelWidth:c,g=a?this.pixelHeight:f,_=0,m=0;if(l){if(d-c<0||g-f<0)throw new Error("scale size smaller than target size");this.pixelWidth>this.pixelHeight?(g=l,d=Math.round(g*this.pixelWidth/this.pixelHeight)):(d=l,g=Math.round(d*this.pixelHeight/this.pixelWidth)),this.targetCanvas.width=h=d,this.targetCanvas.height=p=g,e.dx=(d-c)/2,e.dy=(g-f)/2}else i&&(c/f*this.pixelHeight/this.pixelWidth>=1?a?(h=Math.round(g*c/f),_=Math.floor((h-d)/2)):(d=Math.round(g*this.pixelWidth/this.pixelHeight),_=Math.floor((c-d)/2)):a?(p=Math.round(d*f/c),m=Math.floor((p-g)/2)):(g=Math.round(d*this.pixelHeight/this.pixelWidth),m=Math.floor((f-g)/2))),this.targetCanvas.width=e.dWidth=h,this.targetCanvas.height=e.dHeight=p;this.targetContext.fillStyle=e.gapFillWith,this.targetContext.fillRect(0,0,this.targetCanvas.width,this.targetCanvas.height),this.targetContext.drawImage(n,_,m,d,g)},n.prototype.getImageData=function(n){var e=n.dx,t=n.dy,o=n.dWidth,r=n.dHeight;return this.targetContext.getImageData(e,t,o,r)},n.prototype.cover=function(n,e,t,o){var r=t,i=o;return t/o*e/n>=1?r=Math.round(i*n/e):i=Math.round(r*e/n),[r/t,i/o]},n}();var fn=function(){return(fn=Object.assign||function(n){for(var e,t=1,o=arguments.length;t<o;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function hn(n,e,t){for(var o=[],r=0,i=n.length;r<i;r++){var s=n[r];s>e&&o.push({score:s,i:r})}return o.sort((function(n,e){return e.score-n.score})).slice(0,t)}function pn(n){var e=n[0],t=n[1],o=n[2],r=n[3];return o<e||r<t?0:(o-e)*(r-t)}function dn(n,e){if(e[0]>n[2]||e[2]<n[0]||e[1]>n[3]||e[3]<n[1])return 0;var t=pn(n),o=pn(e),r=function(n,e){var t=n[0],o=n[1],r=n[2],i=n[3],s=e[0],a=e[1],u=e[2],l=e[3],c=Math.max(t,s),f=Math.max(o,a);return(Math.min(r,u)-c)*(Math.min(i,l)-f)}(n,e);return r/(t+o-r)}const gn={multiclass_nms:function(n,e){var t=n[0],o=void 0===t?[]:t,r=n[1],i=void 0===r?[]:r,s=H(o),a=H(i);if(!s||!a)return[];if(s=s[0],a=a[0],!(s&&s.length&&a&&a.length))return[];for(var u=e.nms_top_k,l=void 0===u?100:u,c=e.nms_eta,f=void 0===c?1:c,h=e.keep_top_k,p=void 0===h?100:h,d=e.background_label,g=void 0===d?0:d,_=e.nms_threshold,m=void 0===_?.3:_,v=e.score_threshold,P=void 0===v?0:v,x=[],b=0,T=a.length;b<T;b++){var y=[];if(b!==g){var F=hn(a[b],P,l);if(F&&F.length){var w=F.shift(),E=s[w.i];for(y.push(fn(fn({},w),{box:E,label:b}));F.length;){var A=F.shift();E=s[A.i];for(var O=!0,V=0,C=y;V<C.length;V++)if(dn(E,C[V].box)>m){O=!1;break}O&&y.push(fn(fn({},A),{box:E,label:b})),O&&f<1&&m>.5&&(m*=f)}x=x.concat(y)}}}var k=x.sort((function(n,e){return e.score-n.score})).slice(0,p).sort((function(n,e){return n.label-e.label})).map((function(n){return function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}([n.label,n.score],n.box)}));return k&&k.length?k:[]}};var _n=function(n,e,t,o){return new(t||(t=Promise))((function(r,i){function s(n){try{u(o.next(n))}catch(n){i(n)}}function a(n){try{u(o.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(s,a)}u((o=o.apply(n,e||[])).next())}))},mn=function(n,e){var t,o,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,o=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const vn=function(){function n(n){this.runnerConfig={},this.isPaused=!1,this.model={},this.weightMap=[],this.isExecuted=!1,this.test=!1,this.graphGenerator={},this.mediaProcessor=null,this.needPreheat=!0,this.feedShape={},this.runnerConfig=Object.assign({},n),this.needPreheat=void 0===n.needPreheat||n.needPreheat,this.modelName=n.modelName||Date.now().toString(),this.weightMap=[],f.set("ns",i()),"node"!==f.get("platform")&&(this.mediaProcessor=new cn)}return n.prototype.init=function(){return _n(this,void 0,void 0,(function(){var n;return mn(this,(function(e){switch(e.label){case 0:return P.backendInstance?(this.isExecuted=!1,"wasm"!==f.get("backend")?[3,2]:[4,Promise.all([this.load(),P.backendInstance.init()])]):(console.error("ERROR: Haven't register backend"),[2]);case 1:return e.sent(),[3,5];case 2:return[4,P.backendInstance.init()];case 3:return e.sent(),[4,this.load()];case 4:e.sent(),e.label=5;case 5:return this.genFeedData(),this.genGraph(),this.genOpData(),"wasm"!==f.get("backend")?[3,7]:(this.model=Object.assign(this.model,this.runnerConfig),n=this.model,[4,P.backendInstance.initWasm(this.model,this.weightMap)]);case 6:return n.index=e.sent(),[2,[]];case 7:return this.needPreheat?[4,this.preheat()]:[3,9];case 8:return[2,e.sent()];case 9:return[2]}}))}))},n.prototype.load=function(){return _n(this,void 0,void 0,(function(){var n,e,t,o,r,i,s,a;return mn(this,(function(u){switch(u.label){case 0:return n=this.runnerConfig,e=n.modelPath,t=n.modelObj,o=void 0===t?null:t,e?(r=new d(e),i=this,[4,r.load()]):[3,2];case 1:return i.model=u.sent(),[3,3];case 2:(null==o?void 0:o.model)&&(null==o?void 0:o.params)&&(s=o.model,a=o.params,d.allocateParamsVar(s.vars,a),this.model=s),u.label=3;case 3:return[2]}}))}))},n.prototype.genGraph=function(){this.graphGenerator=new on(this.model,this.runnerConfig),this.weightMap=this.graphGenerator.createGraph()},n.prototype.genOpData=function(){var n=this,e=0;this.weightMap.forEach((function(t,o){var r=t.type;if("feed"!==r&&"fetch"!==r){e++;var i=o===n.weightMap.length-2,s=new un(t,e,n.model,i,n.modelName);t.opData=s}})),c(this.model)},n.prototype.preheat=function(){return _n(this,void 0,void 0,(function(){var n;return mn(this,(function(e){switch(e.label){case 0:return[4,this.checkModelLoaded()];case 1:return e.sent(),[4,this.execute()];case 2:return n=e.sent(),this.isExecuted=!0,[2,n]}}))}))},n.prototype.checkModelLoaded=function(){return _n(this,void 0,void 0,(function(){return mn(this,(function(n){switch(n.label){case 0:return 0!==this.weightMap.length?[3,2]:(console.info("It's better to preheat the model before running."),[4,this.load()]);case 1:n.sent(),this.genFeedData(),this.genGraph(),this.genOpData(),this.isExecuted=!1,n.label=2;case 2:return[2]}}))}))},n.prototype.predict=function(n,e){return _n(this,void 0,void 0,(function(){var t,o,r;return mn(this,(function(i){switch(i.label){case 0:return this.isPaused||!this.mediaProcessor?[2]:(t=[],t=this.runnerConfig.webglFeedProcess?[n]:this.mediaProcessor.process(n,this.runnerConfig,this.feedShape),o=[],"wasm"!==f.get("backend")?[3,3]:[4,P.backendInstance.predict(t[0].data,this.model.index)]);case 1:return i.sent(),[4,this.read()];case 2:return r=i.sent(),o=this.postProcess(r),[3,5];case 3:return this.updateFeedData(t),[4,this.execute()];case 4:o=i.sent(),i.label=5;case 5:return this.isExecuted=!0,[2,e?e(o):o]}}))}))},n.prototype.predictWithFeed=function(n,e,t){var o;return _n(this,void 0,void 0,(function(){var r,i,s,a,u,l,c,h,p,d,g,_;return mn(this,(function(m){switch(m.label){case 0:return r=this.feedShape,i=r.fc,s=void 0===i?3:i,a=r.fw,u=r.fh,Array.isArray(n)?(null===(o=n[0])||void 0===o?void 0:o.data)?((d=n[0].data)instanceof Float32Array||(n[0].data=new Float32Array(d)),l=n):l=[{data:new Float32Array(n),shape:t||[1,s,u,a],name:"image",persistable:!0}]:(h=(c=n).width,p=c.height,d=c.data,l=[{data:new Float32Array(d),shape:t||[1,s,p||u,h||a],name:"image",persistable:!0}]),g=[],"wasm"!==f.get("backend")?[3,3]:[4,P.backendInstance.predict(l[0].data,this.model.index)];case 1:return m.sent(),[4,this.read()];case 2:return _=m.sent(),g=this.postProcess(_),[3,5];case 3:return this.updateFeedData(l),[4,this.execute()];case 4:g=m.sent(),m.label=5;case 5:return this.isExecuted=!0,[2,e?e(g):g]}}))}))},n.prototype.genFeedData=function(){var n,e=this.runnerConfig,t=e.type,o=e.feedShape,r=e.webglFeedProcess;this.feedShape=this.model.feedShape||o;var i,s=this.feedShape,l=s.fc,c=void 0===l?3:l,h=s.fh,p=s.fw,d=this.model.vars;if(t===v.MultipleInput){var g=this.model.ops&&this.model.ops[0]&&(null===(n=this.model.ops[0].inputs)||void 0===n?void 0:n.X);g.length>1&&(i=g.map((function(n){var e=a(d,n),t=e.shape.reverse(),o=t[0],r=t[1],i=t[2],s=t[3],u=void 0===s?1:s;return e.data=new Float32Array(u*i*r*o),e})))}else{var _="wasm"!==f.get("backend")&&r?4:c;i=a(d,"image");var m={name:"image",shape:[1,_,h,p]};i=Object.assign(m,i,{data:new Float32Array(_*h*p).fill(1),persistable:!0})}u(d,i)},n.prototype.updateFeedData=function(n){var e=n[0],t=this.weightMap.find((function(n){return n.opData?n.opData.inputTensors.find((function(n){return n.tensorId.endsWith("_image")})):null})),o=t.opData.inputTensors.find((function(n){return n.tensorId.endsWith("_image")}));o.data=e.data;var r=this.runnerConfig,i=r.webglFeedProcess,s=void 0!==i&&i,a=r.keepRatio,u=void 0===a||a;if(s||f.get("webgl_gpu_pipeline")){var l=e.shape||[1,1,e.height,e.width],c=new Uint8Array(e.data||[]);if(e.width&&e.height&&!e.data){var h=e.naturalWidth||e.width;l=[1,1,e.naturalHeight||e.height,h],c=e}var p=o.opts;p.shape=l;var d=t.opData,g=new rn(p);g.data=c,d.inputTensors=[g];var _=l.slice(-2),m=_[0],v=_[1],P=d.outputTensors[0].shape.slice(-2),x=P[0],b=P[1],T=this.mediaProcessor.cover(v,m,b,x);t.uniform.u_scale.value=T,t.uniform.u_keep_ratio.value=+u}},n.prototype.execute=function(){return _n(this,void 0,void 0,(function(){var n,e;return mn(this,(function(t){switch(t.label){case 0:return n=this.graphGenerator.getFeedExecutor(),this.executeOp(n),[4,this.read()];case 1:return e=t.sent(),[2,this.postProcess(e)]}}))}))},n.prototype.postProcess=function(n){var e="wasm"===f.get("backend");if(f.get("debug"))return n;var t=n,o=this.model,r=o.multiOutputs,i=o.postOps;if(r)if(e)t=r.map((function(e,t){var o;return(o={})[e.name]=n[t],o}));else{var s=0;t=r.map((function(e){var t,o=e.shape.reduce((function(n,e){return n*e})),r=n.slice(s,o+s);return s+=o,(t={})[e.name]=r,t}))}if(r&&i&&i.length)for(var a=function(n,e){var o=i[n],r=o.type,s=o.attrs,a=o.inputs,u=gn[r];if(!u)return{value:void 0};var l=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}(t),c=Object.keys(a).map((function(n){var e=a[n],t=e.name,o=e.shape,r=l.filter((function(n){return n[t]}));return r&&r[0]&&r[0][t]?{name:n,tensorId:t,data:r[0][t],shape:o}:(console.error("未获取到"+t+"的数据"),null)}));t=u(c,s)},u=0,l=i.length;u<l;u++){var c=a(u);if("object"==typeof c)return c.value}return t},n.prototype.executeOp=function(n){var e;if("fetch"!==n.type)if("feed"!==n.type&&n.execute(this.isExecuted),f.get("debug")&&(null===(e=n.opData)||void 0===e?void 0:e.outputTensors)&&n.opData.outputTensors[n.opData.outputTensors.length-1]&&n.opData.outputTensors[n.opData.outputTensors.length-1].tensorId===this.modelName+"_"+(f.get("ns").layerName||f.get("layerName")))console.info(n.opData.name+"_"+n.opData.iLayer,"runner op");else if(n.next){var t=n.next,o=this.graphGenerator.getExecutorById(t);this.executeOp(o)}},n.prototype.read=function(){return _n(this,void 0,void 0,(function(){var n,e,t;return mn(this,(function(o){switch(o.label){case 0:return n=this.graphGenerator.getFetchExecutor(),e=a(this.model.vars,n.inputs.X[0]),t={name:e.name,shape:n.attrs.origin_shape||e.shape,index:this.model.index},[4,P.backendInstance.read(t)];case 1:return[2,o.sent()]}}))}))},n.prototype.stopPredict=function(){this.isPaused=!0},n}(),Pn=function(){}},993:()=>{}},e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={exports:{}};return n[o](r,r.exports,t),r.exports}return t.d=(n,e)=>{for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t(994)})()},function(n,e,t){n.exports=(()=>{"use strict";var n={400:(n,e,t)=>{t.r(e),t.d(e,{GLHelper:()=>T,glInstance:()=>wn,ops:()=>Fn,webgl_types:()=>o});var o={};t.r(o),t.d(o,{UniformType:()=>f});var r={};t.r(r),t.d(r,{exp_func:()=>N,hardSigmoid:()=>L,leakyRelu:()=>S,pow_func:()=>D,prelu:()=>C,relu6:()=>k,scale:()=>R,scaleWidthBias:()=>I,sigmoid:()=>M,sqrt:()=>j,tanh_func:()=>B,transferFromNHWCtoNCHW:()=>V});var i={};function s(){var n;if("undefined"!=typeof window)n=window;else if(void 0!==t.g)n=t.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}return n}function a(n,e){var t=s();return t[n]||(t[n]=e),t[n]}t.r(i),t.d(i,{getPixelsFromTexturePos:()=>H,getSamplerCode:()=>z,getTensorPosFromArrayIndex:()=>X,getValueFromTensorPos:()=>U,getValueFromTensorPosPacking:()=>G,moveTexture2PosToReal:()=>W});var u={opRegistry:{ops:{}},backend:"",backendInstance:null};u=a("GLOBALS",u);var l=s();l.ImageBitmap||(l.ImageBitmap=function(){});const c=a("env",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,e){this.ENV[n]=e},n.prototype.get=function(n){return this.ENV[n]},n}()));var f,h,p,d;function g(n){for(var e=n.length,t=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}(n),o=[];e>1;)t.splice(0,1),o.push(t.reduce((function(n,e){return n*e}))),e--;return o}function _(n,e){if(1===n.length)return"float "+e+" = float("+n[0]+");";for(var t=n.length,o="\n        vec"+t+" "+e+" = vec"+t+"(\n    ",r=0;r<t;r++)o+="float("+n[r]+"),";return o.slice(0,-1)+");"}function m(n,e,t){if(0===n.length)return"";if(2===c.get("webglVersion"))return n.reduce((function(e,o,r){return e+(r<n.length-1?t+"("+o+"), ":t+"("+o+"));")}),t+" "+e+"[] = "+t+"[](");var o=n.reduce((function(n,o,r){return n+"\n            "+e+"["+r+"] = "+t+"("+o+");"}),"");return"\n        "+t+" "+e+"["+n.length+"];\n        "+o+"\n    "}function v(n,e,t){if(0===n.length)return"";var o=n.reduce((function(n,e,o){return n+(0===o?"\n            "+t+" res = "+t+"(0);\n            if (index == "+o+") {\n                res = arr["+o+"];\n            }":"\n            else if (index == "+o+") {\n                res = arr["+o+"];\n            }")}),"");return"\n    "+t+" getValueFromArrByIndex_"+e+"("+t+"["+n.length+"] arr, int index) {\n        "+(2===c.get("webglVersion")?t+" res = arr[index];":o)+"\n        return res;\n    }\n    "}!function(n){n.uniform1f="1f",n.uniform1fv="1fv",n.uniform1i="1i",n.uniform1iv="1iv",n.uniform2f="2f",n.uniform2fv="2fv",n.uniform2i="2i",n.uniform2iv="2iv",n.uniform3f="3f",n.uniform3fv="3fv",n.uniform3i="3i",n.uniform3iv="3iv",n.uniform4f="4f",n.uniform4fv="4fv",n.uniform4i="4i",n.uniform4iv="4iv"}(f||(f={})),function(n){n.INT_TYPE="int",n.FLOAT_TYPE="float"}(h||(h={})),function(n){n[n.VS_SHADER=0]="VS_SHADER",n[n.FS_SHADER=1]="FS_SHADER"}(p||(p={})),function(n){n[n.FLOAT_VEC2=35664]="FLOAT_VEC2",n[n.FLOAT_VEC3=35665]="FLOAT_VEC3",n[n.FLOAT_VEC4=35666]="FLOAT_VEC4",n[n.INT_VEC2=35667]="INT_VEC2",n[n.INT_VEC3=35668]="INT_VEC3",n[n.INT_VEC4=35669]="INT_VEC4",n[n.BOOL=35670]="BOOL",n[n.BOOL_VEC2=35671]="BOOL_VEC2",n[n.BOOL_VEC3=35672]="BOOL_VEC3",n[n.BOOL_VEC4=35673]="BOOL_VEC4",n[n.FLOAT_MAT2=35674]="FLOAT_MAT2",n[n.FLOAT_MAT3=35675]="FLOAT_MAT3",n[n.FLOAT_MAT4=35676]="FLOAT_MAT4",n[n.SAMPLER_2D=35677]="SAMPLER_2D",n[n.SAMPLER_CUBE=35678]="SAMPLER_CUBE",n[n.FLOAT=5126]="FLOAT",n[n.INT=5124]="INT"}(d||(d={}));var P,x=function(n,e,t){this.size=n,this.type=e,this.location=t},b=function(n,e,t){this.size=n,this.type=e,this.location=t},T=function(){function n(){}return n.getWebglVersion=function(){return c.get("webglVersion")},n.createCanvas=function(){return c.get("canvas")||document&&document.createElement("canvas")},n.setWebglVersion=function(n){c.set("webglVersion",n)},n.setWebGLRenderingContext=function(n){return this.gl=n,n},n.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},n.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var n=this.createCanvas();if(!n)return null;n.addEventListener&&n.addEventListener("webglcontextlost",(function(n){throw n.preventDefault(),Error("webgl context is lost~")}),!1);var e=n.getContext("webgl2",this.WEBGL_ATTRIBUTES);return e?c.set("webglVersion",2):(c.set("webglVersion",1),e=n.getContext("webgl",this.WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",this.WEBGL_ATTRIBUTES)),e},n.printStates=function(n){console.log("1. isBlendEnable = "+n.isEnabled(n.BLEND)),console.log("2. isCullFaceEnable = "+n.isEnabled(n.CULL_FACE)),console.log("3. isDepthTestEnable = "+n.isEnabled(n.DEPTH_TEST)),console.log("4. isDitherEnable = "+n.isEnabled(n.DITHER)),console.log("5. isPolygonOffsetFillEnable = "+n.isEnabled(n.POLYGON_OFFSET_FILL)),console.log("6. isSampleAlphtToCoverageEnable = "+n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)),console.log("7. isSampleCoverageEnable = "+n.isEnabled(n.SAMPLE_COVERAGE)),console.log("8. isScissorTestEnable = "+n.isEnabled(n.SCISSOR_TEST)),console.log("9. isStencilTestEnable = "+n.isEnabled(n.STENCIL_TEST))},n.printWebGLInfo=function(n){console.log("renderer = "+n.getParameter(n.RENDERER)),console.log("version = "+n.getParameter(n.VERSION)),console.log("vendor = "+n.getParameter(n.VENDOR)),console.log("glsl version = "+n.getParameter(n.SHADING_LANGUAGE_VERSION))},n.printWebGLTextureInfo=function(n){console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_SIZE = ",n.getParameter(n.MAX_TEXTURE_SIZE)),console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE))},n.triggerContextLostEvent=function(n){var e=n.getExtension("WEBGL_lose_context");null!==e&&e.loseContext()},n.checkGLError=function(n){var e=n.getError();return 0!==e&&(console.log("WebGL Error NO: ",e),!0)},n.setDefaultState=function(n){n.clearColor(0,0,0,0),n.clearDepth(1),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.enable(n.SCISSOR_TEST)},n.setViewport=function(n,e){n.viewport(e[0],e[1],e[2],e[3])},n.initShader=function(n,e,t){var o=this.createShader(n,e);return this.compileShader(n,t,o),o},n.createShader=function(n,e){var t;if(null===(t=e===p.VS_SHADER?n.createShader(n.VERTEX_SHADER):n.createShader(n.FRAGMENT_SHADER)))throw new Error("WebGLShader创建失败！");return t},n.compileShader=function(n,e,t){return n.shaderSource(t,e),n.compileShader(t),!1!==n.getShaderParameter(t,n.COMPILE_STATUS)||(console.error(n.getShaderInfoLog(t)),n.deleteShader(t),!1)},n.createProgram=function(n){var e=n.createProgram();if(null===e)throw new Error("WebGLProgram创建失败！");return e},n.linkProgram=function(n,e,t,o,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),n.attachShader(e,t),n.attachShader(e,o),null!==r&&r(n,e),n.linkProgram(e),!1===n.getProgramParameter(e,n.LINK_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(t),n.deleteShader(o),n.deleteProgram(e),!1):(n.validateProgram(e),!1===n.getProgramParameter(e,n.VALIDATE_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(t),n.deleteShader(o),n.deleteProgram(e),!1):(null!==i&&i(n,e),!0))},n.getProgramActiveAttribs=function(n,e,t){for(var o=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES),r=0;r<o;r++){var i=n.getActiveAttrib(e,r);i&&(t[i.name]=new b(i.size,i.type,n.getAttribLocation(e,i.name)))}},n.getProgramAtciveUniforms=function(n,e,t){for(var o=n.getProgramParameter(e,n.ACTIVE_UNIFORMS),r=0;r<o;r++){var i=n.getActiveUniform(e,r);if(i){var s=n.getUniformLocation(e,i.name);null!==s&&(t[i.name]=new x(i.size,i.type,s))}}},n.createBuffer=function(n){var e=n.createBuffer();if(null===e)throw new Error("WebGLBuffer创建失败！");return e},n.getColorBufferData=function(n){var e=new Uint8Array(n.drawingBufferWidth*n.drawingBufferHeight*4);return n.readPixels(0,0,n.drawingBufferWidth,n.drawingBufferHeight,n.RGBA,n.UNSIGNED_BYTE,e),e},n.setUniformParam=function(n,e,t,o){switch(t){case f.uniform1f:n.uniform1f(e,o);break;case f.uniform1fv:n.uniform1fv(e,o);break;case f.uniform1i:n.uniform1i(e,o);break;case f.uniform1iv:n.uniform1iv(e,o);break;case f.uniform2f:n.uniform2f(e,o[0],o[1]);break;case f.uniform2fv:n.uniform2fv(e,o);break;case f.uniform2i:n.uniform2i(e,o[0],o[1]);break;case f.uniform2iv:n.uniform2iv(e,o);break;case f.uniform3f:n.uniform3f(e,o[0],o[1],o[2]);break;case f.uniform3fv:n.uniform3fv(e,o);break;case f.uniform3i:n.uniform3i(e,o[0],o[1],o[2]);break;case f.uniform3iv:n.uniform3iv(e,o);break;case f.uniform4f:n.uniform4f(e,o[0],o[1],o[2],o[3]);break;case f.uniform4fv:n.uniform4fv(e,o);break;case f.uniform4i:n.uniform4i(e,o[0],o[1],o[2],o[3]);break;case f.uniform4iv:n.uniform4iv(e,o);break;default:console.error("["+t+"]: unknown uniform type")}},n.genTextureInfoFromTensorShape=function(n,e){var t=n||4096,o=e.shape,r=void 0===o?[]:o,i=r[0],s=r[1],a=r[2],u=r[3];if(i*a<=t&&s*u<=t)e.shape_texture=[i*a,s*u];else{var l=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}(r).sort((function(n,e){return n-e})),f=l[0],h=l[1],p=l[2],d=f*l[3],g=h*p;if(d>t||g>t){var _=[d,g].sort((function(n,e){return n-e})),m=_[0],v=_[1],P=function(n,e){var t=e;if(n%t==0)return t;for(;t<n&&n%t!=0;)t++;return t}(v,Math.ceil(v/t));if(d=m*P,g=Math.ceil(v/P),c.get("debug")&&console.error("大小超限",r,[g,d]),d>t||g>t)throw new Error("Requested texture size ["+d+"x"+g+"] greater than WebGL maximum on this browser / GPU ["+t+"x"+t+"].")}e.shape_texture=[g,d]}},n.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"high-performance"},n.gl=null,n}();!function(n){n[n.GL_REPEAT=0]="GL_REPEAT",n[n.GL_MIRRORED_REPEAT=1]="GL_MIRRORED_REPEAT",n[n.GL_CLAMP_TO_EDGE=2]="GL_CLAMP_TO_EDGE"}(P||(P={}));var y=function(){function n(){}return n.getTextureConfig=function(n){var e,t,o,r,i,s,a,u,l=n,f=!0,h=!0;return 2===c.get("webglVersion")?(e=l.getExtension("EXT_color_buffer_float"),o=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,s=l.R16F,a=l.RGBA16F,t=l.RED,u=l.RGBA32F):(r=l.RGBA,s=l.RGBA,a=l.RGBA,i=l.RGBA,t=l.RGBA,u=l.RGBA,e=l.getExtension("OES_texture_float"),o=l.getExtension("OES_texture_half_float").HALF_FLOAT_OES,f=this.isDownloadFloatTextureEnabled(l,u),h=this.isFloatTextureReadPixelsEnabledMethod(l,1,f)),{textureFloat:e,textureHalfFloat:o,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,textureFormat:t,downloadInternalFormat:u,frameBufferSupportFloat:f,isFloatTextureReadPixelsEnabled:h}},n.isFloatTextureReadPixelsEnabledMethod=function(n,e,t){var o=n;if(0===e)return!1;if(1===e){if(null==o.getExtension("OES_texture_float"))return!1}else if(null==o.getExtension("EXT_color_buffer_float")||null==o.getExtension("EXT_color_buffer_half_float"))return!1;var r=o.createFramebuffer(),i=o.createTexture();o.bindTexture(o.TEXTURE_2D,i);var s=2===e?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,s,1,1,0,o.RGBA,t?o.FLOAT:o.getExtension("OES_texture_half_float").HALF_FLOAT_OES,null),o.bindFramebuffer(o.FRAMEBUFFER,r),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,i,0);var a=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;o.readPixels(0,0,1,1,o.RGBA,o.FLOAT,new Float32Array(4));var u=o.getError()===o.NO_ERROR;return a&&u},n.isDownloadFloatTextureEnabled=function(n,e){var t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e,1,1,0,n.RGBA,n.FLOAT,null);var o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);var r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),r},n.uploadDataToTexture=function(n,e,t,o){n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var r=t.width_texture,i=t.height_texture,s=t.data,a=n.RGBA,u=n.RGBA,l=n.FLOAT,f=s;if(s instanceof Uint8Array||s instanceof Uint8ClampedArray)l=n.UNSIGNED_BYTE;else{if(!(s instanceof Float32Array||s instanceof Array))return void n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,s);if(2===c.get("webglVersion")){var h=c.get("webgl_force_half_float_texture");a=o?h?e.internalFormatPackedHalfFloat:e.internalFormatPacked:h?e.internalFormatHalfFloat:e.internalFormat,u=o?n.RGBA:e.textureFormat}else{for(var p=new Float32Array(r*i*4),d=0;d<s.length;d++)o?p[d]=s[d]:(p[4*d]=s[d],p[4*d+1]=0,p[4*d+2]=0,p[4*d+3]=0);f=p}}n.texImage2D(n.TEXTURE_2D,0,a,r,i,0,u,l,f)},n.genOutputTexture=function(n,e,t,o){var r=t.interpType,i=t.width_texture,s=t.height_texture,a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var u=c.get("webgl_force_half_float_texture"),l=u?e.internalFormatPackedHalfFloat:e.internalFormatPacked,f=2===c.get("webglVersion")?u?n.HALF_FLOAT:n.FLOAT:e.frameBufferSupportFloat?n.FLOAT:e.textureHalfFloat,h=o?e.isFloatTextureReadPixelsEnabled?f:n.UNSIGNED_BYTE:null;return n.texImage2D(n.TEXTURE_2D,0,l,i,s,0,n.RGBA,o?h:f,null),n.bindTexture(n.TEXTURE_2D,null),a},n}(),F=["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ","#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],w=new Float32Array([-1,1,-1,-1,1,1,1,-1]),E=["length_shape","length_unformatted_shape","width_shape","height_shape","width_texture","height_texture","offset_x","offset_y","channel","total_shape","numbers_shape"],A={float:["multi_value","bias_value"],bool:["fuse_relu"]};function O(){return"\n    "+(c.get("useModAdaptor")?"\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        ":"\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ")+"\n    "+(c.get("useDivisionAdaptor")?"\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        ":"\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ")+"\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    "}const V="\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n";var C="\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",k="\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",S="\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",R="\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",I="\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",M="\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",L="\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",j="\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",D="\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",B="\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}",N="\nfloat exp_func(float x, float y, float z) {\n    float result = exp(x);\n    return result;\n}";function U(n,e){var t=e.width_shape,o=e.height_shape,r=e.channel,i=e.width_texture;return"\n    float getValueFromTensorPos_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+t*o*r+" + c * "+t*o+" + h * "+t+" + w;\n        // 0.01 hack: 在 PC/WISE 机器上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+i+")));\n        int pos_h = index / int("+i+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+i+"),\n                (float(pos_h) + 0.5) / float("+e.height_texture+")\n            )\n        );\n        return pixels.r;\n    }"}function G(n,e){var t=e.channel,o=e.height_shape,r=e.width_texture,i=e.height_texture,s=e.width_shape;return"\n    vec4 getValueFromTensorPosPacking_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+s*o*t+" + c * "+s*o+" + h * "+s+" + w;\n        // 0.01 hack: 在 PC/WISE 设备上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+r+")));\n        int pos_h = index / int("+r+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+r+"),\n                (float(pos_h) + 0.5) / float("+i+")\n            )\n        );\n        return pixels;\n    }"}function X(n,e){var t=e.numbers_shape,o=e.length_shape;if(1===o)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+t[0]+");\n            }\n        ";for(var r="ivec"+o+"("+t.join(", ")+")",i="pos[0] = n / "+t[0]+";",s=1;s<o;s++)i+="\n            n = calMod(n, "+t[s-1]+");\n            pos["+s+"] = calDivision(n, "+t[s]+");\n        ";return"\n    ivec"+o+" shapeVec_"+n+" = "+r+";\n    ivec"+o+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+o+" pos;\n        "+i+"\n        return pos;\n    }\n    "}function H(n){return"\n    #define getPixelsFromTexturePos_"+n+"(pos) TEXTURE2D(texture_"+n+", pos)\n    "}function W(n,e){return"\n    vec2 moveTexture2PosToReal_"+n+"(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float("+e.width_texture+");\n        v2.y = v.y * float("+e.height_texture+");\n        return v2;\n    }\n    "}function z(n){return"uniform sampler2D texture_"+n+";"}function Y(n,e,t,o,s){var a,u,l="",f=e.name,h=e.mainFunc,p=e.textureFuncConf,d=void 0===p?{}:p,g=e.commonFuncConf;try{var _=function(n,e,t){for(var o={},r=Object.assign({},e),i=[],s=0,a=n;s<a.length;s++){for(var u=a[s],l=u.name,c={},f=0,h=E;f<h.length;f++)void 0!==u[v=h[f]]&&(c[v]=u[v]);o[l]=c,i.push(l)}for(var p=0,d=Object.keys(A);p<d.length;p++)for(var g=d[p],_=0,m=A[g];_<m.length;_++){var v;void 0!==e[v=m[_]]&&(r[v]=g+"("+e[v]+")")}return e.active_function&&(r.active_function=e.active_function),r.runtime=t,{textureParams:o,opParams:r,active_function:e.active_function}}(t,o,s),m=_.textureParams,v=_.opParams,P=_.active_function,x=2===c.get("webglVersion")?" #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        ":" #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",b=function(n){var e=n.frameBufferSupportFloat,t=n.isFinalOp,o=n.isFloatTextureReadPixelsEnabled;return 2===c.get("webglVersion")?"\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        "+O()+"\n    ":e?"\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            "+O()+"\n    ":t&&!o?"\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        "+O()+"\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        ":"\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            "+O()+"\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        "}(n),T=function(n){var e="",t="";if(n.fuse_opt)for(var o in n.fuse_opt){var i=o,s=0,a=0;switch(o){case"scale":var u=n.fuse_opt.scale.bias_after_scale;s=void 0!==(c=n.fuse_opt.scale.scale)?c:1,a=n.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i="scaleWidthBias");break;case"relu":i="prelu";break;case"relu6":s=n.fuse_opt[o].threshold;break;case"hard_sigmoid":i="hardSigmoid",s=n.fuse_opt[o].slope||.2,a=n.fuse_opt[o].offset||.5;break;case"leakyRelu":s=n.fuse_opt[o].alpha;break;case"pow":i="pow_func",s=n.fuse_opt[o].factor||2;break;case"tanh":i="tanh_func";break;case"exp":i="exp_func"}if("hard_swish"===o){var l=void 0!==n.fuse_opt.hard_swish.offset?n.fuse_opt.hard_swish.offset:3,c=void 0!==n.fuse_opt.hard_swish.scale?n.fuse_opt.hard_swish.scale:6;t+="res = res * min(max(0.0, res + float("+l+")), float("+(void 0!==n.fuse_opt.hard_swish.threshold?n.fuse_opt.hard_swish.threshold:6)+")) / float("+c+");"}else"dropout"===o?t+="\n                if ("+("downgrade_in_infer"===n.fuse_opt.dropout.dropout_implementation)+") {\n                    res = res * (1.0 - float("+n.fuse_opt.dropout.dropout_prob+"));\n                }":(e+=r[i],t+="res = "+i+"(res, float("+s+"), float("+a+"));")}return"\n        "+e+"\n        \n        float fuse_op(float x) {\n            float res = x;\n            "+t+"\n            return res;\n        }\n    "}(v),y=function(n,e,t,o){if(!n)return"";var r=Object.assign({},n);r["@all"]&&function(n,e){var t=e.filter((function(n){return"out"!==n.name})),o=n["@all"];t.forEach((function(e){var t=e.name;n[t]?n[t].concat(o):n[t]=o})),delete n["@all"]}(r,o);for(var s="",a="",u=0,l=Object.keys(r);u<l.length;u++){var c=l[u];if(e[c]){a+=z(c);for(var f=0,h=r[c];f<h.length;f++){var p=h[f];if(i[p])try{s+=i[p](c,e[c],t)}catch(n){console.error(n)}}}}return"\n    "+a+"\n    "+s+"\n    "}(d,m,v,t),F=function(n){return void 0===n?"":"\n        int layer_run_time = "+n+";\n    "}(s),w=function(n){var e,t,o,r,i;return"\n        \n    vec2 _2d_shape_texture_out = vec2(float("+n.width_texture+"), float("+n.height_texture+"));\n    \n        "+(t=(e=n).height_shape,o=e.width_shape,"\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+e.width_texture+");\n\n        int n1 = int(index / "+(r=o*t*e.channel)+");\n        int c1 = int(calMod(index, "+r+") / "+(i=o*t)+");\n        int h1 = int(calMod(index, "+i+") / "+o+");\n        int w1 = calMod(index, "+o+");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ")}(m.out);a=l=" "+x+"\n            "+T+"\n            "+b+"\n            "+function(n){if(!n)return"";for(var e="",t=0,o=n;t<o.length;t++){var i=o[t];r[i]&&(e+=r[i])}return e}(g)+"\n            "+(P?r[P]:"")+"\n            "+y+"\n            "+F+"\n            "+w+"\n            "+h(m,v)+"\n        ",u=1===c.get("webglVersion")?"texture2D":"texture",l=a.replace(/\bTEXTURE2D\b/g,u)}catch(n){console.error("["+f+"]: "+n)}return l}const q=function(){function n(n,e,t,o){var r=n;this.vShader=e;try{this.fShader=this.initShader(r,t,"fragment"),this.shape=o&&o.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(n){throw new Error(n)}}return n.prototype.initShader=function(n,e,t){void 0===t&&(t="vertex");var o,r="vertex"===t?n.VERTEX_SHADER:n.FRAGMENT_SHADER;if("vertex"===t&&this.vShader)o=this.vShader;else if(o=n.createShader(r),"vertex"===t&&(this.vShader=o),n.shaderSource(o,e),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS))throw new Error("compile: "+n.getShaderInfoLog(o));return o},n.prototype.setProgram=function(n,e,t){n.useProgram(this.program),t||this.runVertexShader(n,e)},n.prototype.runVertexShader=function(n,e){var t=n.getAttribLocation(this.program,"position");n.enableVertexAttribArray(t),n.bindBuffer(n.ARRAY_BUFFER,e),n.vertexAttribPointer(t,2,n.FLOAT,!1,0,0)},n.Sampler="uSampler",n}();var Z,K=(Z=function(n,e){return(Z=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}Z(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),J=function(n,e,t,o){return new(t||(t=Promise))((function(r,i){function s(n){try{u(o.next(n))}catch(n){i(n)}}function a(n){try{u(o.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(s,a)}u((o=o.apply(n,e||[])).next())}))},Q=function(n,e){var t,o,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,o=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const $=function(n){function e(){var e=n.call(this)||this;return e.cacheTextures={},e.uniformLocations={},e.texturesMap={},e.queryList=[],e.currentTexture=null,e.width_shape_out=1,e.height_shape_out=1,e.width_texture_out=1,e.height_texture_out=1,e.channel=0,e.total_shape=0,e}return K(e,n),e.prototype.init=function(){return J(this,void 0,void 0,(function(){var n;return Q(this,(function(e){return n=this.gl=T.createWebGLRenderingContext(),this.gl?(this.glVersion=T.getWebglVersion(),this.textureConf=y.getTextureConfig(n),this.MAX_TEXTURE_SIZE=c.get("MAX_TEXTURE_SIZE")||n.getParameter(n.MAX_TEXTURE_SIZE),n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),this.vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,w,n.STATIC_DRAW),this.vShader=T.initShader(n,p.VS_SHADER,F[this.glVersion-1]),this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),this.pbo=n.createBuffer(),[2]):[2]}))}))},e.prototype.createProgram=function(n){var e=this,t=n.op,o=n.outTensor,r=n.inputTensors,i=n.shaderParams,s=n.runtime,a=n.isFinalOp,u=null;try{var l=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}([o],r);l.forEach((function(n){return T.genTextureInfoFromTensorShape(e.MAX_TEXTURE_SIZE,n)}));var c=Y(this.textureConf,t,l,i,s);(u=new q(this.gl,this.vShader,c,o)).fsCode=c;var f=y.genOutputTexture(this.gl,this.textureConf,o,a);this.texturesMap[o.tensorId]=f,this.program=u}catch(n){console.error("webgl createProgram: "+t.name+" -- "+n)}return u},e.prototype.runProgram=function(n,e){var t=this,o=function(n,e){if(2===e&&c.get("performance")){var t=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!t)return;var o=n.createQuery();return n.beginQuery(t.TIME_ELAPSED_EXT,o),o}return null}(this.gl,this.glVersion),r=n.isPackedOp;n.program.forEach((function(o,i){var s=n.outputTensors[i],a=s.tensorId;t.setOutProps(s),"frameBuffer"===n.bufferType?t.attachFrameBuffer(a):t.attachColorBuffer(),o.setProgram(t.gl,t.vertexBuffer,e),t.program=o,t.render(n,e,i,r)})),n.tensorData=null,o&&(this.queryList.push({name:n.name,query:o,count:1}),o=function(n,e,t){if(2===e&&c.get("performance")){var o=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!o)return;n.endQuery(o.TIME_ELAPSED_EXT)}return t}(this.gl,this.glVersion,o))},e.prototype.read=function(n){return J(this,void 0,void 0,(function(){var e,t,o;return Q(this,(function(r){switch(r.label){case 0:return c.get("webgl_gpu_pipeline")?(e=this.gl,this.frameBuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),[2,[]]):(t=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return r.sent(),o=n?n.shape:[],[2,this.downloadFloat32TensorFromBuffer(t,o)]}}))}))},e.prototype.createPBO=function(){var n,e=this.textureConf;if(2===this.glVersion){var t=this.gl,o=this.pbo;t.bindBuffer(t.PIXEL_PACK_BUFFER,o);var r=16*this.width_texture_out*this.height_texture_out;return t.bufferData(t.PIXEL_PACK_BUFFER,r,t.STREAM_READ),t.readPixels(0,0,this.width_texture_out,this.height_texture_out,t.RGBA,t.FLOAT,0),t.bindBuffer(t.PIXEL_PACK_BUFFER,null),o}var i=this.gl,s=i.FLOAT;return e.isFloatTextureReadPixelsEnabled?n=new Float32Array(this.width_texture_out*this.height_texture_out*4):(n=new Uint8Array(this.width_texture_out*this.height_texture_out*4),s=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,s,n),e.isFloatTextureReadPixelsEnabled?n:new Float32Array(n.buffer)},e.prototype.createAndWaitForFence=function(){return J(this,void 0,void 0,(function(){var n,e,t,o,r=this;return Q(this,(function(i){return n=this.gl,e=null!=n.fenceSync,t=function(){return!0},e&&(o=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0),n.flush(),t=function(){var e=n.clientWaitSync(o,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED}),[2,new Promise((function(n){r.pollItem(t,n)}))]}))}))},e.prototype.pollItem=function(n,e){var t=function(){n()?e():setTimeout(t,1)};t()},e.prototype.downloadFloat32TensorFromBuffer=function(n,e){var t=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var o=this.gl,r=new Float32Array(t);o.bindBuffer(o.PIXEL_PACK_BUFFER,n),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,r),o.bindBuffer(o.PIXEL_PACK_BUFFER,null);var i=[];if(c.get("webgl_pack_output"))return Array.from(r).slice(0,function(n){return n.reduce((function(n,e){return n*e}),1)}(e));for(var s=0;s<this.width_texture_out*this.height_texture_out;s++)i.push(r[4*s]);return i}var a=n,u=[];for(s=0;s<this.width_texture_out*this.height_texture_out;s++){var l=this.textureConf.isFloatTextureReadPixelsEnabled?4*s:s;u.push(a[l])}return u},e.prototype.setOutProps=function(n){var e=n.width_shape,t=void 0===e?1:e,o=n.height_shape,r=void 0===o?1:o,i=n.width_texture,s=void 0===i?1:i,a=n.height_texture,u=void 0===a?1:a,l=n.channel,c=void 0===l?0:l,f=n.total_shape,h=void 0===f?0:f;this.width_shape_out=t,this.height_shape_out=r,this.width_texture_out=s,this.height_texture_out=u,this.channel=c,this.total_shape=h},e.prototype.attachColorBuffer=function(){var n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.canvas.width=this.width_shape_out,n.canvas.height=this.height_shape_out,n.viewport(0,0,n.canvas.width,n.canvas.height),n.scissor(0,0,n.canvas.width,n.canvas.height)},e.prototype.attachFrameBuffer=function(n){this.currentTexture=this.texturesMap[n];var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.currentTexture,0),e.viewport(0,0,this.width_texture_out,this.height_texture_out),e.scissor(0,0,this.width_texture_out,this.height_texture_out)},e.prototype.render=function(n,e,t,o){var r=this;void 0===e&&(e=!1),void 0===o&&(o=!1);var i=n.inputTensors,s=void 0===i?[]:i,a=n.uniform,u=void 0===a?null:a,l=n.iLayer,c=void 0===l?0:l,f=n.modelName,h=this.gl,p=0;s.forEach((function(n){r.initTexture(p,n,o);var i=r.getUniformLoc("texture_"+n.name,c,e,t,f);i&&h.uniform1i(i,p++)})),u&&this.setUniform(u,c,e,t,f),h.drawArrays(h.TRIANGLE_STRIP,0,4)},e.prototype.initTexture=function(n,e,t){var o,r=this.gl,i=this.textureConf,s=e.tensorId,a=t||e.isPacked,u=e.data;if(e.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[s];l?(o=l,u&&T.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,e)):(o=r.createTexture(),this.cacheTextures[s]=o)}else o=this.texturesMap[s];r.activeTexture(r["TEXTURE"+n]),r.bindTexture(r.TEXTURE_2D,o),u&&(y.uploadDataToTexture(r,i,e,a),e.data=null)},e.prototype.setUniform=function(n,e,t,o,r){var i=this,s=Object.keys(n),a=this.gl;s.forEach((function(s){var u=n[s].type,l=n[s].value,c=i.getUniformLoc(s,e,t,o,r);T.setUniformParam(a,c,u,l)}))},e.prototype.getUniformLoc=function(n,e,t,o,r){var i=r+"_";if(t)return this.uniformLocations[i+e][n+o];var s=this.gl.getUniformLocation(this.program.program,n);return this.uniformLocations[i+e]=this.uniformLocations[i+e]||{},this.uniformLocations[i+e][n+o]=s,s},e.prototype.dispose=function(){},e}((function(){})),nn={mainFunc:function(n,e){var t=n.origin,o=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,c=e.paddings,f=void 0===c?[]:c,h=e.dilations,p=void 0===h?[]:h,d=e.fuse_relu,g=e.filter_nearest_vec4,_=e.filter_remainder_vec4,m=e.act_type,v=void 0===m?"":m,P=e.padding_algorithm,x=void 0===P?"":P,b=e.hard_swish_offset,T=void 0===b?3:b,y=e.hard_swish_scale,F=void 0===y?6:y,w=e.hard_swish_threshold,E=void 0===w?6:w,A=l[0],O=void 0===A?1:A,V=l[1],C=void 0===V?1:V,k=f[0],S=void 0===k?0:k,R=f[1],I=void 0===R?0:R,M=p[0],L=void 0===M?1:M,j=p[1],D=void 0===j?1:j;return"SAME"===x&&Math.ceil((t.width_shape-o.width_shape)/O)+1!==r.width_shape&&(S=1,I=1),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+a+")) * "+o.channel+";\n        int oy = y * "+O+" - "+S+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+L+";\n                continue;\n            }\n            int ox = x * "+C+" - "+I+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+D+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+g+"; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if ("+_+" == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox));\n                } else if ("+_+" == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if ("+_+" == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, "+g+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, "+g+" + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+g+" + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += "+D+";\n            }\n            oy += "+L+";\n        }\n\n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n\n        if ("+d+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===v)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        else if ("+("hard_swish"===v)+") {\n            res = res * min(\n                max(0.0, res + float("+T+")),\n                float("+E+")\n            ) / float("+F+");\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]};function en(n,e){var t=n[0],o=n[1],r=n[2],i=n[3];if(1===t&&1===o)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function tn(n,e,t){if(1===t)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var o=g(e);return o.push(1),"\n    ivec"+t+" shapeVec_"+n+" = ivec"+t+"("+o.join(", ")+");\n    ivec"+t+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+t+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+t+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function on(n){return 1===n?"int":"ivec"+n}function rn(n){var e=n.total_shape,t=n.channel,o=n.height_shape,r=n.width_shape;return[e/t/o/r,t,o,r]}const sn={mainFunc:function(n,e){var t=n.origin,o=e.transpose_X,r=void 0!==o&&o,i=e.transpose_Y,s=void 0!==i&&i,a=e.trans_x,u=void 0!==a&&a,l=e.trans_y,c=r||u,f=s||void 0!==l&&l;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if ("+c+") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if ("+f+") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < "+(c?t.height_shape:t.width_shape)+"; j++) {\n            if ("+c+") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if ("+f+") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}};function an(n,e){var t=n[0],o=n[1],r=n[2],i=n[3];if(1===t&&1===o)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function un(n,e,t){if(1===t)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var o=g(e);return o.push(1),"\n    ivec"+t+" shapeVec_"+n+" = ivec"+t+"("+o.join(", ")+");\n    ivec"+t+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+t+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+t+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function ln(n){return 1===n?"int":"ivec"+n}function cn(n){var e=n.total_shape,t=n.channel,o=n.height_shape,r=n.width_shape;return[e/t/o/r,t,o,r]}const fn={mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getTensorPosFromArrayIndex","getValueFromTensorPos"]}},hn={mainFunc:function(n,e){var t=n.out,o=n.origin,r=e.align_mode,i=void 0===r?1:r,s=e.align_corners,a=void 0===s||s;return"\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = "+i+" == 0 && !"+a+";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+a+") {\n            scale_x = float("+t.width_shape+" - 1) / float("+o.width_shape+" - 1);\n            scale_y = float("+t.height_shape+" - 1) / float("+o.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+t.width_shape+") / float("+o.width_shape+");\n            scale_y = float("+t.height_shape+") / float("+o.height_shape+");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, "+o.width_shape+");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, "+o.height_shape+");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},pn=hn;var dn={relu:["transToPrelu"],relu6:["transToRelu6"],leaky_relu:["transToLeakyrelu"],transToLeakyrelu:["transToLeakyrelu"],scale:["transToScale"],sigmoid:["transToSigmoid"],hard_sigmoid:["transToHardSigmoid"],pow:["transToPow"],exp:["transToExp"],sqrt:["transToSqrt"],tanh:["transToTanh"]};function gn(n,e){var t=e.multi_value,o=void 0===t?1:t,r=e.bias_value,i=void 0===r?0:r;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = "+e.active_function+"(o, float("+o+"), float("+i+"));\n        setOutput(res);\n    }\n    "}function _n(n){return{mainFunc:gn,textureFuncConf:{origin:["getPixelsFromTexturePos"]},behaviors:dn[n]}}const mn={mainFunc:function(n,e){var t=e.axes,o=Array.isArray(t)?t:[t],r=[0,1,2,3].filter((function(n){return n>=o.length}));return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+[0,1,2,3].map((function(n){return o.indexOf(n)>-1?0:"oPos["+r.splice(0,1)+"]"})).join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},vn={mainFunc:function(n,e){var t=n.origin,o=n.out,r=e.align_corners;return"\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+r+") {\n            scale_x = float("+o.width_shape+" -1) / float("+t.width_shape+" - 1);\n            scale_y = float("+o.height_shape+" - 1) / float("+t.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+o.width_shape+") / float("+t.width_shape+");\n            scale_y = float("+o.height_shape+") / float("+t.height_shape+");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, "+r+");\n        int vy = getData(float(oPos.b), scale_y, "+r+");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]};var Pn=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o};const xn={mainFunc:function(n,e){var t=n.origin,o=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.fixed_sizes,u=e.fixed_ratios,l=e.densities,c=e.flatten_to_2d,f=e.clip,h=e.step_w,p=void 0===h?0:h,d=e.step_h,m=void 0===d?0:d,v=e.offset,P=void 0===v?.5:v,x=e.runtime,b=void 0===x?0:x,T=o.height_shape,y=o.width_shape,F=t.height_shape,w=t.width_shape,E=r.total_shape,A=r.channel,O=r.height_shape,V=r.width_shape,C=E/A/O/V,k=g([C,A,O,V]),S=p,R=m;0!==p&&0!==m||(S=y/w,R=T/F);var I=Math.round(.5*(S+R)),M=u.map((function(n){return Math.sqrt(n)})),L=1===M.length?"sqrt_fixed_ratios":"sqrt_fixed_ratios[r]",j=u.length,D=O,B=C,N=A;c&&(B=F,N=w,D=O/F/w);var U=g([B,N,D,V]),G=X("out1",{numbers_shape:Pn(U,[1]),length_shape:4}),H=l.map((function(n){return n*n*j})),W=H.length,z=function(n){var e="ivec2 calRemain(int remain, int curAccIndex, int s) {",t=n.length;if(1===t)e+="\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";else for(var o=0;o<t;o++)e+="\n            int accIndex"+o+" = density_acc_shape["+o+"];\n\n            if (remain >= accIndex"+o+") {\n                s++;\n                remain -= accIndex"+o+";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";return e+"\n    }\n    "}(H),Y=f?"v = min(max(v, 0.), 1.);":"",q=1===W?"density_acc_shape":"density_acc_shape[0]",Z="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    "+G+"\n    \n        "+_(l,"densities")+"\n        "+_(a,"fixed_sizes")+"\n        "+_(M,"sqrt_fixed_ratios")+"\n        "+function(n,e){if(1===n.length)return"int "+e+" = int("+n[0]+");";for(var t=n.length,o="\n        ivec"+t+" "+e+" = ivec"+t+"(\n    ",r=0;r<t;r++)o+=n[r]+",";return o.slice(0,-1)+");"}(H,"density_acc_shape")+"\n    \n    "+z+"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * "+k[0]+" + gg * "+k[1]+" + bb * "+k[2]+" + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    ";return 1===b?"\n        "+_(s,"variances")+"\n        "+Z+"\n        setOutput(getFloat4TensorVal(variances, aa));\n        }":"\n            "+Z+"\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = "+q+";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat"+l.length+"TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float("+P+")) * float("+S+");\n            float center_y = (float(h) + float("+P+")) * float("+R+");\n            float fixed_size = getFloat"+a.length+"TensorVal(fixed_sizes, s);\n            float shift = float("+I+") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * "+L+";\n                float density_center_x = center_x - float("+I+") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float("+y+"), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float("+y+"), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / "+L+";\n                float density_center_y = center_y - float("+I+") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float("+T+"), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float("+T+"), 1.);\n                }\n            }\n\n            "+Y+"\n\n            setOutput(v);\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},bn={mainFunc:function(n,e){var t=n.origin,o=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.flip,u=e.clip,l=e.step_w,c=void 0===l?0:l,f=e.step_h,p=void 0===f?0:f,d=e.offset,g=void 0===d?.5:d,P=e.runtime,x=void 0===P?0:P,b=e.min_sizes,T=void 0===b?[]:b,y=e.max_sizes,F=void 0===y?[]:y,w=e.aspect_ratios,E=void 0===w?[]:w,A=e.min_max_aspect_ratios_order,O=void 0!==A&&A,V=o.height_shape,C=o.width_shape,k=t.height_shape,S=t.width_shape,R=r.channel,I=r.height_shape,M=c,L=p;0!==c&&0!==p||(M=C/S,L=V/k);var j=[1];E.forEach((function(n){1!==n&&(j.push(Math.sqrt(n)),a&&j.push(Math.sqrt(1/n)))}));var D=j.length,B="\n        "+m(T,"min_sizes",h.FLOAT_TYPE)+"\n        "+m(F,"max_sizes",h.FLOAT_TYPE)+"\n        "+m(j,"aspect_ratios",h.FLOAT_TYPE)+"\n    ",N=u?"res = min(max(res, 0.), 1.);":"",U="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    \n        "+v(T,"min_sizes",h.FLOAT_TYPE)+"\n        "+v(F,"max_sizes",h.FLOAT_TYPE)+"\n        "+v(j,"aspect_ratios",h.FLOAT_TYPE)+"\n    \n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        "+B+"\n\n    ";return 1===x?"\n            "+_(s,"variances")+"\n            "+U+"\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }":"\n            "+U+"\n            int idx = nn * "+R*I+" + cc * "+I+" + hh;\n            int as_num = "+D+";\n            float offset = "+g+";\n            \n            int feature_width = "+S+";\n            int num_priors = "+I+";\n            float step_width = float("+M+");\n            float step_height = float("+L+");\n\n            float im_width = float("+C+");\n            float im_height = float("+V+");\n\n            bool min_max_aspect_ratios_order = "+O+";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = calMod(idx / num_priors, feature_width);\n            int p = calMod(idx, num_priors);\n            int m = "+(F.length>0)+" ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = getValueFromArrByIndex_min_sizes(min_sizes, m);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            "+(F.length>0?"\n            int s = calMod(p, as_num + 1);\n            if ("+!O+") {\n                if (s < as_num) {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s - 1);\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }":"\n            int s = calMod(p, as_num);\n            float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ")+"\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            "+N+"\n\n            setOutput(float(res));\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:[]},Tn={mainFunc:function(n,e){for(var t=n.out,o=function(n,e){var t={};for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&e.indexOf(o)<0&&(t[o]=n[o]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(n);r<o.length;r++)e.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(n,o[r])&&(t[o[r]]=n[o[r]])}return t}(n,["out"]),r=o.origin,i=r.width_shape,s=r.height_shape,a=r.channel,u=r.total_shape,l=r.length_unformatted_shape,c=[u/(i*s*a),a,s,i].slice(4-l),f=Object.keys(o).length,h=e.axis<0?e.axis+c.length+1:e.axis,p=1,d=1,g=0;g<h;g++)p*=c[g];for(g=h;g<c.length;g++)d*=c[g];var _=t.total_shape/p,m="";return m=Array.from(Array(f).keys()).reduce((function(n,e){return n+(0===e?"\n            if (i == 0) {\n                ivec4 co = getTensorPosFromArrayIndex_origin(j);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (i == "+e+") {\n                ivec4 co = getTensorPosFromArrayIndex_origin_"+e+"(j);\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }")}),m),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n\n        int index = calMod(sumVal, "+_+");\n\n        int layer = sumVal / "+_+";\n\n        int i = index / "+d+";\n        int j = calMod(index, "+d+") + layer * "+d+";\n\n        float o = 0.0;\n        "+m+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},yn={mainFunc:function(n,e){var t=n.out,o=n.origin,r=e.axes,i=e.starts,s=e.ends,a=e.decrease_axis;if(r.length>1||i.length>1||s.length>1||a&&0===a.length)throw Error("[slice op feature]: current support one dim, support decrease_axis");var u=o.width_shape,l=o.height_shape,c=o.channel,f=o.total_shape,p=o.length_unformatted_shape,d=[f/(u*l*c),c,l,u],g=r[0];if(g<0&&(g=g+p+1),4!==(g=4-p+g))throw Error("[slice op feature]: unsupport axis value");for(var _=i[0],P=s[0],x=d[0],b=d[1],T=d[2],y=d[3],F=[],w=_;w<P;w++)for(var E=0;E<x;E++)for(var A=0;A<b;A++)for(var O=0;O<T;O++)F.push(E*b*T*y+A*T*y+O*y+w);var V=m(F,"arr",h.INT_TYPE);return"\n    "+v(F,"arr",h.INT_TYPE)+"\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        "+V+"\n\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n\n        int index = getValueFromArrByIndex_arr(arr, sumVal);\n\n        float res = 0.0;\n        ivec4 co = getTensorPosFromArrayIndex_origin(index);\n        res = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}};var Fn={arg_max:{mainFunc:function(n,e){var t=n.origin,o=e.axis,r=void 0===o?-1:o,i=e.flatten,s=t.total_shape,a=t.height_shape,u=t.width_shape,l=t.channel,c=t.length_unformatted_shape,f=s/(u*a*l),h=r<0?3:4-c+r,p=[f,l,a,u][h];return"\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+h+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+p+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+f+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},arg_min:{mainFunc:function(n,e){for(var t=n.origin,o=e.axis,r=void 0===o?-1:o,i=e.flatten,s=t.total_shape,a=t.height_shape,u=t.width_shape,l=t.channel,c=s/(u*a*l),f=[c,l,a,u],h=0,p=0;p<4&&!(f[p]>1);p++)h++;var d=r<0?4-h+r:r,g=f[d=h+d];return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+d+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+d+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+d+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+c+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},conv2d:nn,conv2d_packing:{mainFunc:function(n,e){var t=n.origin,o=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,c=e.paddings,f=void 0===c?[]:c,h=e.dilations,p=void 0===h?[]:h,d=e.fuse_relu,g=e.act_type,_=e.hard_swish_offset,m=void 0===_?3:_,v=e.hard_swish_scale,P=void 0===v?6:v,x=e.hard_swish_threshold,b=void 0===x?6:x,T=l[0],y=void 0===T?1:T,F=l[1],w=void 0===F?1:F,E=f[0],A=void 0===E?0:E,O=f[1],V=void 0===O?0:O,C=p[0],k=void 0===C?1:C,S=p[1],R=void 0===S?1:S;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * "+y+" - "+A+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+k+";\n                continue;\n            }\n            int ox = x * "+w+" - "+V+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+R+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+o.channel+"; j += 1) {\n                    int c0 = (c / ("+r.channel+" * 4 / "+a+")) * "+o.channel+" + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / ("+r.channel+" * 4 / "+a+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / ("+r.channel+" * 4 / "+a+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / ("+r.channel+" * 4 / "+a+")) * "+o.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += "+R+";\n            }\n            oy += "+k+";\n        }\n\n        "+(i?"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);":"")+"\n\n        if ("+d+") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if ("+("relu6"===g)+") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        else if ("+("hard_swish"===g)+") {\n            res = res * min(\n                max(vec4(0.0, 0.0, 0.0, 0.0), res + vec4("+m+")),\n                vec4("+b+")\n            ) / vec4("+P+");\n        }\n\n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPosPacking"],origin:["getValueFromTensorPosPacking"],bias:["getValueFromTensorPosPacking"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},conv2d_transpose:{mainFunc:function(n,e){var t=n.origin,o=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,c=e.paddings,f=void 0===c?[]:c,h=e.dilations,p=void 0===h?[]:h,d=e.fuse_relu,g=e.act_type,_=l[0],m=void 0===_?1:_,v=l[1],P=void 0===v?1:v,x=f[0],b=void 0===x?0:x,T=f[1],y=void 0===T?0:T;y=o.height_shape-y-1,b=o.width_shape-b-1;var F=p[0],w=void 0===F?1:F,E=p[1],A=void 0===E?1:E;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * "+a+" / "+r.channel+") * "+t.channel+";\n        int oy = y - "+y+";\n        const int groupLen = int("+t.channel+" / "+a+");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy < 0) {\n                oy += "+w+";\n                continue;\n            }\n            int ox = x - "+b+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n\n                if (ox < 0) {\n                    ox += "+A+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int("+P+")) == 0 && calMod(oy, int("+m+")) == 0) {\n                        temp_x = int(floor(float(ox) / float("+P+")));\n                        temp_y = int(floor(float(oy) / float("+m+")));\n                        if (temp_x < "+t.width_shape+" && temp_y < "+t.height_shape+") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / "+a+"),\n                                "+o.height_shape+"-1-fy,\n                                "+o.width_shape+"-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += "+A+";\n            }\n            oy += "+w+";\n        }\n        \n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n        \n        if ("+d+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===g)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        \n        setOutput(float(res));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},depthwise_conv2d:nn,conv2d_depthwise:nn,conv2d_elementwise_add:{mainFunc:function(n,e){var t=n.origin,o=n.filter,r=n.out,i=n.counter,s=e.active_function,a=e.groups,u=void 0===a?1:a,l=e.axis,c=e.strides,f=void 0===c?[]:c,h=e.paddings,p=void 0===h?[]:h,d=e.dilations,g=void 0===d?[]:d,_=e.multi_value,m=e.bias_value,v=f[0],P=void 0===v?1:v,x=f[1],b=void 0===x?1:x,T=p[0],y=void 0===T?0:T,F=p[1],w=void 0===F?0:F,E=g[0],A=void 0===E?1:E,O=g[1],V=void 0===O?1:O;return"\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float("+i.width_shape+");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos["+l+"];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+u+")) * "+o.channel+";\n        int oy = y * "+P+" - "+y+";\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+A+";\n                continue;\n            }\n            int ox = x * "+b+" - "+w+";\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+V+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+o.channel+"; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += "+V+";\n            }\n            oy += "+A+";\n        }\n        setOutput("+s+"(res,  "+_+",  "+m+"));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]},behaviors:["mergeAttrs","checkIsMerge","setActiveFunc"]},pool2d:{mainFunc:function(n,e){var t=n.origin,o=e.strides,r=void 0===o?[]:o,i=e.paddings,s=void 0===i?[]:i,a=e.pooling_type,u=e.ksize,l=r[0],c=void 0===l?1:l,f=r[1],h=void 0===f?1:f,p=s[0],d=void 0===p?0:p,g=s[1],_=void 0===g?0:g,m=u[0],v=u[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if ("+a+" == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+h+" - "+_+";\n        for (int fy = 0; fy < "+m+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+v+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+a+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+a+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_max:{mainFunc:function(n,e){var t=n.origin,o=e.strides,r=void 0===o?[]:o,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=e.global_pooling,l=e.runtime,c=r[0],f=void 0===c?1:c,h=r[1],p=void 0===h?1:h,d=s[0],g=void 0===d?0:d,_=s[1],m=void 0===_?0:_,v=a[0],P=a[1],x=function(n){var e=n.total_shape,t=n.channel,o=n.height_shape,r=n.width_shape;return[e/t/o/r,t,o,r]}(t),b="",T="setOutput(float(res));";return 0===l&&!0===u&&(b="\n            if (curr > res) {\n                index = "+x[2]*x[3]+" * out_pos[1] + "+x[3]+" * oy + ox;\n            }\n        ",T="setOutput(float(index));"),"\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+f+" - "+g+";\n        int ox_base = out_pos[3] * "+p+" - "+m+";\n        for (int fy = 0; fy < "+v+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+P+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                "+b+"\n                res = max(res, curr);\n            }\n        }\n        "+T+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_winograd:{mainFunc:function(n,e){var t=n.origin,o=n.pool,r=e.strides,i=void 0===r?[]:r,s=e.paddings,a=void 0===s?[]:s,u=e.type_pool,l=i[0],c=void 0===l?1:l,f=i[1],h=void 0===f?1:f,p=a[0],d=void 0===p?0:p,g=a[1],_=void 0===g?0:g,m=t.height_shape,v=t.width_texture,P=t.height_texture;return"\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = "+m+" + "+t.offset_y+";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float("+v+"),\n            (float(g * height / 2 + y) + 0.5) / float("+P+"))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+h+" - "+_+";\n\n        for (int fy = 0; fy < "+o.height_shape+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+o.width_shape+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+u+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+u+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},elementwise_add:{mainFunc:function(n,e){var t=e.counterPos,o=e.Scale_y,r=void 0===o?1:o,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+u/r+") * c + float("+u/s+") * o;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_mul:{mainFunc:function(n,e){var t=n.counter,o=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+t.height_texture/t.height_shape+") {\n            newN = int("+t.height_texture/t.height_shape+");\n        }\n        if (c >= "+t.channel+") {\n            newC = int("+(t.channel-1)+");\n        }\n        if (h >= "+t.height_shape+") {\n            newH = "+(t.height_shape-1)+";\n        }\n        if (w >= "+t.width_shape+") {\n            newW = "+(t.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+l/a+") * o * float("+1/i+") * c;\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_div:{mainFunc:function(n,e){var t=n.counter,o=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+t.height_texture/t.height_shape+") {\n            newN = int("+t.height_texture/t.height_shape+");\n        }\n        if (c >= "+t.channel+") {\n            newC = int("+(t.channel-1)+");\n        }\n        if (h >= "+t.height_shape+") {\n            newH = "+(t.height_shape-1)+";\n        }\n        if (w >= "+t.width_shape+") {\n            newW = "+(t.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+l+") * (float("+1/a+") * o / (float("+1/i+") * c));\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_pow:{mainFunc:function(n,e){var t=e.counterPos,o=e.Scale_y,r=void 0===o?1:o,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = pow(float("+u/s+") * o, float("+u/r+") * c);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_sub:{mainFunc:function(n,e){var t=e.counterPos,o=e.Scale_y,r=void 0===o?1:o,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+u/s+") * o - float("+u/r+") * c;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},mul:{mainFunc:function(n,e){var t=n.origin,o=n.counter,r=e.x_num_col_dims,i=e.y_num_col_dims,s=rn(t),a=rn(o),u=en(s,r),l=u[0],c=u[1],f=u[2],h=u[3],p=u[4],d=en(a,i),g=d[0],_=d[1],m=d[2],v=d[3];return"\n    "+tn("x1",l,c)+"\n    "+tn("x2",f,h)+"\n    "+tn("y1",g,_)+"\n    "+tn("y2",m,v)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+on(c)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+on(v)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+p[1]+"; j++) {\n            "+on(h)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+on(_)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+on(c)+"(x1), "+on(h)+"(x2));\n            ivec4 yPos = ivec4("+on(_)+"(y1), "+on(v)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},matmul:sn,matmul_v2:sn,fc:{mainFunc:function(n,e){var t=n.origin,o=n.weight,r=e.x_num_col_dims,i=e.y_num_col_dims,s=cn(t),a=cn(o),u=an(s,r),l=u[0],c=u[1],f=u[2],h=u[3],p=u[4],d=an(a,i),g=d[0],_=d[1],m=d[2],v=d[3];return"\n    "+un("x1",l,c)+"\n    "+un("x2",f,h)+"\n    "+un("y1",g,_)+"\n    "+un("y2",m,v)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+ln(c)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+ln(v)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+p[1]+"; j++) {\n            "+ln(h)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+ln(_)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+ln(c)+"(x1), "+ln(h)+"(x2));\n            ivec4 yPos = ivec4("+ln(_)+"(y1), "+ln(v)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    "},textureFuncConf:{weight:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]}},dropout:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if ("+("downgrade_in_infer"===e.dropout_implementation)+") {\n            o = o * (1.0 - float("+e.dropout_prob+"));\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},concat:{mainFunc:function(n,e){var t=e.dim,o=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,o=n.height_shape,r=n.channel;return[n.total_shape/(e*o*r),r,o,e][t]})),r=o.map((function(n,e){return o.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+t+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            ":"\n            else if (oPos["+t+"] < "+n+") {\n                oPos["+t+"] = oPos["+t+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},concat_mul:{mainFunc:function(n,e){var t=e.dim,o=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,o=n.height_shape,r=n.channel;return[n.total_shape/(e*o*r),r,o,e][t]})),r=o.map((function(n,e){return o.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+t+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }":"\n            else if (oPos["+t+"] < "+n+") {\n                oPos["+t+"] = oPos["+t+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},split:{mainFunc:function(n,e){var t=e.target_length,o=e.num,r=e.dim,i=e.sections;return"\n    // start函数\n    void main(void) {\n        int length = int("+(i&&i.length>1?i[0]:t/o)+");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos["+r+"] = oPos["+r+"] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},softmax:{mainFunc:function(n,e){var t=n.origin,o=e.axis,r=o;return(!o||o<0)&&(r=(o||-1)+4),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int("+t.total_shape+"/"+t.channel+"/"+t.height_shape+"/"+t.width_shape+");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if ("+r+" == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if ("+r+" == 1) {\n            for (int i = 0; i < "+t.channel+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < "+t.width_shape+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},batchnorm:{mainFunc:function(n,e){var t=n.bias,o=n.scale,r=n.mean,i=n.variance,s=e.epsilon;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float("+o.width_texture+") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float("+t.width_texture+") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float("+r.width_texture+")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float("+i.width_texture+") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + "+s+");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],scale:["getPixelsFromTexturePos"],bias:["getPixelsFromTexturePos"],mean:["getPixelsFromTexturePos"],variance:["getPixelsFromTexturePos"]}},reshape:fn,reshape2:fn,bilinear_interp:hn,transpose2:{mainFunc:function(n,e){var t=e.perm_arr,o=e.perm_size,r=t[0],i=t[1],s=t[2];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if ("+o+" == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if ("+o+" == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + "+r+") > 3 ? 3 : (2 + "+r+")],\n                oPos[(2 + "+i+") > 3 ? 3 : (2 + "+i+")]\n            );\n        }\n        else if ("+o+" == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + "+r+") > 3 ? 3 : (1 + "+r+")],\n                oPos[(1 + "+i+") > 3 ? 3 : (1 + "+i+")],\n                oPos[(1 + "+s+") > 3 ? 3 : (1 + "+s+")]\n            );\n        }\n        else if ("+o+" == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos["+r+"],\n                oPos["+i+"],\n                oPos["+s+"],\n                oPos["+t[3]+"]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizePerm"]},unpacked_2_packed:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},packed_2_unpacked:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},unsqueeze2:{mainFunc:function(n,e){var t=n.origin,o=e.axes,r=t.length_unformatted_shape,i=Array.isArray(o)?o:[o],s=4-r-i.length,a=i.map((function(n){return n+s})),u=[0,1,2,3].filter((function(n){return-1===a.indexOf(n)})).map((function(n){return"oPos["+n+"]"})),l=Array.from(new Array(a.length),(function(){return"0"}));return u.splice.apply(u,function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var o=Array(n),r=0;for(e=0;e<t;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)o[r]=i[s];return o}([0,0],l)),"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+u.join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},flatten_contiguous_range:{mainFunc:function(n,e){var t=n.origin,o=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+t.channel+",\n            "+t.width_shape+",\n            "+t.height_shape+",\n            "+t.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},flatten2:fn,greater_than:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},reduce_sum:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+e.inputs_dim+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},where:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"],condition:["getValueFromTensorPos"]}},connect:{mainFunc:function(n,e){var t=n.out,o=t.total_shape,r=t.width_shape,i=t.height_shape,s=t.channel,a=g([o/(r*i*s),s,i,r]),u=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e].total_shape})),l=u.map((function(n,e){return u.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),c="";return l.forEach((function(n,e){c+=0===e?"\n            if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin_"+e+"(sumVal - "+l[e-1]+");\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * "+a[2]+" + oPos.a;\n        "+c+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},reduce_mean:{mainFunc:function(n,e){var t=e.inputs_dim;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+t+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float("+t+");\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},hard_swish:{mainFunc:function(n,e){var t=e.offset,o=void 0===t?3:t,r=e.scale,i=void 0===r?6:r,s=e.threshold;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float("+o+")), float("+(void 0===s?6:s)+")) / float("+i+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},nearest_interp:vn,nearest_interp_v2:vn,cast:{mainFunc:function(n,e){var t="";switch(e.out_dtype){case 0:t="\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);";break;case 1:case 2:case 3:t="\n            int res_int = int(o);\n            setOutput(float(res_int));";break;default:t="       \n            float res_float = o;\n            setOutput(res_float);"}return"\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        "+t+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},fill_constant_batch_size_like:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        float res = float("+e.value+");\n        setOutput(res);\n    }\n"}},rnn_matmul:{mainFunc:function(n,e){var t=n.weightlist_0,o=e.input_axis,r=e.state_axis,i=e.batch,s=e.reverse,a=void 0!==s&&s?i-o-1:o;return"\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if ("+(0===o)+") {\n            res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n        for (int j = 0; j < "+t.width_shape+"; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], "+r+", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"]}},rnn_hidden:{mainFunc:function(n,e){var t=e.state_axis,o=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+o+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*o+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*o+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+t+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_cell:{mainFunc:function(n,e){var t=e.state_axis,o=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+o+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*o+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*o+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+t+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_origin:{mainFunc:function(n,e){var t=n.weightlist_0,o=n.weightlist_1,r=e.state_axis;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < "+t.width_shape+"; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < "+o.width_shape+"; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, "+r+", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"],weightlist_1:["getValueFromTensorPos"],weightlist_2:["getValueFromTensorPos"],weightlist_3:["getValueFromTensorPos"]}},pool2d_avg:{mainFunc:function(n,e){var t=n.origin,o=e.strides,r=void 0===o?[]:o,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=r[0],l=void 0===u?1:u,c=r[1],f=void 0===c?1:c,h=s[0],p=void 0===h?0:h,d=s[1],g=void 0===d?0:d,_=a[0],m=a[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+l+" - "+p+";\n        int ox_base = out_pos[3] * "+f+" - "+g+";\n        for (int fy = 0; fy < "+_+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+t.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+m+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+t.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float("+_+" * "+m+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["setPacked","setAdaptive","isGlobalPooling"]},prelu:_n("prelu"),relu6:_n("relu6"),leakyRelu:_n("leakyRelu"),scale:_n("scale"),sigmoid:_n("sigmoid"),relu:_n("relu"),hard_sigmoid:_n("hard_sigmoid"),pow:_n("pow"),sqrt:_n("sqrt"),tanh:_n("tanh"),exp:_n("exp"),squeeze2:mn,pad3d:{mainFunc:function(n,e){var t=n.origin,o=e.paddings,r=e.mode,i=e.value,s=function(n){var e=n.total_shape,t=n.channel,o=n.height_shape,r=n.width_shape;return[e/t/o/r,t,o,r]}(t),a={reflect:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = "+o[0]+" - oPos.a;\n            }\n            else if (oPos.a - "+o[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - (oPos.a - "+o[0]+" - "+s[3]+" + 1) - 1;\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = "+o[2]+" - oPos.b;\n            }\n            else if (oPos.b - "+o[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - (oPos.b - "+o[2]+" - "+s[2]+" + 1) - 1;\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",replicate:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = 0;\n            }\n            else if (oPos.a - "+o[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - 1;\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = 0;\n            }\n            else if (oPos.b - "+o[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - 1;\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",circular:"\n            int a;\n            int b;\n            if (oPos.a - "+o[0]+" < 0) {\n                a = int(mod(float("+o[0]+" + oPos.a - 1), float("+s[3]+")));\n            }\n            else if (oPos.a - "+o[0]+" >= "+s[3]+") {\n                a = int(mod(float(oPos.a - "+o[0]+" - "+s[3]+"), float("+s[3]+")));\n            }\n            else {\n                a = oPos.a - "+o[0]+";\n            }\n            if (oPos.b - "+o[2]+" < 0) {\n                b = int(mod(float("+o[2]+" + oPos.b - 1), float("+s[2]+")));\n            }\n            else if (oPos.b - "+o[2]+" >= "+s[2]+") {\n                b = int(mod(float(oPos.b - "+o[2]+" - "+s[2]+"), float("+s[2]+")));\n            }\n            else {\n                b = oPos.b - "+o[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",constant:"",undefined:""};return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = "+(i||"0.0")+";\n        if (oPos.a - "+o[0]+" >= 0\n            && oPos.b - "+o[2]+" >= 0\n            && oPos.a - "+o[0]+" < "+s[3]+"\n            && oPos.b - "+o[2]+" < "+s[2]+"\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - "+o[2]+", oPos.a - "+o[0]+");\n        }\n        else {\n            "+a[r]+"\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},bilinear_interp_v2:pn,shuffle_channel:{mainFunc:function(n,e){var t=n.out,o=e.group,r=void 0===o?2:o,i=t.total_shape,s=t.height_shape,a=t.width_shape,u=t.channel,l=[1,0,2,3];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * "+a+"\n            + oPos.g * "+s+" * "+a+"\n            + oPos.r * "+u+" * "+a+" * "+s+";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+r+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos["+l[0]+"],\n            transpose_out_pos["+l[1]+"], transpose_out_pos["+l[2]+"], transpose_out_pos["+l[3]+"]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * "+a+"\n            + transpose_in_pos.g * "+s+" * "+a+"\n            + transpose_in_pos.r * "+u/r+" * "+a+" * "+s+";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            "+u+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},pack_out:{mainFunc:function(n,e){return"\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},nhwc_2_nchw:{mainFunc:function(n,e){var t=n.origin,o=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * "+o.channel+"\n            + oPos.b * "+o.width_shape+" * "+o.channel+"\n            + oPos.g\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+t.channel+",\n            "+t.width_shape+",\n            "+t.height_shape+",\n            "+t.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},feedPost:{mainFunc:function(n,e){var t=n.out,o=e.mean,r=void 0===o?[0,0,0]:o,i=e.std,s=void 0===i?[1,1,1]:i,a=t.total_shape,u=t.height_shape,l=t.width_shape,c=t.channel;return"\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * "+l+"\n            + nhwcPos.g * "+u+" * "+l+"\n            + nhwcPos.r * "+c+" * "+l+" * "+u+";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+c+",\n            "+l+",\n            "+u+",\n            "+a+"\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float("+r[0]+")) / float("+s[0]+");\n        } else if (c == 1) {\n            res = (res - float("+r[1]+")) / float("+s[1]+");\n        } else if (c == 2) {\n            res = (res - float("+r[2]+")) / float("+s[2]+");\n        }\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]},commonFuncConf:["transferFromNHWCtoNCHW"]},imgFeed:{mainFunc:function(){return"\n    uniform vec2 u_scale;\n    uniform int u_keep_ratio;\n\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        // 支持模型不按比例拉伸\n        if (u_keep_ratio == 0) {\n            vec4 origin = TEXTURE2D(texture_origin, outCoord);\n            setPackedOutput(origin);\n            return;\n        }\n        float startX = (1.0 - u_scale.x) / 2.0;\n        float endX = startX + u_scale.x;\n        float startY = (1.0 - u_scale.y) / 2.0;\n        float endY = startY + u_scale.y;\n\n        if (outCoord.x >= startX && outCoord.x <= endX && outCoord.y >= startY && outCoord.y <= endY) {\n            vec2 newPos = (outCoord - vec2(startX, startY)) / u_scale;\n            vec4 origin = TEXTURE2D(texture_origin, newPos);\n            setPackedOutput(origin);\n        }\n        else {\n            setPackedOutput(vec4(1.0));\n        }\n    }\n    "},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(n,e){var t="decode_center_size"===e.code_type;return"\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        "+(t?"\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        ":"\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ")+"\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == "+(t?2:1)+") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        "+(t?"\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        ":"\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ")+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{targetbox:["getValueFromTensorPos"],priorbox:["getValueFromTensorPos"],priorboxvar:["getValueFromTensorPos"]},behaviors:[]},density_prior_box:xn,prior_box:bn,stack:Tn,slice:yn},wn=new $;!function(n,e,t){u.backend=n,e&&(u.backendInstance=e),t&&Object.keys(t).forEach((function(n){!function(n,e){var t=n.conf,o=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,l=n.behaviors,c=void 0===l?[]:l,f=u.backend+"_"+e;u.opRegistry.ops[f]||(u.opRegistry.ops[f]={name:e,conf:t,params:o,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:c})}(t[n],n)}))}("webgl",wn,Fn)}},e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={exports:{}};return n[o](r,r.exports,t),r.exports}return t.d=(n,e)=>{for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t(400)})()},,function(n,e,t){n.exports=t(4)},function(n,e,t){"use strict";t.r(e),t.d(e,"swapModel",(function(){return m})),t.d(e,"load",(function(){return v})),t.d(e,"preheat",(function(){return P})),t.d(e,"drawHumanSeg",(function(){return x})),t.d(e,"blurBackground",(function(){return b})),t.d(e,"drawMask",(function(){return T}));var o=t(0),r=t(1);var i,s={mainFunc:function(n){var e=n.out;return"\n\n    #define SIGMA SIGMA 3.0\n    #define BLUR_MSIZE 8\n    #define MSIZE 3\n    #define kernelSize 5.0\n    #define weight 1.0\n\n    uniform int type; // 0: blurBackground 1: drawHumanseg 2: drawMask\n\n    void main() {\n        vec2 outCoord = vCoord.xy;\n       \n        outCoord.y = 1.0 - vCoord.y;\n\n        vec2 sourceTextureSize = vec2("+e.width_shape+", "+e.height_shape+");\n        vec2 sourceTexelSize = 1.0 / sourceTextureSize;\n\n        float kernel[MSIZE]; // 3\n        kernel[0] = 0.12579369017522166;\n        kernel[1] = 0.13298;\n        kernel[2] = 0.12579369017522166;\n\n        float origin_alpha = 1.0 - TEXTURE2D(texture_origin, vec2(outCoord.x, outCoord.y) / 2.0).r;\n        vec4 counter = TEXTURE2D(texture_counter, outCoord.xy);\n        vec4 res = vec4(0.0);\n\n        if (type == 0) {\n            // Simple Cheap Box Blur \n            float pixelSizeX = 1.0 / float("+e.width_shape+");\n            float pixelSizeY = 1.0 / float("+e.height_shape+"); \n    \n            // Horizontal Blur\n            vec4 accumulation = vec4(0);\n            float weightsum = 0.0;\n            for (float i = -kernelSize; i <= kernelSize; i++){\n                accumulation += TEXTURE2D(texture_counter, outCoord.xy + vec2(i * pixelSizeX, 0.0)) * weight;\n                weightsum += weight;\n            }\n            // Vertical Blur\n            for (float i = -kernelSize; i <= kernelSize; i++){\n                accumulation += TEXTURE2D(texture_counter, outCoord.xy + vec2(0.0, i * pixelSizeY)) * weight;\n                weightsum += weight;\n            }\n            \n            res = accumulation / weightsum;\n            if (origin_alpha > 0.2) {\n                res = counter;\n            }\n        }\n        else if (type == 1) {\n            res = counter;\n            res.a = origin_alpha;\n        }\n        else if (type == 2) {\n            if (origin_alpha > 0.2) {\n                res = vec4(1.0);\n                res.a = origin_alpha;\n            }\n        }\n                \n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{origin:[],counter:[]}},a=(i=function(n,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}i(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),u=function(n){function e(e,t){var o=n.call(this,"DealOrigin")||this;return o.width=e||500,o.height=t||280,o}return a(e,n),e.prototype.transform=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];if(o.env.get("webgl_gpu_pipeline")){var t=n[0],r=n[1],i=t.find((function(n){return"fetch"===n.type})),s=i.inputs.X[0],a={attrs:{},inputs:{X:[s],Y:["image"]},outputs:{Out:["fetch_pack"]},type:"segImg",isPacked:!0,bufferType:o.interfaces.BufferType.ColorBuffer,uniform:{type:{type:"1i",value:0}}},u={name:"fetch_pack",shape:[1,1,this.height,this.width],persistable:!1};i.inputs.X=["fetch_pack"],t.push(a),r instanceof Array?r.push.apply(r,[u]):r.fetch_pack=u}},e}(o.Transformer),l=function(n,e,t,o){return new(t||(t=Promise))((function(r,i){function s(n){try{u(o.next(n))}catch(n){i(n)}}function a(n){try{u(o.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(s,a)}u((o=o.apply(n,e||[])).next())}))},c=function(n,e){var t,o,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,o&&(r=2&i[0]?o.return:i[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,i[1])).done)return r;switch(o=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,o=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!(r=s.trys,(r=r.length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],o=0}finally{t=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}},f=null;Object(o.registerOp)(s,"segImg");var h=Object.assign({},r.GLHelper.WEBGL_ATTRIBUTES,{alpha:!0});function p(n){var e=n.getContext("webgl2",h);return e?o.env.set("webglVersion",2):(o.env.set("webglVersion",1),e=n.getContext("webgl",h)||n.getContext("experimental-webgl",h)),e}var d=document.createElement("canvas");d.width=500,d.height=280;var g=p(d),_=null;function m(n){return void 0===n&&(n={needPreheat:!0,modelType:"large",canvasWidth:500,canvasHeight:280}),l(this,void 0,void 0,(function(){return c(this,(function(e){switch(e.label){case 0:return f.stopPredict(),f=null,_=null,d.remove(),(d=document.createElement("canvas")).width=500,d.height=280,g=p(d),[4,v(n)];case 1:return e.sent(),[2]}}))}))}function v(n){return void 0===n&&(n={needPreheat:!0,modelType:"large",canvasWidth:500,canvasHeight:280}),l(this,void 0,void 0,(function(){var e;return c(this,(function(t){switch(t.label){case 0:return"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_398x224_fuse_activation/model.json","https://paddlejs.cdn.bcebos.com/models/humansegv2/model.json","https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_288x160_fuse_activation/model.json",e="large"===n.modelType?"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_398x224_fuse_activation/model.json":"medium"===n.modelType?"https://paddlejs.cdn.bcebos.com/models/humansegv2/model.json":"https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_288x160_fuse_activation/model.json",f=new o.Runner({modelPath:e,needPreheat:void 0===n.needPreheat||n.needPreheat,feedShape:{fw:398,fh:224},fill:"#fff",mean:[.5,.5,.5],std:[.5,.5,.5],plugins:{preTransforms:[new u(n.canvasWidth,n.canvasHeight)]}}),r.GLHelper.setWebGLRenderingContext(g),o.env.set("webgl_pack_channel",!0),o.env.set("webgl_gpu_pipeline",!0),o.env.set("webgl_force_half_float_texture",!0),[4,f.init()];case 1:return t.sent(),[2]}}))}))}function P(){return l(this,void 0,void 0,(function(){return c(this,(function(n){switch(n.label){case 0:return[4,f.preheat()];case 1:return[2,n.sent()]}}))}))}function x(n,e,t){return l(this,void 0,void 0,(function(){var o,r;return c(this,(function(i){switch(i.label){case 0:return _||(_=f.weightMap[f.weightMap.length-1].opData),_.uniform.type.value=1,[4,f.predict(n)];case 1:return i.sent(),o=y(n),e.width=n.width,e.height=n.height,r=e.getContext("2d"),t&&r.drawImage(t,-o.bx,-o.by,o.bw,o.bh),r.drawImage(g.canvas,-o.bx,-o.by,o.bw,o.bh),[2]}}))}))}function b(n,e){return l(this,void 0,void 0,(function(){var t;return c(this,(function(o){switch(o.label){case 0:return _||(_=f.weightMap[f.weightMap.length-1].opData),_.uniform.type.value=0,[4,f.predict(n)];case 1:return o.sent(),e.width=n.width,e.height=n.height,t=y(n),e.getContext("2d").drawImage(g.canvas,-t.bx,-t.by,t.bw,t.bh),[2]}}))}))}function T(n,e,t){return l(this,void 0,void 0,(function(){var o,r;return c(this,(function(i){switch(i.label){case 0:return _||(_=f.weightMap[f.weightMap.length-1].opData),_.uniform.type.value=2,[4,f.predict(n)];case 1:return i.sent(),e.width=n.width,e.height=n.height,o=y(n),(r=e.getContext("2d")).drawImage(t,-o.bx,-o.by,o.bw,o.bh),r.drawImage(g.canvas,-o.bx,-o.by,o.bw,o.bh),[2]}}))}))}function y(n){var e=398,t=224,o=e/t,r=n.naturalWidth||n.width,i=n.naturalHeight||n.height,s=0,a=0,u=0,l=0,c=i,f=r,h=r/i;return o/h>=1?(e=t*h,s=Math.floor((398-e)/2),f=c*o,u=Math.floor((f-r)/2)):(t=e/h,a=Math.floor((224-t)/2),c=f/o,l=Math.floor((c-i)/2)),{x:s,y:a,sw:e,sh:t,bx:u,by:l,bw:f,bh:c}}}])}));