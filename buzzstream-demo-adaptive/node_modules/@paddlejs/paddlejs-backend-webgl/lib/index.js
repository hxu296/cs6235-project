!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.paddlejs=e():(n.paddlejs=n.paddlejs||{},n.paddlejs.webglBackend=e())}(this,(function(){return(()=>{"use strict";var n={400:(n,e,o)=>{o.r(e),o.d(e,{GLHelper:()=>F,glInstance:()=>En,ops:()=>yn,webgl_types:()=>t});var t={};o.r(t),o.d(t,{UniformType:()=>c});var r={};o.r(r),o.d(r,{exp_func:()=>j,hardSigmoid:()=>B,leakyRelu:()=>S,pow_func:()=>D,prelu:()=>C,relu6:()=>R,scale:()=>I,scaleWidthBias:()=>L,sigmoid:()=>k,sqrt:()=>M,tanh_func:()=>U,transferFromNHWCtoNCHW:()=>O});var i={};function s(){var n;if("undefined"!=typeof window)n=window;else if(void 0!==o.g)n=o.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}return n}function a(n,e){var o=s();return o[n]||(o[n]=e),o[n]}o.r(i),o.d(i,{getPixelsFromTexturePos:()=>H,getSamplerCode:()=>z,getTensorPosFromArrayIndex:()=>G,getValueFromTensorPos:()=>N,getValueFromTensorPosPacking:()=>X,moveTexture2PosToReal:()=>W});var u={opRegistry:{ops:{}},backend:"",backendInstance:null};u=a("GLOBALS",u);var l=s();l.ImageBitmap||(l.ImageBitmap=function(){});const f=a("env",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,e){this.ENV[n]=e},n.prototype.get=function(n){return this.ENV[n]},n}()));var c;!function(n){n.uniform1f="1f",n.uniform1fv="1fv",n.uniform1i="1i",n.uniform1iv="1iv",n.uniform2f="2f",n.uniform2fv="2fv",n.uniform2i="2i",n.uniform2iv="2iv",n.uniform3f="3f",n.uniform3fv="3fv",n.uniform3i="3i",n.uniform3iv="3iv",n.uniform4f="4f",n.uniform4fv="4fv",n.uniform4i="4i",n.uniform4iv="4iv"}(c||(c={}));var _;function g(n){for(var e=n.length,o=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(n),t=[];e>1;)o.splice(0,1),t.push(o.reduce((function(n,e){return n*e}))),e--;return t}function h(n,e){if(1===n.length)return"float "+e+" = float("+n[0]+");";for(var o=n.length,t="\n        vec"+o+" "+e+" = vec"+o+"(\n    ",r=0;r<o;r++)t+="float("+n[r]+"),";return t.slice(0,-1)+");"}function d(n,e,o){if(0===n.length)return"";if(2===f.get("webglVersion"))return n.reduce((function(e,t,r){return e+(r<n.length-1?o+"("+t+"), ":o+"("+t+"));")}),o+" "+e+"[] = "+o+"[](");var t=n.reduce((function(n,t,r){return n+"\n            "+e+"["+r+"] = "+o+"("+t+");"}),"");return"\n        "+o+" "+e+"["+n.length+"];\n        "+t+"\n    "}function p(n,e,o){if(0===n.length)return"";var t=n.reduce((function(n,e,t){return n+(0===t?"\n            "+o+" res = "+o+"(0);\n            if (index == "+t+") {\n                res = arr["+t+"];\n            }":"\n            else if (index == "+t+") {\n                res = arr["+t+"];\n            }")}),"");return"\n    "+o+" getValueFromArrByIndex_"+e+"("+o+"["+n.length+"] arr, int index) {\n        "+(2===f.get("webglVersion")?o+" res = arr[index];":t)+"\n        return res;\n    }\n    "}!function(n){n.INT_TYPE="int",n.FLOAT_TYPE="float"}(_||(_={}));var m,P;!function(n){n[n.VS_SHADER=0]="VS_SHADER",n[n.FS_SHADER=1]="FS_SHADER"}(m||(m={})),function(n){n[n.FLOAT_VEC2=35664]="FLOAT_VEC2",n[n.FLOAT_VEC3=35665]="FLOAT_VEC3",n[n.FLOAT_VEC4=35666]="FLOAT_VEC4",n[n.INT_VEC2=35667]="INT_VEC2",n[n.INT_VEC3=35668]="INT_VEC3",n[n.INT_VEC4=35669]="INT_VEC4",n[n.BOOL=35670]="BOOL",n[n.BOOL_VEC2=35671]="BOOL_VEC2",n[n.BOOL_VEC3=35672]="BOOL_VEC3",n[n.BOOL_VEC4=35673]="BOOL_VEC4",n[n.FLOAT_MAT2=35674]="FLOAT_MAT2",n[n.FLOAT_MAT3=35675]="FLOAT_MAT3",n[n.FLOAT_MAT4=35676]="FLOAT_MAT4",n[n.SAMPLER_2D=35677]="SAMPLER_2D",n[n.SAMPLER_CUBE=35678]="SAMPLER_CUBE",n[n.FLOAT=5126]="FLOAT",n[n.INT=5124]="INT"}(P||(P={}));var v,x=function(n,e,o){this.size=n,this.type=e,this.location=o},T=function(n,e,o){this.size=n,this.type=e,this.location=o},F=function(){function n(){}return n.getWebglVersion=function(){return f.get("webglVersion")},n.createCanvas=function(){return f.get("canvas")||document&&document.createElement("canvas")},n.setWebglVersion=function(n){f.set("webglVersion",n)},n.setWebGLRenderingContext=function(n){return this.gl=n,n},n.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},n.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var n=this.createCanvas();if(!n)return null;n.addEventListener&&n.addEventListener("webglcontextlost",(function(n){throw n.preventDefault(),Error("webgl context is lost~")}),!1);var e=n.getContext("webgl2",this.WEBGL_ATTRIBUTES);return e?f.set("webglVersion",2):(f.set("webglVersion",1),e=n.getContext("webgl",this.WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",this.WEBGL_ATTRIBUTES)),e},n.printStates=function(n){console.log("1. isBlendEnable = "+n.isEnabled(n.BLEND)),console.log("2. isCullFaceEnable = "+n.isEnabled(n.CULL_FACE)),console.log("3. isDepthTestEnable = "+n.isEnabled(n.DEPTH_TEST)),console.log("4. isDitherEnable = "+n.isEnabled(n.DITHER)),console.log("5. isPolygonOffsetFillEnable = "+n.isEnabled(n.POLYGON_OFFSET_FILL)),console.log("6. isSampleAlphtToCoverageEnable = "+n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)),console.log("7. isSampleCoverageEnable = "+n.isEnabled(n.SAMPLE_COVERAGE)),console.log("8. isScissorTestEnable = "+n.isEnabled(n.SCISSOR_TEST)),console.log("9. isStencilTestEnable = "+n.isEnabled(n.STENCIL_TEST))},n.printWebGLInfo=function(n){console.log("renderer = "+n.getParameter(n.RENDERER)),console.log("version = "+n.getParameter(n.VERSION)),console.log("vendor = "+n.getParameter(n.VENDOR)),console.log("glsl version = "+n.getParameter(n.SHADING_LANGUAGE_VERSION))},n.printWebGLTextureInfo=function(n){console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_SIZE = ",n.getParameter(n.MAX_TEXTURE_SIZE)),console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE))},n.triggerContextLostEvent=function(n){var e=n.getExtension("WEBGL_lose_context");null!==e&&e.loseContext()},n.checkGLError=function(n){var e=n.getError();return 0!==e&&(console.log("WebGL Error NO: ",e),!0)},n.setDefaultState=function(n){n.clearColor(0,0,0,0),n.clearDepth(1),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.enable(n.SCISSOR_TEST)},n.setViewport=function(n,e){n.viewport(e[0],e[1],e[2],e[3])},n.initShader=function(n,e,o){var t=this.createShader(n,e);return this.compileShader(n,o,t),t},n.createShader=function(n,e){var o;if(null===(o=e===m.VS_SHADER?n.createShader(n.VERTEX_SHADER):n.createShader(n.FRAGMENT_SHADER)))throw new Error("WebGLShader创建失败！");return o},n.compileShader=function(n,e,o){return n.shaderSource(o,e),n.compileShader(o),!1!==n.getShaderParameter(o,n.COMPILE_STATUS)||(console.error(n.getShaderInfoLog(o)),n.deleteShader(o),!1)},n.createProgram=function(n){var e=n.createProgram();if(null===e)throw new Error("WebGLProgram创建失败！");return e},n.linkProgram=function(n,e,o,t,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),n.attachShader(e,o),n.attachShader(e,t),null!==r&&r(n,e),n.linkProgram(e),!1===n.getProgramParameter(e,n.LINK_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(o),n.deleteShader(t),n.deleteProgram(e),!1):(n.validateProgram(e),!1===n.getProgramParameter(e,n.VALIDATE_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(o),n.deleteShader(t),n.deleteProgram(e),!1):(null!==i&&i(n,e),!0))},n.getProgramActiveAttribs=function(n,e,o){for(var t=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES),r=0;r<t;r++){var i=n.getActiveAttrib(e,r);i&&(o[i.name]=new T(i.size,i.type,n.getAttribLocation(e,i.name)))}},n.getProgramAtciveUniforms=function(n,e,o){for(var t=n.getProgramParameter(e,n.ACTIVE_UNIFORMS),r=0;r<t;r++){var i=n.getActiveUniform(e,r);if(i){var s=n.getUniformLocation(e,i.name);null!==s&&(o[i.name]=new x(i.size,i.type,s))}}},n.createBuffer=function(n){var e=n.createBuffer();if(null===e)throw new Error("WebGLBuffer创建失败！");return e},n.getColorBufferData=function(n){var e=new Uint8Array(n.drawingBufferWidth*n.drawingBufferHeight*4);return n.readPixels(0,0,n.drawingBufferWidth,n.drawingBufferHeight,n.RGBA,n.UNSIGNED_BYTE,e),e},n.setUniformParam=function(n,e,o,t){switch(o){case c.uniform1f:n.uniform1f(e,t);break;case c.uniform1fv:n.uniform1fv(e,t);break;case c.uniform1i:n.uniform1i(e,t);break;case c.uniform1iv:n.uniform1iv(e,t);break;case c.uniform2f:n.uniform2f(e,t[0],t[1]);break;case c.uniform2fv:n.uniform2fv(e,t);break;case c.uniform2i:n.uniform2i(e,t[0],t[1]);break;case c.uniform2iv:n.uniform2iv(e,t);break;case c.uniform3f:n.uniform3f(e,t[0],t[1],t[2]);break;case c.uniform3fv:n.uniform3fv(e,t);break;case c.uniform3i:n.uniform3i(e,t[0],t[1],t[2]);break;case c.uniform3iv:n.uniform3iv(e,t);break;case c.uniform4f:n.uniform4f(e,t[0],t[1],t[2],t[3]);break;case c.uniform4fv:n.uniform4fv(e,t);break;case c.uniform4i:n.uniform4i(e,t[0],t[1],t[2],t[3]);break;case c.uniform4iv:n.uniform4iv(e,t);break;default:console.error("["+o+"]: unknown uniform type")}},n.genTextureInfoFromTensorShape=function(n,e){var o=n||4096,t=e.shape,r=void 0===t?[]:t,i=r[0],s=r[1],a=r[2],u=r[3];if(i*a<=o&&s*u<=o)e.shape_texture=[i*a,s*u];else{var l=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(r).sort((function(n,e){return n-e})),c=l[0],_=l[1],g=l[2],h=c*l[3],d=_*g;if(h>o||d>o){var p=[h,d].sort((function(n,e){return n-e})),m=p[0],P=p[1],v=function(n,e){var o=e;if(n%o==0)return o;for(;o<n&&n%o!=0;)o++;return o}(P,Math.ceil(P/o));if(h=m*v,d=Math.ceil(P/v),f.get("debug")&&console.error("大小超限",r,[d,h]),h>o||d>o)throw new Error("Requested texture size ["+h+"x"+d+"] greater than WebGL maximum on this browser / GPU ["+o+"x"+o+"].")}e.shape_texture=[d,h]}},n.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"high-performance"},n.gl=null,n}();!function(n){n[n.GL_REPEAT=0]="GL_REPEAT",n[n.GL_MIRRORED_REPEAT=1]="GL_MIRRORED_REPEAT",n[n.GL_CLAMP_TO_EDGE=2]="GL_CLAMP_TO_EDGE"}(v||(v={}));var b=function(){function n(){}return n.getTextureConfig=function(n){var e,o,t,r,i,s,a,u,l=n,c=!0,_=!0;return 2===f.get("webglVersion")?(e=l.getExtension("EXT_color_buffer_float"),t=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,s=l.R16F,a=l.RGBA16F,o=l.RED,u=l.RGBA32F):(r=l.RGBA,s=l.RGBA,a=l.RGBA,i=l.RGBA,o=l.RGBA,u=l.RGBA,e=l.getExtension("OES_texture_float"),t=l.getExtension("OES_texture_half_float").HALF_FLOAT_OES,c=this.isDownloadFloatTextureEnabled(l,u),_=this.isFloatTextureReadPixelsEnabledMethod(l,1,c)),{textureFloat:e,textureHalfFloat:t,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,textureFormat:o,downloadInternalFormat:u,frameBufferSupportFloat:c,isFloatTextureReadPixelsEnabled:_}},n.isFloatTextureReadPixelsEnabledMethod=function(n,e,o){var t=n;if(0===e)return!1;if(1===e){if(null==t.getExtension("OES_texture_float"))return!1}else if(null==t.getExtension("EXT_color_buffer_float")||null==t.getExtension("EXT_color_buffer_half_float"))return!1;var r=t.createFramebuffer(),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i);var s=2===e?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,s,1,1,0,t.RGBA,o?t.FLOAT:t.getExtension("OES_texture_half_float").HALF_FLOAT_OES,null),t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4));var u=t.getError()===t.NO_ERROR;return a&&u},n.isDownloadFloatTextureEnabled=function(n,e){var o=n.createTexture();n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,e,1,1,0,n.RGBA,n.FLOAT,null);var t=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,t),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,o,0);var r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(o),n.deleteFramebuffer(t),r},n.uploadDataToTexture=function(n,e,o,t){n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var r=o.width_texture,i=o.height_texture,s=o.data,a=n.RGBA,u=n.RGBA,l=n.FLOAT,c=s;if(s instanceof Uint8Array||s instanceof Uint8ClampedArray)l=n.UNSIGNED_BYTE;else{if(!(s instanceof Float32Array||s instanceof Array))return void n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,s);if(2===f.get("webglVersion")){var _=f.get("webgl_force_half_float_texture");a=t?_?e.internalFormatPackedHalfFloat:e.internalFormatPacked:_?e.internalFormatHalfFloat:e.internalFormat,u=t?n.RGBA:e.textureFormat}else{for(var g=new Float32Array(r*i*4),h=0;h<s.length;h++)t?g[h]=s[h]:(g[4*h]=s[h],g[4*h+1]=0,g[4*h+2]=0,g[4*h+3]=0);c=g}}n.texImage2D(n.TEXTURE_2D,0,a,r,i,0,u,l,c)},n.genOutputTexture=function(n,e,o,t){var r=o.interpType,i=o.width_texture,s=o.height_texture,a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var u=f.get("webgl_force_half_float_texture"),l=u?e.internalFormatPackedHalfFloat:e.internalFormatPacked,c=2===f.get("webglVersion")?u?n.HALF_FLOAT:n.FLOAT:e.frameBufferSupportFloat?n.FLOAT:e.textureHalfFloat,_=t?e.isFloatTextureReadPixelsEnabled?c:n.UNSIGNED_BYTE:null;return n.texImage2D(n.TEXTURE_2D,0,l,i,s,0,n.RGBA,t?_:c,null),n.bindTexture(n.TEXTURE_2D,null),a},n}(),y=["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ","#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],E=new Float32Array([-1,1,-1,-1,1,1,1,-1]),w=["length_shape","length_unformatted_shape","width_shape","height_shape","width_texture","height_texture","offset_x","offset_y","channel","total_shape","numbers_shape"],V={float:["multi_value","bias_value"],bool:["fuse_relu"]};function A(){return"\n    "+(f.get("useModAdaptor")?"\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        ":"\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ")+"\n    "+(f.get("useDivisionAdaptor")?"\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        ":"\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ")+"\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    "}const O="\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n";var C="\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",R="\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",S="\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",I="\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",L="\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",k="\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",B="\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",M="\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",D="\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",U="\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}",j="\nfloat exp_func(float x, float y, float z) {\n    float result = exp(x);\n    return result;\n}";function N(n,e){var o=e.width_shape,t=e.height_shape,r=e.channel,i=e.width_texture;return"\n    float getValueFromTensorPos_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+o*t*r+" + c * "+o*t+" + h * "+o+" + w;\n        // 0.01 hack: 在 PC/WISE 机器上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+i+")));\n        int pos_h = index / int("+i+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+i+"),\n                (float(pos_h) + 0.5) / float("+e.height_texture+")\n            )\n        );\n        return pixels.r;\n    }"}function X(n,e){var o=e.channel,t=e.height_shape,r=e.width_texture,i=e.height_texture,s=e.width_shape;return"\n    vec4 getValueFromTensorPosPacking_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+s*t*o+" + c * "+s*t+" + h * "+s+" + w;\n        // 0.01 hack: 在 PC/WISE 设备上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+r+")));\n        int pos_h = index / int("+r+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+r+"),\n                (float(pos_h) + 0.5) / float("+i+")\n            )\n        );\n        return pixels;\n    }"}function G(n,e){var o=e.numbers_shape,t=e.length_shape;if(1===t)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+o[0]+");\n            }\n        ";for(var r="ivec"+t+"("+o.join(", ")+")",i="pos[0] = n / "+o[0]+";",s=1;s<t;s++)i+="\n            n = calMod(n, "+o[s-1]+");\n            pos["+s+"] = calDivision(n, "+o[s]+");\n        ";return"\n    ivec"+t+" shapeVec_"+n+" = "+r+";\n    ivec"+t+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+t+" pos;\n        "+i+"\n        return pos;\n    }\n    "}function H(n){return"\n    #define getPixelsFromTexturePos_"+n+"(pos) TEXTURE2D(texture_"+n+", pos)\n    "}function W(n,e){return"\n    vec2 moveTexture2PosToReal_"+n+"(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float("+e.width_texture+");\n        v2.y = v.y * float("+e.height_texture+");\n        return v2;\n    }\n    "}function z(n){return"uniform sampler2D texture_"+n+";"}function Y(n,e,o,t,s){var a,u,l="",c=e.name,_=e.mainFunc,g=e.textureFuncConf,h=void 0===g?{}:g,d=e.commonFuncConf;try{var p=function(n,e,o){for(var t={},r=Object.assign({},e),i=[],s=0,a=n;s<a.length;s++){for(var u=a[s],l=u.name,f={},c=0,_=w;c<_.length;c++)void 0!==u[P=_[c]]&&(f[P]=u[P]);t[l]=f,i.push(l)}for(var g=0,h=Object.keys(V);g<h.length;g++)for(var d=h[g],p=0,m=V[d];p<m.length;p++){var P;void 0!==e[P=m[p]]&&(r[P]=d+"("+e[P]+")")}return e.active_function&&(r.active_function=e.active_function),r.runtime=o,{textureParams:t,opParams:r,active_function:e.active_function}}(o,t,s),m=p.textureParams,P=p.opParams,v=p.active_function,x=2===f.get("webglVersion")?" #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        ":" #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",T=function(n){var e=n.frameBufferSupportFloat,o=n.isFinalOp,t=n.isFloatTextureReadPixelsEnabled;return 2===f.get("webglVersion")?"\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        "+A()+"\n    ":e?"\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            "+A()+"\n    ":o&&!t?"\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        "+A()+"\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        ":"\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            "+A()+"\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        "}(n),F=function(n){var e="",o="";if(n.fuse_opt)for(var t in n.fuse_opt){var i=t,s=0,a=0;switch(t){case"scale":var u=n.fuse_opt.scale.bias_after_scale;s=void 0!==(f=n.fuse_opt.scale.scale)?f:1,a=n.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i="scaleWidthBias");break;case"relu":i="prelu";break;case"relu6":s=n.fuse_opt[t].threshold;break;case"hard_sigmoid":i="hardSigmoid",s=n.fuse_opt[t].slope||.2,a=n.fuse_opt[t].offset||.5;break;case"leakyRelu":s=n.fuse_opt[t].alpha;break;case"pow":i="pow_func",s=n.fuse_opt[t].factor||2;break;case"tanh":i="tanh_func";break;case"exp":i="exp_func"}if("hard_swish"===t){var l=void 0!==n.fuse_opt.hard_swish.offset?n.fuse_opt.hard_swish.offset:3,f=void 0!==n.fuse_opt.hard_swish.scale?n.fuse_opt.hard_swish.scale:6;o+="res = res * min(max(0.0, res + float("+l+")), float("+(void 0!==n.fuse_opt.hard_swish.threshold?n.fuse_opt.hard_swish.threshold:6)+")) / float("+f+");"}else"dropout"===t?o+="\n                if ("+("downgrade_in_infer"===n.fuse_opt.dropout.dropout_implementation)+") {\n                    res = res * (1.0 - float("+n.fuse_opt.dropout.dropout_prob+"));\n                }":(e+=r[i],o+="res = "+i+"(res, float("+s+"), float("+a+"));")}return"\n        "+e+"\n        \n        float fuse_op(float x) {\n            float res = x;\n            "+o+"\n            return res;\n        }\n    "}(P),b=function(n,e,o,t){if(!n)return"";var r=Object.assign({},n);r["@all"]&&function(n,e){var o=e.filter((function(n){return"out"!==n.name})),t=n["@all"];o.forEach((function(e){var o=e.name;n[o]?n[o].concat(t):n[o]=t})),delete n["@all"]}(r,t);for(var s="",a="",u=0,l=Object.keys(r);u<l.length;u++){var f=l[u];if(e[f]){a+=z(f);for(var c=0,_=r[f];c<_.length;c++){var g=_[c];if(i[g])try{s+=i[g](f,e[f],o)}catch(n){console.error(n)}}}}return"\n    "+a+"\n    "+s+"\n    "}(h,m,P,o),y=function(n){return void 0===n?"":"\n        int layer_run_time = "+n+";\n    "}(s),E=function(n){var e,o,t,r,i;return"\n        \n    vec2 _2d_shape_texture_out = vec2(float("+n.width_texture+"), float("+n.height_texture+"));\n    \n        "+(o=(e=n).height_shape,t=e.width_shape,"\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+e.width_texture+");\n\n        int n1 = int(index / "+(r=t*o*e.channel)+");\n        int c1 = int(calMod(index, "+r+") / "+(i=t*o)+");\n        int h1 = int(calMod(index, "+i+") / "+t+");\n        int w1 = calMod(index, "+t+");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ")}(m.out),O=function(n){if(!n)return"";for(var e="",o=0,t=n;o<t.length;o++){var i=t[o];r[i]&&(e+=r[i])}return e}(d);a=l=" "+x+"\n            "+F+"\n            "+T+"\n            "+O+"\n            "+(v?r[v]:"")+"\n            "+b+"\n            "+y+"\n            "+E+"\n            "+_(m,P)+"\n        ",u=1===f.get("webglVersion")?"texture2D":"texture",l=a.replace(/\bTEXTURE2D\b/g,u)}catch(n){console.error("["+c+"]: "+n)}return l}const q=function(){function n(n,e,o,t){var r=n;this.vShader=e;try{this.fShader=this.initShader(r,o,"fragment"),this.shape=t&&t.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(n){throw new Error(n)}}return n.prototype.initShader=function(n,e,o){void 0===o&&(o="vertex");var t,r="vertex"===o?n.VERTEX_SHADER:n.FRAGMENT_SHADER;if("vertex"===o&&this.vShader)t=this.vShader;else if(t=n.createShader(r),"vertex"===o&&(this.vShader=t),n.shaderSource(t,e),n.compileShader(t),!n.getShaderParameter(t,n.COMPILE_STATUS))throw new Error("compile: "+n.getShaderInfoLog(t));return t},n.prototype.setProgram=function(n,e,o){n.useProgram(this.program),o||this.runVertexShader(n,e)},n.prototype.runVertexShader=function(n,e){var o=n.getAttribLocation(this.program,"position");n.enableVertexAttribArray(o),n.bindBuffer(n.ARRAY_BUFFER,e),n.vertexAttribPointer(o,2,n.FLOAT,!1,0,0)},n.Sampler="uSampler",n}();var Z,K=(Z=function(n,e){return(Z=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o])})(n,e)},function(n,e){function o(){this.constructor=n}Z(n,e),n.prototype=null===e?Object.create(e):(o.prototype=e.prototype,new o)}),Q=function(n,e,o,t){return new(o||(o=Promise))((function(r,i){function s(n){try{u(t.next(n))}catch(n){i(n)}}function a(n){try{u(t.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof o?e:new o((function(n){n(e)}))).then(s,a)}u((t=t.apply(n,e||[])).next())}))},J=function(n,e){var o,t,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(o)throw new TypeError("Generator is already executing.");for(;s;)try{if(o=1,t&&(r=2&i[0]?t.return:i[0]?t.throw||((r=t.return)&&r.call(t),0):t.next)&&!(r=r.call(t,i[1])).done)return r;switch(t=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,t=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],t=0}finally{o=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const $=function(n){function e(){var e=n.call(this)||this;return e.cacheTextures={},e.uniformLocations={},e.texturesMap={},e.queryList=[],e.currentTexture=null,e.width_shape_out=1,e.height_shape_out=1,e.width_texture_out=1,e.height_texture_out=1,e.channel=0,e.total_shape=0,e}return K(e,n),e.prototype.init=function(){return Q(this,void 0,void 0,(function(){var n;return J(this,(function(e){return n=this.gl=F.createWebGLRenderingContext(),this.gl?(this.glVersion=F.getWebglVersion(),this.textureConf=b.getTextureConfig(n),this.MAX_TEXTURE_SIZE=f.get("MAX_TEXTURE_SIZE")||n.getParameter(n.MAX_TEXTURE_SIZE),n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),this.vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,E,n.STATIC_DRAW),this.vShader=F.initShader(n,m.VS_SHADER,y[this.glVersion-1]),this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),this.pbo=n.createBuffer(),[2]):[2]}))}))},e.prototype.createProgram=function(n){var e=this,o=n.op,t=n.outTensor,r=n.inputTensors,i=n.shaderParams,s=n.runtime,a=n.isFinalOp,u=null;try{var l=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([t],r);l.forEach((function(n){return F.genTextureInfoFromTensorShape(e.MAX_TEXTURE_SIZE,n)}));var f=Y(this.textureConf,o,l,i,s);(u=new q(this.gl,this.vShader,f,t)).fsCode=f;var c=b.genOutputTexture(this.gl,this.textureConf,t,a);this.texturesMap[t.tensorId]=c,this.program=u}catch(n){console.error("webgl createProgram: "+o.name+" -- "+n)}return u},e.prototype.runProgram=function(n,e){var o=this,t=function(n,e){if(2===e&&f.get("performance")){var o=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!o)return;var t=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,t),t}return null}(this.gl,this.glVersion),r=n.isPackedOp;n.program.forEach((function(t,i){var s=n.outputTensors[i],a=s.tensorId;o.setOutProps(s),"frameBuffer"===n.bufferType?o.attachFrameBuffer(a):o.attachColorBuffer(),t.setProgram(o.gl,o.vertexBuffer,e),o.program=t,o.render(n,e,i,r)})),n.tensorData=null,t&&(this.queryList.push({name:n.name,query:t,count:1}),t=function(n,e,o){if(2===e&&f.get("performance")){var t=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!t)return;n.endQuery(t.TIME_ELAPSED_EXT)}return o}(this.gl,this.glVersion,t))},e.prototype.read=function(n){return Q(this,void 0,void 0,(function(){var e,o,t;return J(this,(function(r){switch(r.label){case 0:return f.get("webgl_gpu_pipeline")?(e=this.gl,this.frameBuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),[2,[]]):(o=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return r.sent(),t=n?n.shape:[],[2,this.downloadFloat32TensorFromBuffer(o,t)]}}))}))},e.prototype.createPBO=function(){var n,e=this.textureConf;if(2===this.glVersion){var o=this.gl,t=this.pbo;o.bindBuffer(o.PIXEL_PACK_BUFFER,t);var r=16*this.width_texture_out*this.height_texture_out;return o.bufferData(o.PIXEL_PACK_BUFFER,r,o.STREAM_READ),o.readPixels(0,0,this.width_texture_out,this.height_texture_out,o.RGBA,o.FLOAT,0),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),t}var i=this.gl,s=i.FLOAT;return e.isFloatTextureReadPixelsEnabled?n=new Float32Array(this.width_texture_out*this.height_texture_out*4):(n=new Uint8Array(this.width_texture_out*this.height_texture_out*4),s=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,s,n),e.isFloatTextureReadPixelsEnabled?n:new Float32Array(n.buffer)},e.prototype.createAndWaitForFence=function(){return Q(this,void 0,void 0,(function(){var n,e,o,t,r=this;return J(this,(function(i){return n=this.gl,e=null!=n.fenceSync,o=function(){return!0},e&&(t=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0),n.flush(),o=function(){var e=n.clientWaitSync(t,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED}),[2,new Promise((function(n){r.pollItem(o,n)}))]}))}))},e.prototype.pollItem=function(n,e){var o=function(){n()?e():setTimeout(o,1)};o()},e.prototype.downloadFloat32TensorFromBuffer=function(n,e){var o=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var t=this.gl,r=new Float32Array(o);t.bindBuffer(t.PIXEL_PACK_BUFFER,n),t.getBufferSubData(t.PIXEL_PACK_BUFFER,0,r),t.bindBuffer(t.PIXEL_PACK_BUFFER,null);var i=[];if(f.get("webgl_pack_output"))return Array.from(r).slice(0,function(n){return n.reduce((function(n,e){return n*e}),1)}(e));for(var s=0;s<this.width_texture_out*this.height_texture_out;s++)i.push(r[4*s]);return i}var a=n,u=[];for(s=0;s<this.width_texture_out*this.height_texture_out;s++){var l=this.textureConf.isFloatTextureReadPixelsEnabled?4*s:s;u.push(a[l])}return u},e.prototype.setOutProps=function(n){var e=n.width_shape,o=void 0===e?1:e,t=n.height_shape,r=void 0===t?1:t,i=n.width_texture,s=void 0===i?1:i,a=n.height_texture,u=void 0===a?1:a,l=n.channel,f=void 0===l?0:l,c=n.total_shape,_=void 0===c?0:c;this.width_shape_out=o,this.height_shape_out=r,this.width_texture_out=s,this.height_texture_out=u,this.channel=f,this.total_shape=_},e.prototype.attachColorBuffer=function(){var n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.canvas.width=this.width_shape_out,n.canvas.height=this.height_shape_out,n.viewport(0,0,n.canvas.width,n.canvas.height),n.scissor(0,0,n.canvas.width,n.canvas.height)},e.prototype.attachFrameBuffer=function(n){this.currentTexture=this.texturesMap[n];var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.currentTexture,0),e.viewport(0,0,this.width_texture_out,this.height_texture_out),e.scissor(0,0,this.width_texture_out,this.height_texture_out)},e.prototype.render=function(n,e,o,t){var r=this;void 0===e&&(e=!1),void 0===t&&(t=!1);var i=n.inputTensors,s=void 0===i?[]:i,a=n.uniform,u=void 0===a?null:a,l=n.iLayer,f=void 0===l?0:l,c=n.modelName,_=this.gl,g=0;s.forEach((function(n){r.initTexture(g,n,t);var i=r.getUniformLoc("texture_"+n.name,f,e,o,c);i&&_.uniform1i(i,g++)})),u&&this.setUniform(u,f,e,o,c),_.drawArrays(_.TRIANGLE_STRIP,0,4)},e.prototype.initTexture=function(n,e,o){var t,r=this.gl,i=this.textureConf,s=e.tensorId,a=o||e.isPacked,u=e.data;if(e.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[s];l?(t=l,u&&F.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,e)):(t=r.createTexture(),this.cacheTextures[s]=t)}else t=this.texturesMap[s];r.activeTexture(r["TEXTURE"+n]),r.bindTexture(r.TEXTURE_2D,t),u&&(b.uploadDataToTexture(r,i,e,a),e.data=null)},e.prototype.setUniform=function(n,e,o,t,r){var i=this,s=Object.keys(n),a=this.gl;s.forEach((function(s){var u=n[s].type,l=n[s].value,f=i.getUniformLoc(s,e,o,t,r);F.setUniformParam(a,f,u,l)}))},e.prototype.getUniformLoc=function(n,e,o,t,r){var i=r+"_";if(o)return this.uniformLocations[i+e][n+t];var s=this.gl.getUniformLocation(this.program.program,n);return this.uniformLocations[i+e]=this.uniformLocations[i+e]||{},this.uniformLocations[i+e][n+t]=s,s},e.prototype.dispose=function(){},e}((function(){})),nn={mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.filter_nearest_vec4,p=e.filter_remainder_vec4,m=e.act_type,P=void 0===m?"":m,v=e.padding_algorithm,x=void 0===v?"":v,T=e.hard_swish_offset,F=void 0===T?3:T,b=e.hard_swish_scale,y=void 0===b?6:b,E=e.hard_swish_threshold,w=void 0===E?6:E,V=l[0],A=void 0===V?1:V,O=l[1],C=void 0===O?1:O,R=c[0],S=void 0===R?0:R,I=c[1],L=void 0===I?0:I,k=g[0],B=void 0===k?1:k,M=g[1],D=void 0===M?1:M;return"SAME"===x&&Math.ceil((o.width_shape-t.width_shape)/A)+1!==r.width_shape&&(S=1,L=1),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+a+")) * "+t.channel+";\n        int oy = y * "+A+" - "+S+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+B+";\n                continue;\n            }\n            int ox = x * "+C+" - "+L+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+D+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+d+"; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if ("+p+" == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox));\n                } else if ("+p+" == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if ("+p+" == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += "+D+";\n            }\n            oy += "+B+";\n        }\n\n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n\n        if ("+h+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===P)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        else if ("+("hard_swish"===P)+") {\n            res = res * min(\n                max(0.0, res + float("+F+")),\n                float("+w+")\n            ) / float("+y+");\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]};function en(n,e){var o=n[0],t=n[1],r=n[2],i=n[3];if(1===o&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function on(n,e,o){if(1===o)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var t=g(e);return t.push(1),"\n    ivec"+o+" shapeVec_"+n+" = ivec"+o+"("+t.join(", ")+");\n    ivec"+o+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+o+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+o+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function tn(n){return 1===n?"int":"ivec"+n}function rn(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}const sn={mainFunc:function(n,e){var o=n.origin,t=e.transpose_X,r=void 0!==t&&t,i=e.transpose_Y,s=void 0!==i&&i,a=e.trans_x,u=void 0!==a&&a,l=e.trans_y,f=r||u,c=s||void 0!==l&&l;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if ("+f+") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if ("+c+") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < "+(f?o.height_shape:o.width_shape)+"; j++) {\n            if ("+f+") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if ("+c+") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}};function an(n,e){var o=n[0],t=n[1],r=n[2],i=n[3];if(1===o&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function un(n,e,o){if(1===o)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var t=g(e);return t.push(1),"\n    ivec"+o+" shapeVec_"+n+" = ivec"+o+"("+t.join(", ")+");\n    ivec"+o+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+o+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+o+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function ln(n){return 1===n?"int":"ivec"+n}function fn(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}const cn={mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getTensorPosFromArrayIndex","getValueFromTensorPos"]}},_n={mainFunc:function(n,e){var o=n.out,t=n.origin,r=e.align_mode,i=void 0===r?1:r,s=e.align_corners,a=void 0===s||s;return"\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = "+i+" == 0 && !"+a+";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+a+") {\n            scale_x = float("+o.width_shape+" - 1) / float("+t.width_shape+" - 1);\n            scale_y = float("+o.height_shape+" - 1) / float("+t.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+o.width_shape+") / float("+t.width_shape+");\n            scale_y = float("+o.height_shape+") / float("+t.height_shape+");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, "+t.width_shape+");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, "+t.height_shape+");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},gn=_n;var hn={relu:["transToPrelu"],relu6:["transToRelu6"],leaky_relu:["transToLeakyrelu"],transToLeakyrelu:["transToLeakyrelu"],scale:["transToScale"],sigmoid:["transToSigmoid"],hard_sigmoid:["transToHardSigmoid"],pow:["transToPow"],exp:["transToExp"],sqrt:["transToSqrt"],tanh:["transToTanh"]};function dn(n,e){var o=e.multi_value,t=void 0===o?1:o,r=e.bias_value,i=void 0===r?0:r;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = "+e.active_function+"(o, float("+t+"), float("+i+"));\n        setOutput(res);\n    }\n    "}function pn(n){return{mainFunc:dn,textureFuncConf:{origin:["getPixelsFromTexturePos"]},behaviors:hn[n]}}const mn={mainFunc:function(n,e){var o=e.axes,t=Array.isArray(o)?o:[o],r=[0,1,2,3].filter((function(n){return n>=t.length}));return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+[0,1,2,3].map((function(n){return t.indexOf(n)>-1?0:"oPos["+r.splice(0,1)+"]"})).join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},Pn={mainFunc:function(n,e){var o=n.origin,t=n.out,r=e.align_corners;return"\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+r+") {\n            scale_x = float("+t.width_shape+" -1) / float("+o.width_shape+" - 1);\n            scale_y = float("+t.height_shape+" - 1) / float("+o.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+t.width_shape+") / float("+o.width_shape+");\n            scale_y = float("+t.height_shape+") / float("+o.height_shape+");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, "+r+");\n        int vy = getData(float(oPos.b), scale_y, "+r+");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]};var vn=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t};const xn={mainFunc:function(n,e){var o=n.origin,t=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.fixed_sizes,u=e.fixed_ratios,l=e.densities,f=e.flatten_to_2d,c=e.clip,_=e.step_w,d=void 0===_?0:_,p=e.step_h,m=void 0===p?0:p,P=e.offset,v=void 0===P?.5:P,x=e.runtime,T=void 0===x?0:x,F=t.height_shape,b=t.width_shape,y=o.height_shape,E=o.width_shape,w=r.total_shape,V=r.channel,A=r.height_shape,O=r.width_shape,C=w/V/A/O,R=g([C,V,A,O]),S=d,I=m;0!==d&&0!==m||(S=b/E,I=F/y);var L=Math.round(.5*(S+I)),k=u.map((function(n){return Math.sqrt(n)})),B=1===k.length?"sqrt_fixed_ratios":"sqrt_fixed_ratios[r]",M=u.length,D=A,U=C,j=V;f&&(U=y,j=E,D=A/y/E);var N=g([U,j,D,O]),X=G("out1",{numbers_shape:vn(N,[1]),length_shape:4}),H=l.map((function(n){return n*n*M})),W=H.length,z=function(n){var e="ivec2 calRemain(int remain, int curAccIndex, int s) {",o=n.length;if(1===o)e+="\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";else for(var t=0;t<o;t++)e+="\n            int accIndex"+t+" = density_acc_shape["+t+"];\n\n            if (remain >= accIndex"+t+") {\n                s++;\n                remain -= accIndex"+t+";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";return e+"\n    }\n    "}(H),Y=c?"v = min(max(v, 0.), 1.);":"",q=1===W?"density_acc_shape":"density_acc_shape[0]",Z="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    "+X+"\n    \n        "+h(l,"densities")+"\n        "+h(a,"fixed_sizes")+"\n        "+h(k,"sqrt_fixed_ratios")+"\n        "+function(n,e){if(1===n.length)return"int "+e+" = int("+n[0]+");";for(var o=n.length,t="\n        ivec"+o+" "+e+" = ivec"+o+"(\n    ",r=0;r<o;r++)t+=n[r]+",";return t.slice(0,-1)+");"}(H,"density_acc_shape")+"\n    \n    "+z+"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * "+R[0]+" + gg * "+R[1]+" + bb * "+R[2]+" + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    ";return 1===T?"\n        "+h(s,"variances")+"\n        "+Z+"\n        setOutput(getFloat4TensorVal(variances, aa));\n        }":"\n            "+Z+"\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = "+q+";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat"+l.length+"TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float("+v+")) * float("+S+");\n            float center_y = (float(h) + float("+v+")) * float("+I+");\n            float fixed_size = getFloat"+a.length+"TensorVal(fixed_sizes, s);\n            float shift = float("+L+") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * "+B+";\n                float density_center_x = center_x - float("+L+") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float("+b+"), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float("+b+"), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / "+B+";\n                float density_center_y = center_y - float("+L+") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float("+F+"), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float("+F+"), 1.);\n                }\n            }\n\n            "+Y+"\n\n            setOutput(v);\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},Tn={mainFunc:function(n,e){var o=n.origin,t=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.flip,u=e.clip,l=e.step_w,f=void 0===l?0:l,c=e.step_h,g=void 0===c?0:c,m=e.offset,P=void 0===m?.5:m,v=e.runtime,x=void 0===v?0:v,T=e.min_sizes,F=void 0===T?[]:T,b=e.max_sizes,y=void 0===b?[]:b,E=e.aspect_ratios,w=void 0===E?[]:E,V=e.min_max_aspect_ratios_order,A=void 0!==V&&V,O=t.height_shape,C=t.width_shape,R=o.height_shape,S=o.width_shape,I=r.channel,L=r.height_shape,k=f,B=g;0!==f&&0!==g||(k=C/S,B=O/R);var M=[1];w.forEach((function(n){1!==n&&(M.push(Math.sqrt(n)),a&&M.push(Math.sqrt(1/n)))}));var D=M.length,U="\n        "+d(F,"min_sizes",_.FLOAT_TYPE)+"\n        "+d(y,"max_sizes",_.FLOAT_TYPE)+"\n        "+d(M,"aspect_ratios",_.FLOAT_TYPE)+"\n    ",j=u?"res = min(max(res, 0.), 1.);":"",N="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    \n        "+p(F,"min_sizes",_.FLOAT_TYPE)+"\n        "+p(y,"max_sizes",_.FLOAT_TYPE)+"\n        "+p(M,"aspect_ratios",_.FLOAT_TYPE)+"\n    \n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        "+U+"\n\n    ";return 1===x?"\n            "+h(s,"variances")+"\n            "+N+"\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }":"\n            "+N+"\n            int idx = nn * "+I*L+" + cc * "+L+" + hh;\n            int as_num = "+D+";\n            float offset = "+P+";\n            \n            int feature_width = "+S+";\n            int num_priors = "+L+";\n            float step_width = float("+k+");\n            float step_height = float("+B+");\n\n            float im_width = float("+C+");\n            float im_height = float("+O+");\n\n            bool min_max_aspect_ratios_order = "+A+";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = calMod(idx / num_priors, feature_width);\n            int p = calMod(idx, num_priors);\n            int m = "+(y.length>0)+" ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = getValueFromArrByIndex_min_sizes(min_sizes, m);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            "+(y.length>0?"\n            int s = calMod(p, as_num + 1);\n            if ("+!A+") {\n                if (s < as_num) {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s - 1);\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }":"\n            int s = calMod(p, as_num);\n            float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ")+"\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            "+j+"\n\n            setOutput(float(res));\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:[]};const Fn={mainFunc:function(n,e){for(var o=n.out,t=function(n,e){var o={};for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&e.indexOf(t)<0&&(o[t]=n[t]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(t=Object.getOwnPropertySymbols(n);r<t.length;r++)e.indexOf(t[r])<0&&Object.prototype.propertyIsEnumerable.call(n,t[r])&&(o[t[r]]=n[t[r]])}return o}(n,["out"]),r=t.origin,i=r.width_shape,s=r.height_shape,a=r.channel,u=r.total_shape,l=r.length_unformatted_shape,f=[u/(i*s*a),a,s,i].slice(4-l),c=Object.keys(t).length,_=e.axis<0?e.axis+f.length+1:e.axis,g=1,h=1,d=0;d<_;d++)g*=f[d];for(d=_;d<f.length;d++)h*=f[d];var p=o.total_shape/g,m="";return m=Array.from(Array(c).keys()).reduce((function(n,e){return n+(0===e?"\n            if (i == 0) {\n                ivec4 co = getTensorPosFromArrayIndex_origin(j);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (i == "+e+") {\n                ivec4 co = getTensorPosFromArrayIndex_origin_"+e+"(j);\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }")}),m),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n\n        int index = calMod(sumVal, "+p+");\n\n        int layer = sumVal / "+p+";\n\n        int i = index / "+h+";\n        int j = calMod(index, "+h+") + layer * "+h+";\n\n        float o = 0.0;\n        "+m+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},bn={mainFunc:function(n,e){var o=n.out,t=n.origin,r=e.axes,i=e.starts,s=e.ends,a=e.decrease_axis;if(r.length>1||i.length>1||s.length>1||a&&0===a.length)throw Error("[slice op feature]: current support one dim, support decrease_axis");var u=t.width_shape,l=t.height_shape,f=t.channel,c=t.total_shape,g=t.length_unformatted_shape,h=[c/(u*l*f),f,l,u],m=r[0];if(m<0&&(m=m+g+1),4!==(m=4-g+m))throw Error("[slice op feature]: unsupport axis value");for(var P=i[0],v=s[0],x=h[0],T=h[1],F=h[2],b=h[3],y=[],E=P;E<v;E++)for(var w=0;w<x;w++)for(var V=0;V<T;V++)for(var A=0;A<F;A++)y.push(w*T*F*b+V*F*b+A*b+E);var O=d(y,"arr",_.INT_TYPE);return"\n    "+p(y,"arr",_.INT_TYPE)+"\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        "+O+"\n\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n\n        int index = getValueFromArrByIndex_arr(arr, sumVal);\n\n        float res = 0.0;\n        ivec4 co = getTensorPosFromArrayIndex_origin(index);\n        res = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}};var yn={arg_max:{mainFunc:function(n,e){var o=n.origin,t=e.axis,r=void 0===t?-1:t,i=e.flatten,s=o.total_shape,a=o.height_shape,u=o.width_shape,l=o.channel,f=o.length_unformatted_shape,c=s/(u*a*l),_=r<0?3:4-f+r,g=[c,l,a,u][_];return"\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+_+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+c+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},arg_min:{mainFunc:function(n,e){for(var o=n.origin,t=e.axis,r=void 0===t?-1:t,i=e.flatten,s=o.total_shape,a=o.height_shape,u=o.width_shape,l=o.channel,f=s/(u*a*l),c=[f,l,a,u],_=0,g=0;g<4&&!(c[g]>1);g++)_++;var h=r<0?4-_+r:r,d=c[h=_+h];return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+h+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+f+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},conv2d:nn,conv2d_packing:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.act_type,p=e.hard_swish_offset,m=void 0===p?3:p,P=e.hard_swish_scale,v=void 0===P?6:P,x=e.hard_swish_threshold,T=void 0===x?6:x,F=l[0],b=void 0===F?1:F,y=l[1],E=void 0===y?1:y,w=c[0],V=void 0===w?0:w,A=c[1],O=void 0===A?0:A,C=g[0],R=void 0===C?1:C,S=g[1],I=void 0===S?1:S;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * "+b+" - "+V+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+R+";\n                continue;\n            }\n            int ox = x * "+E+" - "+O+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+I+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j += 1) {\n                    int c0 = (c / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += "+I+";\n            }\n            oy += "+R+";\n        }\n\n        "+(i?"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);":"")+"\n\n        if ("+h+") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if ("+("relu6"===d)+") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        else if ("+("hard_swish"===d)+") {\n            res = res * min(\n                max(vec4(0.0, 0.0, 0.0, 0.0), res + vec4("+m+")),\n                vec4("+T+")\n            ) / vec4("+v+");\n        }\n\n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPosPacking"],origin:["getValueFromTensorPosPacking"],bias:["getValueFromTensorPosPacking"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},conv2d_transpose:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.act_type,p=l[0],m=void 0===p?1:p,P=l[1],v=void 0===P?1:P,x=c[0],T=void 0===x?0:x,F=c[1],b=void 0===F?0:F;b=t.height_shape-b-1,T=t.width_shape-T-1;var y=g[0],E=void 0===y?1:y,w=g[1],V=void 0===w?1:w;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * "+a+" / "+r.channel+") * "+o.channel+";\n        int oy = y - "+b+";\n        const int groupLen = int("+o.channel+" / "+a+");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy < 0) {\n                oy += "+E+";\n                continue;\n            }\n            int ox = x - "+T+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n\n                if (ox < 0) {\n                    ox += "+V+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int("+v+")) == 0 && calMod(oy, int("+m+")) == 0) {\n                        temp_x = int(floor(float(ox) / float("+v+")));\n                        temp_y = int(floor(float(oy) / float("+m+")));\n                        if (temp_x < "+o.width_shape+" && temp_y < "+o.height_shape+") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / "+a+"),\n                                "+t.height_shape+"-1-fy,\n                                "+t.width_shape+"-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += "+V+";\n            }\n            oy += "+E+";\n        }\n        \n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n        \n        if ("+h+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===d)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        \n        setOutput(float(res));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},depthwise_conv2d:nn,conv2d_depthwise:nn,conv2d_elementwise_add:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.counter,s=e.active_function,a=e.groups,u=void 0===a?1:a,l=e.axis,f=e.strides,c=void 0===f?[]:f,_=e.paddings,g=void 0===_?[]:_,h=e.dilations,d=void 0===h?[]:h,p=e.multi_value,m=e.bias_value,P=c[0],v=void 0===P?1:P,x=c[1],T=void 0===x?1:x,F=g[0],b=void 0===F?0:F,y=g[1],E=void 0===y?0:y,w=d[0],V=void 0===w?1:w,A=d[1],O=void 0===A?1:A;return"\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float("+i.width_shape+");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos["+l+"];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+u+")) * "+t.channel+";\n        int oy = y * "+v+" - "+b+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+V+";\n                continue;\n            }\n            int ox = x * "+T+" - "+E+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+O+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += "+O+";\n            }\n            oy += "+V+";\n        }\n        setOutput("+s+"(res,  "+p+",  "+m+"));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]},behaviors:["mergeAttrs","checkIsMerge","setActiveFunc"]},pool2d:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.pooling_type,u=e.ksize,l=r[0],f=void 0===l?1:l,c=r[1],_=void 0===c?1:c,g=s[0],h=void 0===g?0:g,d=s[1],p=void 0===d?0:d,m=u[0],P=u[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if ("+a+" == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n        for (int fy = 0; fy < "+m+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+P+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+a+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+a+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_max:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=e.global_pooling,l=e.runtime,f=r[0],c=void 0===f?1:f,_=r[1],g=void 0===_?1:_,h=s[0],d=void 0===h?0:h,p=s[1],m=void 0===p?0:p,P=a[0],v=a[1],x=function(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}(o),T="",F="setOutput(float(res));";return 0===l&&!0===u&&(T="\n            if (curr > res) {\n                index = "+x[2]*x[3]+" * out_pos[1] + "+x[3]+" * oy + ox;\n            }\n        ",F="setOutput(float(index));"),"\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+g+" - "+m+";\n        for (int fy = 0; fy < "+P+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+v+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                "+T+"\n                res = max(res, curr);\n            }\n        }\n        "+F+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_winograd:{mainFunc:function(n,e){var o=n.origin,t=n.pool,r=e.strides,i=void 0===r?[]:r,s=e.paddings,a=void 0===s?[]:s,u=e.type_pool,l=i[0],f=void 0===l?1:l,c=i[1],_=void 0===c?1:c,g=a[0],h=void 0===g?0:g,d=a[1],p=void 0===d?0:d,m=o.height_shape,P=o.width_texture,v=o.height_texture;return"\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = "+m+" + "+o.offset_y+";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float("+P+"),\n            (float(g * height / 2 + y) + 0.5) / float("+v+"))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+u+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+u+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},elementwise_add:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+u/r+") * c + float("+u/s+") * o;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_mul:{mainFunc:function(n,e){var o=n.counter,t=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+o.height_texture/o.height_shape+") {\n            newN = int("+o.height_texture/o.height_shape+");\n        }\n        if (c >= "+o.channel+") {\n            newC = int("+(o.channel-1)+");\n        }\n        if (h >= "+o.height_shape+") {\n            newH = "+(o.height_shape-1)+";\n        }\n        if (w >= "+o.width_shape+") {\n            newW = "+(o.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l/a+") * o * float("+1/i+") * c;\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_div:{mainFunc:function(n,e){var o=n.counter,t=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+o.height_texture/o.height_shape+") {\n            newN = int("+o.height_texture/o.height_shape+");\n        }\n        if (c >= "+o.channel+") {\n            newC = int("+(o.channel-1)+");\n        }\n        if (h >= "+o.height_shape+") {\n            newH = "+(o.height_shape-1)+";\n        }\n        if (w >= "+o.width_shape+") {\n            newW = "+(o.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l+") * (float("+1/a+") * o / (float("+1/i+") * c));\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_pow:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = pow(float("+u/s+") * o, float("+u/r+") * c);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_sub:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+u/s+") * o - float("+u/r+") * c;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},mul:{mainFunc:function(n,e){var o=n.origin,t=n.counter,r=e.x_num_col_dims,i=e.y_num_col_dims,s=rn(o),a=rn(t),u=en(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=en(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+on("x1",l,f)+"\n    "+on("x2",c,_)+"\n    "+on("y1",d,p)+"\n    "+on("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+tn(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+tn(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+tn(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+tn(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+tn(f)+"(x1), "+tn(_)+"(x2));\n            ivec4 yPos = ivec4("+tn(p)+"(y1), "+tn(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},matmul:sn,matmul_v2:sn,fc:{mainFunc:function(n,e){var o=n.origin,t=n.weight,r=e.x_num_col_dims,i=e.y_num_col_dims,s=fn(o),a=fn(t),u=an(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=an(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+un("x1",l,f)+"\n    "+un("x2",c,_)+"\n    "+un("y1",d,p)+"\n    "+un("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+ln(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+ln(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+ln(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+ln(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+ln(f)+"(x1), "+ln(_)+"(x2));\n            ivec4 yPos = ivec4("+ln(p)+"(y1), "+ln(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    "},textureFuncConf:{weight:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]}},dropout:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if ("+("downgrade_in_infer"===e.dropout_implementation)+") {\n            o = o * (1.0 - float("+e.dropout_prob+"));\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},concat:{mainFunc:function(n,e){var o=e.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(e*t*r),r,t,e][o]})),r=t.map((function(n,e){return t.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+o+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            ":"\n            else if (oPos["+o+"] < "+n+") {\n                oPos["+o+"] = oPos["+o+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},concat_mul:{mainFunc:function(n,e){var o=e.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(e*t*r),r,t,e][o]})),r=t.map((function(n,e){return t.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+o+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }":"\n            else if (oPos["+o+"] < "+n+") {\n                oPos["+o+"] = oPos["+o+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},split:{mainFunc:function(n,e){var o=e.target_length,t=e.num,r=e.dim,i=e.sections;return"\n    // start函数\n    void main(void) {\n        int length = int("+(i&&i.length>1?i[0]:o/t)+");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos["+r+"] = oPos["+r+"] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},softmax:{mainFunc:function(n,e){var o=n.origin,t=e.axis,r=t;return(!t||t<0)&&(r=(t||-1)+4),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int("+o.total_shape+"/"+o.channel+"/"+o.height_shape+"/"+o.width_shape+");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if ("+r+" == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if ("+r+" == 1) {\n            for (int i = 0; i < "+o.channel+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < "+o.width_shape+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},batchnorm:{mainFunc:function(n,e){var o=n.bias,t=n.scale,r=n.mean,i=n.variance,s=e.epsilon;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float("+t.width_texture+") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float("+o.width_texture+") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float("+r.width_texture+")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float("+i.width_texture+") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + "+s+");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],scale:["getPixelsFromTexturePos"],bias:["getPixelsFromTexturePos"],mean:["getPixelsFromTexturePos"],variance:["getPixelsFromTexturePos"]}},reshape:cn,reshape2:cn,bilinear_interp:_n,transpose2:{mainFunc:function(n,e){var o=e.perm_arr,t=e.perm_size,r=o[0],i=o[1],s=o[2];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if ("+t+" == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if ("+t+" == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + "+r+") > 3 ? 3 : (2 + "+r+")],\n                oPos[(2 + "+i+") > 3 ? 3 : (2 + "+i+")]\n            );\n        }\n        else if ("+t+" == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + "+r+") > 3 ? 3 : (1 + "+r+")],\n                oPos[(1 + "+i+") > 3 ? 3 : (1 + "+i+")],\n                oPos[(1 + "+s+") > 3 ? 3 : (1 + "+s+")]\n            );\n        }\n        else if ("+t+" == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos["+r+"],\n                oPos["+i+"],\n                oPos["+s+"],\n                oPos["+o[3]+"]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizePerm"]},unpacked_2_packed:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},packed_2_unpacked:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},unsqueeze2:{mainFunc:function(n,e){var o=n.origin,t=e.axes,r=o.length_unformatted_shape,i=Array.isArray(t)?t:[t],s=4-r-i.length,a=i.map((function(n){return n+s})),u=[0,1,2,3].filter((function(n){return-1===a.indexOf(n)})).map((function(n){return"oPos["+n+"]"})),l=Array.from(new Array(a.length),(function(){return"0"}));return u.splice.apply(u,function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([0,0],l)),"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+u.join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},flatten_contiguous_range:{mainFunc:function(n,e){var o=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+o.channel+",\n            "+o.width_shape+",\n            "+o.height_shape+",\n            "+o.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},flatten2:cn,greater_than:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},reduce_sum:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+e.inputs_dim+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},where:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"],condition:["getValueFromTensorPos"]}},connect:{mainFunc:function(n,e){var o=n.out,t=o.total_shape,r=o.width_shape,i=o.height_shape,s=o.channel,a=g([t/(r*i*s),s,i,r]),u=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e].total_shape})),l=u.map((function(n,e){return u.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),f="";return l.forEach((function(n,e){f+=0===e?"\n            if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin_"+e+"(sumVal - "+l[e-1]+");\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * "+a[2]+" + oPos.a;\n        "+f+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},reduce_mean:{mainFunc:function(n,e){var o=e.inputs_dim;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+o+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float("+o+");\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},hard_swish:{mainFunc:function(n,e){var o=e.offset,t=void 0===o?3:o,r=e.scale,i=void 0===r?6:r,s=e.threshold;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float("+t+")), float("+(void 0===s?6:s)+")) / float("+i+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},nearest_interp:Pn,nearest_interp_v2:Pn,cast:{mainFunc:function(n,e){var o="";switch(e.out_dtype){case 0:o="\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);";break;case 1:case 2:case 3:o="\n            int res_int = int(o);\n            setOutput(float(res_int));";break;default:o="       \n            float res_float = o;\n            setOutput(res_float);"}return"\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        "+o+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},fill_constant_batch_size_like:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        float res = float("+e.value+");\n        setOutput(res);\n    }\n"}},rnn_matmul:{mainFunc:function(n,e){var o=n.weightlist_0,t=e.input_axis,r=e.state_axis,i=e.batch,s=e.reverse,a=void 0!==s&&s?i-t-1:t;return"\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if ("+(0===t)+") {\n            res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n        for (int j = 0; j < "+o.width_shape+"; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], "+r+", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"]}},rnn_hidden:{mainFunc:function(n,e){var o=e.state_axis,t=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+o+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_cell:{mainFunc:function(n,e){var o=e.state_axis,t=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+o+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_origin:{mainFunc:function(n,e){var o=n.weightlist_0,t=n.weightlist_1,r=e.state_axis;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < "+o.width_shape+"; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < "+t.width_shape+"; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, "+r+", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"],weightlist_1:["getValueFromTensorPos"],weightlist_2:["getValueFromTensorPos"],weightlist_3:["getValueFromTensorPos"]}},pool2d_avg:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=r[0],l=void 0===u?1:u,f=r[1],c=void 0===f?1:f,_=s[0],g=void 0===_?0:_,h=s[1],d=void 0===h?0:h,p=a[0],m=a[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+l+" - "+g+";\n        int ox_base = out_pos[3] * "+c+" - "+d+";\n        for (int fy = 0; fy < "+p+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+m+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float("+p+" * "+m+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["setPacked","setAdaptive","isGlobalPooling"]},prelu:pn("prelu"),relu6:pn("relu6"),leakyRelu:pn("leakyRelu"),scale:pn("scale"),sigmoid:pn("sigmoid"),relu:pn("relu"),hard_sigmoid:pn("hard_sigmoid"),pow:pn("pow"),sqrt:pn("sqrt"),tanh:pn("tanh"),exp:pn("exp"),squeeze2:mn,pad3d:{mainFunc:function(n,e){var o=n.origin,t=e.paddings,r=e.mode,i=e.value,s=function(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}(o),a={reflect:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = "+t[0]+" - oPos.a;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - (oPos.a - "+t[0]+" - "+s[3]+" + 1) - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = "+t[2]+" - oPos.b;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - (oPos.b - "+t[2]+" - "+s[2]+" + 1) - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",replicate:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = 0;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = 0;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",circular:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = int(mod(float("+t[0]+" + oPos.a - 1), float("+s[3]+")));\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = int(mod(float(oPos.a - "+t[0]+" - "+s[3]+"), float("+s[3]+")));\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = int(mod(float("+t[2]+" + oPos.b - 1), float("+s[2]+")));\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = int(mod(float(oPos.b - "+t[2]+" - "+s[2]+"), float("+s[2]+")));\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",constant:"",undefined:""};return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = "+(i||"0.0")+";\n        if (oPos.a - "+t[0]+" >= 0\n            && oPos.b - "+t[2]+" >= 0\n            && oPos.a - "+t[0]+" < "+s[3]+"\n            && oPos.b - "+t[2]+" < "+s[2]+"\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - "+t[2]+", oPos.a - "+t[0]+");\n        }\n        else {\n            "+a[r]+"\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},bilinear_interp_v2:gn,shuffle_channel:{mainFunc:function(n,e){var o=n.out,t=e.group,r=void 0===t?2:t,i=o.total_shape,s=o.height_shape,a=o.width_shape,u=o.channel,l=[1,0,2,3];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * "+a+"\n            + oPos.g * "+s+" * "+a+"\n            + oPos.r * "+u+" * "+a+" * "+s+";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+r+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos["+l[0]+"],\n            transpose_out_pos["+l[1]+"], transpose_out_pos["+l[2]+"], transpose_out_pos["+l[3]+"]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * "+a+"\n            + transpose_in_pos.g * "+s+" * "+a+"\n            + transpose_in_pos.r * "+u/r+" * "+a+" * "+s+";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            "+u+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},pack_out:{mainFunc:function(n,e){return"\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},nhwc_2_nchw:{mainFunc:function(n,e){var o=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * "+t.channel+"\n            + oPos.b * "+t.width_shape+" * "+t.channel+"\n            + oPos.g\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+o.channel+",\n            "+o.width_shape+",\n            "+o.height_shape+",\n            "+o.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},feedPost:{mainFunc:function(n,e){var o=n.out,t=e.mean,r=void 0===t?[0,0,0]:t,i=e.std,s=void 0===i?[1,1,1]:i,a=o.total_shape,u=o.height_shape,l=o.width_shape,f=o.channel;return"\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * "+l+"\n            + nhwcPos.g * "+u+" * "+l+"\n            + nhwcPos.r * "+f+" * "+l+" * "+u+";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+f+",\n            "+l+",\n            "+u+",\n            "+a+"\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float("+r[0]+")) / float("+s[0]+");\n        } else if (c == 1) {\n            res = (res - float("+r[1]+")) / float("+s[1]+");\n        } else if (c == 2) {\n            res = (res - float("+r[2]+")) / float("+s[2]+");\n        }\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]},commonFuncConf:["transferFromNHWCtoNCHW"]},imgFeed:{mainFunc:function(){return"\n    uniform vec2 u_scale;\n    uniform int u_keep_ratio;\n\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        // 支持模型不按比例拉伸\n        if (u_keep_ratio == 0) {\n            vec4 origin = TEXTURE2D(texture_origin, outCoord);\n            setPackedOutput(origin);\n            return;\n        }\n        float startX = (1.0 - u_scale.x) / 2.0;\n        float endX = startX + u_scale.x;\n        float startY = (1.0 - u_scale.y) / 2.0;\n        float endY = startY + u_scale.y;\n\n        if (outCoord.x >= startX && outCoord.x <= endX && outCoord.y >= startY && outCoord.y <= endY) {\n            vec2 newPos = (outCoord - vec2(startX, startY)) / u_scale;\n            vec4 origin = TEXTURE2D(texture_origin, newPos);\n            setPackedOutput(origin);\n        }\n        else {\n            setPackedOutput(vec4(1.0));\n        }\n    }\n    "},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(n,e){var o="decode_center_size"===e.code_type;return"\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        "+(o?"\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        ":"\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ")+"\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == "+(o?2:1)+") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        "+(o?"\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        ":"\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ")+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{targetbox:["getValueFromTensorPos"],priorbox:["getValueFromTensorPos"],priorboxvar:["getValueFromTensorPos"]},behaviors:[]},density_prior_box:xn,prior_box:Tn,stack:Fn,slice:bn},En=new $;!function(n,e,o){n&&(u.backend=n),e&&(u.backendInstance=e),o&&Object.keys(o).forEach((function(n){!function(n,e){var o=n.conf,t=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,l=n.behaviors,f=void 0===l?[]:l,c=u.backend+"_"+e;u.opRegistry.ops[c]||(u.opRegistry.ops[c]={name:e,conf:o,params:t,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:f})}(o[n],n)}))}("webgl",En,yn)}},e={};function o(t){if(e[t])return e[t].exports;var r=e[t]={exports:{}};return n[t](r,r.exports,o),r.exports}return o.d=(n,e)=>{for(var t in e)o.o(e,t)&&!o.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},o.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),o.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),o.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o(400)})()}));