/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paddlejs_mediapipe_camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @paddlejs-mediapipe/camera */ "./node_modules/@paddlejs-mediapipe/camera/lib/index.js");
/* harmony import */ var _paddlejs_mediapipe_camera__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_paddlejs_mediapipe_camera__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inference_engine/index_gpu */ "./inference_engine/index_gpu.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var GRACE_PERIOD_MS = 7000;
var SWITCH_MODEL_FPS_THRESHOLD = 40;
var queryParams = new URLSearchParams(window.location.search);
var autostart = queryParams.get('autostart');
var modelType = queryParams.get('model') || 'large';
var loadingDom = document.getElementById('isLoading');
var video = document.getElementById('video');
var videoToolDom = document.getElementById('video-tool');
var demoCanvas = document.getElementById('demo');
var backCanvas = document.createElement('canvas');
var confidenceDom = document.getElementById('confidence');
var backgroundCanvas = document.createElement('canvas');
backgroundCanvas.width = backCanvas.width;
backgroundCanvas.height = backCanvas.height;
var image = new Image();
image.src = './bgImgs/gt.jpeg';
image.onload = function () {
    var ctx = backgroundCanvas.getContext('2d');
    ctx.drawImage(image, 0, 0, backgroundCanvas.width, backgroundCanvas.height);
};
var modelTypeDom = document.getElementById('model-type');
modelTypeDom.innerHTML = "Model Type: " + modelType.toUpperCase();
var lastFrameTime = Date.now();
var frameCount = 0;
var cameraStartTime = -1;
var camera = null;
var confidence = parseFloat(queryParams.get('confidence')) || 0.5;
var step_size = parseFloat(queryParams.get('step-size')) || 0.05;
function setupCamera() {
    camera = new _paddlejs_mediapipe_camera__WEBPACK_IMPORTED_MODULE_0___default.a(video, {
        mirror: true,
        enableOnInactiveState: true,
        onFrame: onCameraFrame
    });
    if (autostart === 'true') {
        camera.start();
        cameraStartTime = Date.now();
    }
}
function onCameraFrame() {
    return __awaiter(this, void 0, void 0, function () {
        var videoCanvas, videoCanvasCtx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    videoCanvas = document.createElement('canvas');
                    videoCanvasCtx = videoCanvas.getContext('2d');
                    videoCanvas.width = video.width;
                    videoCanvas.height = video.height;
                    if (video.paused) {
                        demoCanvas.getContext('2d').drawImage(videoCanvas, 0, 0, videoCanvas.width, videoCanvas.height);
                        console.log('Video is paused.');
                    }
                    else {
                        videoCanvasCtx.drawImage(video, 0, 0, video.width, video.height);
                        _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["drawHumanSeg"](videoCanvas, demoCanvas, backgroundCanvas);
                    }
                    return [4, updateFPS()];
                case 1:
                    _a.sent();
                    return [2];
            }
        });
    });
}
function adaptiveModelSwitching(fps) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (cameraStartTime > 0 &&
                        (Date.now() - cameraStartTime) > GRACE_PERIOD_MS &&
                        fps < SWITCH_MODEL_FPS_THRESHOLD) {
                        confidence /= 2;
                        step_size /= 2;
                        console.log(step_size);
                    }
                    else if (fps >= SWITCH_MODEL_FPS_THRESHOLD) {
                        confidence += step_size;
                        confidence = Math.min(confidence, 1);
                    }
                    if (!(modelType !== 'small' && confidence < 0.5)) return [3, 2];
                    return [4, switchToModel('small')];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    if (!(modelType !== 'large' && confidence > 0.8)) return [3, 4];
                    return [4, switchToModel('large')];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    confidenceDom.innerHTML = "Confidence: " + confidence.toFixed(2);
                    return [2];
            }
        });
    });
}
function updateFPS() {
    return __awaiter(this, void 0, void 0, function () {
        var fpsDisplay, now, duration, fps;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fpsDisplay = document.getElementById('fps');
                    if (video.paused) {
                        fpsDisplay.innerHTML = "FPS: 0";
                        return [2];
                    }
                    frameCount++;
                    now = Date.now();
                    duration = now - lastFrameTime;
                    if (!(duration > 1000)) return [3, 2];
                    fps = Math.round((frameCount * 1000) / duration);
                    fpsDisplay.innerHTML = "FPS: " + fps.toString();
                    if (fps < SWITCH_MODEL_FPS_THRESHOLD) {
                        fpsDisplay.style.color = 'red';
                    }
                    else if (fps < 50) {
                        fpsDisplay.style.color = 'orange';
                    }
                    else {
                        fpsDisplay.style.color = 'green';
                    }
                    return [4, adaptiveModelSwitching(fps)];
                case 1:
                    _a.sent();
                    frameCount = 0;
                    lastFrameTime = now;
                    _a.label = 2;
                case 2: return [2];
            }
        });
    });
}
function switchToModel(size) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    camera.pause();
                    return [4, _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["swapModel"]({
                            needPreheat: true,
                            modelType: size,
                        })];
                case 1:
                    _a.sent();
                    cameraStartTime = Date.now();
                    modelTypeDom.innerHTML = "Model Type: " + size.toUpperCase();
                    modelType = size;
                    camera.start();
                    return [2];
            }
        });
    });
}
function loadModel() {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = modelType;
                    switch (_a) {
                        case 'large': return [3, 1];
                        case 'medium': return [3, 3];
                        case 'small': return [3, 5];
                    }
                    return [3, 7];
                case 1: return [4, _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["load"]({
                        needPreheat: true,
                        modelType: 'large',
                    })];
                case 2:
                    _b.sent();
                    return [3, 9];
                case 3: return [4, _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["load"]({
                        needPreheat: true,
                        modelType: 'medium',
                    })];
                case 4:
                    _b.sent();
                    return [3, 9];
                case 5: return [4, _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["load"]({
                        needPreheat: true,
                        modelType: 'small',
                    })];
                case 6:
                    _b.sent();
                    return [3, 9];
                case 7: return [4, _inference_engine_index_gpu__WEBPACK_IMPORTED_MODULE_1__["load"]()];
                case 8:
                    _b.sent();
                    return [3, 9];
                case 9:
                    console.log("Loaded model: " + modelType);
                    setupCamera();
                    return [2];
            }
        });
    });
}
video && video.addEventListener('loadeddata', function () {
    loadingDom && loadingDom.remove();
});
videoToolDom.addEventListener('click', function (e) {
    var target = e.target;
    if (target.id === 'start') {
        camera.start();
        cameraStartTime = Date.now();
    }
    if (target.id === 'pause') {
        camera.pause();
    }
});
loadModel();


/***/ }),

/***/ "./inference_engine/customOp/segImg.ts":
/*!*********************************************!*\
  !*** ./inference_engine/customOp/segImg.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function mainFunc(_a) {
    var out = _a.out;
    var THRESHHOLD = 0.2;
    return "\n\n    #define SIGMA SIGMA 3.0\n    #define BLUR_MSIZE 8\n    #define MSIZE 3\n    #define kernelSize 5.0\n    #define weight 1.0\n\n    uniform int type; // 0: blurBackground 1: drawHumanseg 2: drawMask\n\n    void main() {\n        vec2 outCoord = vCoord.xy;\n       \n        outCoord.y = 1.0 - vCoord.y;\n\n        vec2 sourceTextureSize = vec2(" + out.width_shape + ", " + out.height_shape + ");\n        vec2 sourceTexelSize = 1.0 / sourceTextureSize;\n\n        float kernel[MSIZE]; // 3\n        kernel[0] = 0.12579369017522166;\n        kernel[1] = 0.13298;\n        kernel[2] = 0.12579369017522166;\n\n        float origin_alpha = 1.0 - TEXTURE2D(texture_origin, vec2(outCoord.x, outCoord.y) / 2.0).r;\n        vec4 counter = TEXTURE2D(texture_counter, outCoord.xy);\n        vec4 res = vec4(0.0);\n\n        if (type == 0) {\n            // Simple Cheap Box Blur \n            float pixelSizeX = 1.0 / float(" + out.width_shape + ");\n            float pixelSizeY = 1.0 / float(" + out.height_shape + "); \n    \n            // Horizontal Blur\n            vec4 accumulation = vec4(0);\n            float weightsum = 0.0;\n            for (float i = -kernelSize; i <= kernelSize; i++){\n                accumulation += TEXTURE2D(texture_counter, outCoord.xy + vec2(i * pixelSizeX, 0.0)) * weight;\n                weightsum += weight;\n            }\n            // Vertical Blur\n            for (float i = -kernelSize; i <= kernelSize; i++){\n                accumulation += TEXTURE2D(texture_counter, outCoord.xy + vec2(0.0, i * pixelSizeY)) * weight;\n                weightsum += weight;\n            }\n            \n            res = accumulation / weightsum;\n            if (origin_alpha > " + THRESHHOLD + ") {\n                res = counter;\n            }\n        }\n        else if (type == 1) {\n            res = counter;\n            res.a = origin_alpha;\n        }\n        else if (type == 2) {\n            if (origin_alpha > " + THRESHHOLD + ") {\n                res = vec4(1.0);\n                res.a = origin_alpha;\n            }\n        }\n                \n        setPackedOutput(res);\n    }\n    ";
}
/* harmony default export */ __webpack_exports__["default"] = ({
    mainFunc: mainFunc,
    textureFuncConf: {
        origin: [],
        counter: []
    }
});


/***/ }),

/***/ "./inference_engine/customTransformer/appendCustomOpToNN.ts":
/*!******************************************************************!*\
  !*** ./inference_engine/customTransformer/appendCustomOpToNN.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @paddlejs/paddlejs-core */ "./node_modules/@paddlejs/paddlejs-core/lib/index.js");
/* harmony import */ var _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var IMG_ORIGIN = 'image';
var FINAL_PACK_OP_NAME = 'fetch_pack';
var DEFAULT_WIDTH = 500;
var DEFAULT_HEIGHT = 280;
var DealOrigin = (function (_super) {
    __extends(DealOrigin, _super);
    function DealOrigin(width, height) {
        var _this = _super.call(this, 'DealOrigin') || this;
        _this.width = width || DEFAULT_WIDTH;
        _this.height = height || DEFAULT_HEIGHT;
        return _this;
    }
    DealOrigin.prototype.transform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!_paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].get('webgl_gpu_pipeline')) {
            return;
        }
        var ops = args[0], vars = args[1];
        var fetchOp = ops.find(function (item) { return item.type === 'fetch'; });
        var inputName = fetchOp.inputs.X[0];
        var segImgOp = {
            attrs: {},
            inputs: {
                X: [inputName],
                Y: [IMG_ORIGIN]
            },
            outputs: {
                Out: [FINAL_PACK_OP_NAME]
            },
            type: 'segImg',
            isPacked: true,
            bufferType: _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["interfaces"].BufferType.ColorBuffer,
            uniform: {
                type: {
                    type: '1i',
                    value: 0
                }
            }
        };
        var packOutVar = {
            name: FINAL_PACK_OP_NAME,
            shape: [1, 1, this.height, this.width],
            persistable: false
        };
        fetchOp.inputs.X = [FINAL_PACK_OP_NAME];
        ops.push(segImgOp);
        if (vars instanceof Array) {
            vars.push.apply(vars, [packOutVar]);
        }
        else {
            vars[FINAL_PACK_OP_NAME] = packOutVar;
        }
    };
    return DealOrigin;
}(_paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["Transformer"]));
/* harmony default export */ __webpack_exports__["default"] = (DealOrigin);


/***/ }),

/***/ "./inference_engine/index_gpu.ts":
/*!***************************************!*\
  !*** ./inference_engine/index_gpu.ts ***!
  \***************************************/
/*! exports provided: swapModel, load, preheat, drawHumanSeg, blurBackground, drawMask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swapModel", function() { return swapModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preheat", function() { return preheat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawHumanSeg", function() { return drawHumanSeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blurBackground", function() { return blurBackground; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawMask", function() { return drawMask; });
/* harmony import */ var _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @paddlejs/paddlejs-core */ "./node_modules/@paddlejs/paddlejs-core/lib/index.js");
/* harmony import */ var _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _paddlejs_paddlejs_backend_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @paddlejs/paddlejs-backend-webgl */ "./node_modules/@paddlejs/paddlejs-backend-webgl/lib/index.js");
/* harmony import */ var _paddlejs_paddlejs_backend_webgl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_paddlejs_paddlejs_backend_webgl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _customOp_segImg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./customOp/segImg */ "./inference_engine/customOp/segImg.ts");
/* harmony import */ var _customTransformer_appendCustomOpToNN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./customTransformer/appendCustomOpToNN */ "./inference_engine/customTransformer/appendCustomOpToNN.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var runner = null;
var WIDTH = 398;
var HEIGHT = 224;
function registerCustomOp() {
    Object(_paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["registerOp"])(_customOp_segImg__WEBPACK_IMPORTED_MODULE_2__["default"], 'segImg');
}
registerCustomOp();
var WEBGL_ATTRIBUTES = Object.assign({}, _paddlejs_paddlejs_backend_webgl__WEBPACK_IMPORTED_MODULE_1__["GLHelper"].WEBGL_ATTRIBUTES, {
    alpha: true
});
function createWebglContext(canvas) {
    var gl = canvas.getContext('webgl2', WEBGL_ATTRIBUTES);
    if (gl) {
        _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].set('webglVersion', 2);
    }
    else {
        _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].set('webglVersion', 1);
        gl = (canvas.getContext('webgl', WEBGL_ATTRIBUTES)
            || canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));
    }
    return gl;
}
var renderCanvas = document.createElement('canvas');
renderCanvas.width = 500;
renderCanvas.height = 280;
var gl = createWebglContext(renderCanvas);
var segImgOp = null;
function swapModel(options) {
    if (options === void 0) { options = {
        needPreheat: true,
        modelType: 'large',
        canvasWidth: 500,
        canvasHeight: 280
    }; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    runner.stopPredict();
                    runner = null;
                    segImgOp = null;
                    renderCanvas.remove();
                    renderCanvas = document.createElement('canvas');
                    renderCanvas.width = 500;
                    renderCanvas.height = 280;
                    gl = createWebglContext(renderCanvas);
                    return [4, load(options)];
                case 1:
                    _a.sent();
                    return [2];
            }
        });
    });
}
function load(options) {
    if (options === void 0) { options = {
        needPreheat: true,
        modelType: 'large',
        canvasWidth: 500,
        canvasHeight: 280
    }; }
    return __awaiter(this, void 0, void 0, function () {
        var largeModelpath, mdediumModelPath, smallModelPath, modelPath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    largeModelpath = 'https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_398x224_fuse_activation/model.json';
                    mdediumModelPath = 'https://paddlejs.cdn.bcebos.com/models/humansegv2/model.json';
                    smallModelPath = 'https://paddlejs.bj.bcebos.com/models/fuse/humanseg/humanseg_288x160_fuse_activation/model.json';
                    modelPath = options.modelType === 'large' ? largeModelpath : options.modelType === 'medium' ? mdediumModelPath : smallModelPath;
                    runner = new _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["Runner"]({
                        modelPath: modelPath,
                        needPreheat: options.needPreheat !== undefined ? options.needPreheat : true,
                        feedShape: {
                            fw: WIDTH,
                            fh: HEIGHT
                        },
                        fill: '#fff',
                        mean: [0.5, 0.5, 0.5],
                        std: [0.5, 0.5, 0.5],
                        plugins: {
                            preTransforms: [new _customTransformer_appendCustomOpToNN__WEBPACK_IMPORTED_MODULE_3__["default"](options.canvasWidth, options.canvasHeight)]
                        }
                    });
                    _paddlejs_paddlejs_backend_webgl__WEBPACK_IMPORTED_MODULE_1__["GLHelper"].setWebGLRenderingContext(gl);
                    _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].set('webgl_pack_channel', true);
                    _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].set('webgl_gpu_pipeline', true);
                    _paddlejs_paddlejs_core__WEBPACK_IMPORTED_MODULE_0__["env"].set('webgl_force_half_float_texture', true);
                    return [4, runner.init()];
                case 1:
                    _a.sent();
                    return [2];
            }
        });
    });
}
function preheat() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, runner.preheat()];
                case 1: return [2, _a.sent()];
            }
        });
    });
}
function drawHumanSeg(input, canvas, back) {
    return __awaiter(this, void 0, void 0, function () {
        var backgroundSize, destCtx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!segImgOp) {
                        segImgOp = runner.weightMap[runner.weightMap.length - 1].opData;
                    }
                    segImgOp.uniform.type.value = 1;
                    return [4, runner.predict(input)];
                case 1:
                    _a.sent();
                    backgroundSize = genBackgroundSize(input);
                    canvas.width = input.width;
                    canvas.height = input.height;
                    destCtx = canvas.getContext('2d');
                    if (back) {
                        destCtx.drawImage(back, -backgroundSize.bx, -backgroundSize.by, backgroundSize.bw, backgroundSize.bh);
                    }
                    destCtx.drawImage(gl.canvas, -backgroundSize.bx, -backgroundSize.by, backgroundSize.bw, backgroundSize.bh);
                    return [2];
            }
        });
    });
}
function blurBackground(input, canvas) {
    return __awaiter(this, void 0, void 0, function () {
        var backgroundSize, destCtx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!segImgOp) {
                        segImgOp = runner.weightMap[runner.weightMap.length - 1].opData;
                    }
                    segImgOp.uniform.type.value = 0;
                    return [4, runner.predict(input)];
                case 1:
                    _a.sent();
                    canvas.width = input.width;
                    canvas.height = input.height;
                    backgroundSize = genBackgroundSize(input);
                    destCtx = canvas.getContext('2d');
                    destCtx.drawImage(gl.canvas, -backgroundSize.bx, -backgroundSize.by, backgroundSize.bw, backgroundSize.bh);
                    return [2];
            }
        });
    });
}
function drawMask(input, canvas, back) {
    return __awaiter(this, void 0, void 0, function () {
        var backgroundSize, destCtx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!segImgOp) {
                        segImgOp = runner.weightMap[runner.weightMap.length - 1].opData;
                    }
                    segImgOp.uniform.type.value = 2;
                    return [4, runner.predict(input)];
                case 1:
                    _a.sent();
                    canvas.width = input.width;
                    canvas.height = input.height;
                    backgroundSize = genBackgroundSize(input);
                    destCtx = canvas.getContext('2d');
                    destCtx.drawImage(back, -backgroundSize.bx, -backgroundSize.by, backgroundSize.bw, backgroundSize.bh);
                    destCtx.drawImage(gl.canvas, -backgroundSize.bx, -backgroundSize.by, backgroundSize.bw, backgroundSize.bh);
                    return [2];
            }
        });
    });
}
function genBackgroundSize(inputElement) {
    var sw = WIDTH;
    var sh = HEIGHT;
    var ratio = sw / sh;
    var inputWidth = inputElement.naturalWidth || inputElement.width;
    var inputHeight = inputElement.naturalHeight || inputElement.height;
    var x = 0;
    var y = 0;
    var bx = 0;
    var by = 0;
    var bh = inputHeight;
    var bw = inputWidth;
    var origin_ratio = inputWidth / inputHeight;
    if (ratio / origin_ratio >= 1) {
        sw = sh * origin_ratio;
        x = Math.floor((WIDTH - sw) / 2);
        bw = bh * ratio;
        bx = Math.floor((bw - inputWidth) / 2);
    }
    else {
        sh = sw / origin_ratio;
        y = Math.floor((HEIGHT - sh) / 2);
        bh = bw / ratio;
        by = Math.floor((bh - inputHeight) / 2);
    }
    return {
        x: x,
        y: y,
        sw: sw,
        sh: sh,
        bx: bx,
        by: by,
        bw: bw,
        bh: bh
    };
}


/***/ }),

/***/ "./node_modules/@paddlejs-mediapipe/camera/lib/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@paddlejs-mediapipe/camera/lib/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(self,(function(){return(()=>{"use strict";var t={607:(t,e,i)=>{i.r(e),i.d(e,{default:()=>o});const o=function(){function t(t,e){void 0===e&&(e={}),this.noop=function(){},this.defaultOption={mirror:!1,targetCanvas:null,onSuccess:this.noop,onError:this.noop,onNotSupported:this.noop,onFrame:this.noop,switchError:this.noop,videoLoaded:this.noop},this.video=t,this.options=Object.assign({},this.defaultOption,e),this.currentMode="user",this.initVideoStream()}return t.prototype.initVideoStream=function(){var t=navigator.userAgent;this.isIOS=!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),this.video.width=this.options.width||this.video.clientWidth,this.video.height=this.options.height||this.video.clientHeight,this.enumerateDevices()},t.prototype.handleStream=function(){var t=this,e={deviceId:{exact:this.videoDeviceId},facingMode:this.currentMode,width:this.video.width,height:this.video.height};navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({video:e}).then((function(e){t.stream=e,t.streamCallback()})).catch(this.options.onError):(navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia,navigator.getUserMedia?navigator.getUserMedia({video:e},(function(e){t.stream=e,t.streamCallback()}),this.options.onError):this.options.onNotSupported())},t.prototype.enumerateDevices=function(){var t=this;navigator.mediaDevices&&navigator.mediaDevices.enumerateDevices?navigator.mediaDevices.enumerateDevices().then((function(e){var i=[];e.forEach((function(t){"videoinput"===t.kind&&i.push(t.deviceId)})),t.videoDevices=i,t.videoDevices.length<2&&!t.isIOS&&t.options.switchError&&t.options.switchError(),t.videoDeviceId=t.videoDevices[0],t.handleStream()})).catch((function(e){t.options.onNotSupported&&t.options.onNotSupported(),console.error(e.name+": "+e.message)})):this.options.onNotSupported&&this.options.onNotSupported()},t.prototype.streamCallback=function(){var t=this;this.options.onSuccess();var e=window.URL||window.webkitURL||window.mozURL||window.msURL;if("srcObject"in this.video)try{this.video.srcObject=this.stream}catch(t){this.video.src=e.createObjectURL(this.stream)||this.stream}this.video.addEventListener("loadeddata",(function(){t.options.height?t.video.width=t.video.clientWidth:t.video.height=t.video.clientHeight,t.options.videoLoaded&&t.options.videoLoaded(),t.initCanvas()}))},t.prototype.stopMediaTracks=function(){var t,e;null===(e=null===(t=this.stream)||void 0===t?void 0:t.getTracks())||void 0===e||e.forEach((function(t){t.stop()}))},t.prototype.initCanvas=function(){this.options.targetCanvas&&(this.canvas=this.options.targetCanvas,this.canvas.width=this.video.width,this.canvas.height=this.video.height,this.context=this.canvas.getContext("2d"),this.options.mirror&&(this.context.translate(this.canvas.width,0),this.context.scale(-1,1)))},t.prototype.videoRequestAnimationFrame=function(){var t=this,e=function(){t.context&&t.context.drawImage(t.video,0,0,t.video.width,t.video.height),t.options.onFrame(t.video),t.requestAnimationId=requestAnimationFrame(e)};e()},t.prototype.start=function(){this.video&&this.video.play(),this.requestAnimationId||this.videoRequestAnimationFrame()},t.prototype.pause=function(){this.video&&this.video.pause(),this.canvas&&this.requestAnimationId&&(cancelAnimationFrame(this.requestAnimationId),this.requestAnimationId=null)},t.prototype.switchCameras=function(){if(this.isIOS||this.videoDevices&&!(this.videoDevices.length<2)){this.stopMediaTracks();var t=this.currentMode;this.currentMode="user"===t?"environment":"user";var e=this.videoDeviceId;this.videoDeviceId=e===this.videoDevices[0]?this.videoDevices[1]:this.videoDevices[0],this.handleStream()}},t}()}},e={};function i(o){if(e[o])return e[o].exports;var s=e[o]={exports:{}};return t[o](s,s.exports,i),s.exports}return i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i(607)})()}));

/***/ }),

/***/ "./node_modules/@paddlejs/paddlejs-backend-webgl/lib/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@paddlejs/paddlejs-backend-webgl/lib/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(n,e){ true?module.exports=e():undefined}(this,(function(){return(()=>{"use strict";var n={400:(n,e,o)=>{o.r(e),o.d(e,{GLHelper:()=>F,glInstance:()=>En,ops:()=>yn,webgl_types:()=>t});var t={};o.r(t),o.d(t,{UniformType:()=>c});var r={};o.r(r),o.d(r,{exp_func:()=>j,hardSigmoid:()=>B,leakyRelu:()=>S,pow_func:()=>D,prelu:()=>C,relu6:()=>R,scale:()=>I,scaleWidthBias:()=>L,sigmoid:()=>k,sqrt:()=>M,tanh_func:()=>U,transferFromNHWCtoNCHW:()=>O});var i={};function s(){var n;if("undefined"!=typeof window)n=window;else if(void 0!==o.g)n=o.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}return n}function a(n,e){var o=s();return o[n]||(o[n]=e),o[n]}o.r(i),o.d(i,{getPixelsFromTexturePos:()=>H,getSamplerCode:()=>z,getTensorPosFromArrayIndex:()=>G,getValueFromTensorPos:()=>N,getValueFromTensorPosPacking:()=>X,moveTexture2PosToReal:()=>W});var u={opRegistry:{ops:{}},backend:"",backendInstance:null};u=a("GLOBALS",u);var l=s();l.ImageBitmap||(l.ImageBitmap=function(){});const f=a("env",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,e){this.ENV[n]=e},n.prototype.get=function(n){return this.ENV[n]},n}()));var c;!function(n){n.uniform1f="1f",n.uniform1fv="1fv",n.uniform1i="1i",n.uniform1iv="1iv",n.uniform2f="2f",n.uniform2fv="2fv",n.uniform2i="2i",n.uniform2iv="2iv",n.uniform3f="3f",n.uniform3fv="3fv",n.uniform3i="3i",n.uniform3iv="3iv",n.uniform4f="4f",n.uniform4fv="4fv",n.uniform4i="4i",n.uniform4iv="4iv"}(c||(c={}));var _;function g(n){for(var e=n.length,o=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(n),t=[];e>1;)o.splice(0,1),t.push(o.reduce((function(n,e){return n*e}))),e--;return t}function h(n,e){if(1===n.length)return"float "+e+" = float("+n[0]+");";for(var o=n.length,t="\n        vec"+o+" "+e+" = vec"+o+"(\n    ",r=0;r<o;r++)t+="float("+n[r]+"),";return t.slice(0,-1)+");"}function d(n,e,o){if(0===n.length)return"";if(2===f.get("webglVersion"))return n.reduce((function(e,t,r){return e+(r<n.length-1?o+"("+t+"), ":o+"("+t+"));")}),o+" "+e+"[] = "+o+"[](");var t=n.reduce((function(n,t,r){return n+"\n            "+e+"["+r+"] = "+o+"("+t+");"}),"");return"\n        "+o+" "+e+"["+n.length+"];\n        "+t+"\n    "}function p(n,e,o){if(0===n.length)return"";var t=n.reduce((function(n,e,t){return n+(0===t?"\n            "+o+" res = "+o+"(0);\n            if (index == "+t+") {\n                res = arr["+t+"];\n            }":"\n            else if (index == "+t+") {\n                res = arr["+t+"];\n            }")}),"");return"\n    "+o+" getValueFromArrByIndex_"+e+"("+o+"["+n.length+"] arr, int index) {\n        "+(2===f.get("webglVersion")?o+" res = arr[index];":t)+"\n        return res;\n    }\n    "}!function(n){n.INT_TYPE="int",n.FLOAT_TYPE="float"}(_||(_={}));var m,P;!function(n){n[n.VS_SHADER=0]="VS_SHADER",n[n.FS_SHADER=1]="FS_SHADER"}(m||(m={})),function(n){n[n.FLOAT_VEC2=35664]="FLOAT_VEC2",n[n.FLOAT_VEC3=35665]="FLOAT_VEC3",n[n.FLOAT_VEC4=35666]="FLOAT_VEC4",n[n.INT_VEC2=35667]="INT_VEC2",n[n.INT_VEC3=35668]="INT_VEC3",n[n.INT_VEC4=35669]="INT_VEC4",n[n.BOOL=35670]="BOOL",n[n.BOOL_VEC2=35671]="BOOL_VEC2",n[n.BOOL_VEC3=35672]="BOOL_VEC3",n[n.BOOL_VEC4=35673]="BOOL_VEC4",n[n.FLOAT_MAT2=35674]="FLOAT_MAT2",n[n.FLOAT_MAT3=35675]="FLOAT_MAT3",n[n.FLOAT_MAT4=35676]="FLOAT_MAT4",n[n.SAMPLER_2D=35677]="SAMPLER_2D",n[n.SAMPLER_CUBE=35678]="SAMPLER_CUBE",n[n.FLOAT=5126]="FLOAT",n[n.INT=5124]="INT"}(P||(P={}));var v,x=function(n,e,o){this.size=n,this.type=e,this.location=o},T=function(n,e,o){this.size=n,this.type=e,this.location=o},F=function(){function n(){}return n.getWebglVersion=function(){return f.get("webglVersion")},n.createCanvas=function(){return f.get("canvas")||document&&document.createElement("canvas")},n.setWebglVersion=function(n){f.set("webglVersion",n)},n.setWebGLRenderingContext=function(n){return this.gl=n,n},n.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},n.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var n=this.createCanvas();if(!n)return null;n.addEventListener&&n.addEventListener("webglcontextlost",(function(n){throw n.preventDefault(),Error("webgl context is lost~")}),!1);var e=n.getContext("webgl2",this.WEBGL_ATTRIBUTES);return e?f.set("webglVersion",2):(f.set("webglVersion",1),e=n.getContext("webgl",this.WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",this.WEBGL_ATTRIBUTES)),e},n.printStates=function(n){console.log("1. isBlendEnable = "+n.isEnabled(n.BLEND)),console.log("2. isCullFaceEnable = "+n.isEnabled(n.CULL_FACE)),console.log("3. isDepthTestEnable = "+n.isEnabled(n.DEPTH_TEST)),console.log("4. isDitherEnable = "+n.isEnabled(n.DITHER)),console.log("5. isPolygonOffsetFillEnable = "+n.isEnabled(n.POLYGON_OFFSET_FILL)),console.log("6. isSampleAlphtToCoverageEnable = "+n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)),console.log("7. isSampleCoverageEnable = "+n.isEnabled(n.SAMPLE_COVERAGE)),console.log("8. isScissorTestEnable = "+n.isEnabled(n.SCISSOR_TEST)),console.log("9. isStencilTestEnable = "+n.isEnabled(n.STENCIL_TEST))},n.printWebGLInfo=function(n){console.log("renderer = "+n.getParameter(n.RENDERER)),console.log("version = "+n.getParameter(n.VERSION)),console.log("vendor = "+n.getParameter(n.VENDOR)),console.log("glsl version = "+n.getParameter(n.SHADING_LANGUAGE_VERSION))},n.printWebGLTextureInfo=function(n){console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_SIZE = ",n.getParameter(n.MAX_TEXTURE_SIZE)),console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE))},n.triggerContextLostEvent=function(n){var e=n.getExtension("WEBGL_lose_context");null!==e&&e.loseContext()},n.checkGLError=function(n){var e=n.getError();return 0!==e&&(console.log("WebGL Error NO: ",e),!0)},n.setDefaultState=function(n){n.clearColor(0,0,0,0),n.clearDepth(1),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.enable(n.SCISSOR_TEST)},n.setViewport=function(n,e){n.viewport(e[0],e[1],e[2],e[3])},n.initShader=function(n,e,o){var t=this.createShader(n,e);return this.compileShader(n,o,t),t},n.createShader=function(n,e){var o;if(null===(o=e===m.VS_SHADER?n.createShader(n.VERTEX_SHADER):n.createShader(n.FRAGMENT_SHADER)))throw new Error("WebGLShader创建失败！");return o},n.compileShader=function(n,e,o){return n.shaderSource(o,e),n.compileShader(o),!1!==n.getShaderParameter(o,n.COMPILE_STATUS)||(console.error(n.getShaderInfoLog(o)),n.deleteShader(o),!1)},n.createProgram=function(n){var e=n.createProgram();if(null===e)throw new Error("WebGLProgram创建失败！");return e},n.linkProgram=function(n,e,o,t,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),n.attachShader(e,o),n.attachShader(e,t),null!==r&&r(n,e),n.linkProgram(e),!1===n.getProgramParameter(e,n.LINK_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(o),n.deleteShader(t),n.deleteProgram(e),!1):(n.validateProgram(e),!1===n.getProgramParameter(e,n.VALIDATE_STATUS)?(console.error(n.getProgramInfoLog(e)),n.deleteShader(o),n.deleteShader(t),n.deleteProgram(e),!1):(null!==i&&i(n,e),!0))},n.getProgramActiveAttribs=function(n,e,o){for(var t=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES),r=0;r<t;r++){var i=n.getActiveAttrib(e,r);i&&(o[i.name]=new T(i.size,i.type,n.getAttribLocation(e,i.name)))}},n.getProgramAtciveUniforms=function(n,e,o){for(var t=n.getProgramParameter(e,n.ACTIVE_UNIFORMS),r=0;r<t;r++){var i=n.getActiveUniform(e,r);if(i){var s=n.getUniformLocation(e,i.name);null!==s&&(o[i.name]=new x(i.size,i.type,s))}}},n.createBuffer=function(n){var e=n.createBuffer();if(null===e)throw new Error("WebGLBuffer创建失败！");return e},n.getColorBufferData=function(n){var e=new Uint8Array(n.drawingBufferWidth*n.drawingBufferHeight*4);return n.readPixels(0,0,n.drawingBufferWidth,n.drawingBufferHeight,n.RGBA,n.UNSIGNED_BYTE,e),e},n.setUniformParam=function(n,e,o,t){switch(o){case c.uniform1f:n.uniform1f(e,t);break;case c.uniform1fv:n.uniform1fv(e,t);break;case c.uniform1i:n.uniform1i(e,t);break;case c.uniform1iv:n.uniform1iv(e,t);break;case c.uniform2f:n.uniform2f(e,t[0],t[1]);break;case c.uniform2fv:n.uniform2fv(e,t);break;case c.uniform2i:n.uniform2i(e,t[0],t[1]);break;case c.uniform2iv:n.uniform2iv(e,t);break;case c.uniform3f:n.uniform3f(e,t[0],t[1],t[2]);break;case c.uniform3fv:n.uniform3fv(e,t);break;case c.uniform3i:n.uniform3i(e,t[0],t[1],t[2]);break;case c.uniform3iv:n.uniform3iv(e,t);break;case c.uniform4f:n.uniform4f(e,t[0],t[1],t[2],t[3]);break;case c.uniform4fv:n.uniform4fv(e,t);break;case c.uniform4i:n.uniform4i(e,t[0],t[1],t[2],t[3]);break;case c.uniform4iv:n.uniform4iv(e,t);break;default:console.error("["+o+"]: unknown uniform type")}},n.genTextureInfoFromTensorShape=function(n,e){var o=n||4096,t=e.shape,r=void 0===t?[]:t,i=r[0],s=r[1],a=r[2],u=r[3];if(i*a<=o&&s*u<=o)e.shape_texture=[i*a,s*u];else{var l=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(r).sort((function(n,e){return n-e})),c=l[0],_=l[1],g=l[2],h=c*l[3],d=_*g;if(h>o||d>o){var p=[h,d].sort((function(n,e){return n-e})),m=p[0],P=p[1],v=function(n,e){var o=e;if(n%o==0)return o;for(;o<n&&n%o!=0;)o++;return o}(P,Math.ceil(P/o));if(h=m*v,d=Math.ceil(P/v),f.get("debug")&&console.error("大小超限",r,[d,h]),h>o||d>o)throw new Error("Requested texture size ["+h+"x"+d+"] greater than WebGL maximum on this browser / GPU ["+o+"x"+o+"].")}e.shape_texture=[d,h]}},n.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"high-performance"},n.gl=null,n}();!function(n){n[n.GL_REPEAT=0]="GL_REPEAT",n[n.GL_MIRRORED_REPEAT=1]="GL_MIRRORED_REPEAT",n[n.GL_CLAMP_TO_EDGE=2]="GL_CLAMP_TO_EDGE"}(v||(v={}));var b=function(){function n(){}return n.getTextureConfig=function(n){var e,o,t,r,i,s,a,u,l=n,c=!0,_=!0;return 2===f.get("webglVersion")?(e=l.getExtension("EXT_color_buffer_float"),t=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,s=l.R16F,a=l.RGBA16F,o=l.RED,u=l.RGBA32F):(r=l.RGBA,s=l.RGBA,a=l.RGBA,i=l.RGBA,o=l.RGBA,u=l.RGBA,e=l.getExtension("OES_texture_float"),t=l.getExtension("OES_texture_half_float").HALF_FLOAT_OES,c=this.isDownloadFloatTextureEnabled(l,u),_=this.isFloatTextureReadPixelsEnabledMethod(l,1,c)),{textureFloat:e,textureHalfFloat:t,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,textureFormat:o,downloadInternalFormat:u,frameBufferSupportFloat:c,isFloatTextureReadPixelsEnabled:_}},n.isFloatTextureReadPixelsEnabledMethod=function(n,e,o){var t=n;if(0===e)return!1;if(1===e){if(null==t.getExtension("OES_texture_float"))return!1}else if(null==t.getExtension("EXT_color_buffer_float")||null==t.getExtension("EXT_color_buffer_half_float"))return!1;var r=t.createFramebuffer(),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i);var s=2===e?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,s,1,1,0,t.RGBA,o?t.FLOAT:t.getExtension("OES_texture_half_float").HALF_FLOAT_OES,null),t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4));var u=t.getError()===t.NO_ERROR;return a&&u},n.isDownloadFloatTextureEnabled=function(n,e){var o=n.createTexture();n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,e,1,1,0,n.RGBA,n.FLOAT,null);var t=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,t),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,o,0);var r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(o),n.deleteFramebuffer(t),r},n.uploadDataToTexture=function(n,e,o,t){n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var r=o.width_texture,i=o.height_texture,s=o.data,a=n.RGBA,u=n.RGBA,l=n.FLOAT,c=s;if(s instanceof Uint8Array||s instanceof Uint8ClampedArray)l=n.UNSIGNED_BYTE;else{if(!(s instanceof Float32Array||s instanceof Array))return void n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,s);if(2===f.get("webglVersion")){var _=f.get("webgl_force_half_float_texture");a=t?_?e.internalFormatPackedHalfFloat:e.internalFormatPacked:_?e.internalFormatHalfFloat:e.internalFormat,u=t?n.RGBA:e.textureFormat}else{for(var g=new Float32Array(r*i*4),h=0;h<s.length;h++)t?g[h]=s[h]:(g[4*h]=s[h],g[4*h+1]=0,g[4*h+2]=0,g[4*h+3]=0);c=g}}n.texImage2D(n.TEXTURE_2D,0,a,r,i,0,u,l,c)},n.genOutputTexture=function(n,e,o,t){var r=o.interpType,i=o.width_texture,s=o.height_texture,a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var u=f.get("webgl_force_half_float_texture"),l=u?e.internalFormatPackedHalfFloat:e.internalFormatPacked,c=2===f.get("webglVersion")?u?n.HALF_FLOAT:n.FLOAT:e.frameBufferSupportFloat?n.FLOAT:e.textureHalfFloat,_=t?e.isFloatTextureReadPixelsEnabled?c:n.UNSIGNED_BYTE:null;return n.texImage2D(n.TEXTURE_2D,0,l,i,s,0,n.RGBA,t?_:c,null),n.bindTexture(n.TEXTURE_2D,null),a},n}(),y=["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ","#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],E=new Float32Array([-1,1,-1,-1,1,1,1,-1]),w=["length_shape","length_unformatted_shape","width_shape","height_shape","width_texture","height_texture","offset_x","offset_y","channel","total_shape","numbers_shape"],V={float:["multi_value","bias_value"],bool:["fuse_relu"]};function A(){return"\n    "+(f.get("useModAdaptor")?"\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        ":"\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ")+"\n    "+(f.get("useDivisionAdaptor")?"\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        ":"\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ")+"\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    "}const O="\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n";var C="\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",R="\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",S="\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",I="\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",L="\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",k="\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",B="\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",M="\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",D="\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",U="\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}",j="\nfloat exp_func(float x, float y, float z) {\n    float result = exp(x);\n    return result;\n}";function N(n,e){var o=e.width_shape,t=e.height_shape,r=e.channel,i=e.width_texture;return"\n    float getValueFromTensorPos_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+o*t*r+" + c * "+o*t+" + h * "+o+" + w;\n        // 0.01 hack: 在 PC/WISE 机器上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+i+")));\n        int pos_h = index / int("+i+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+i+"),\n                (float(pos_h) + 0.5) / float("+e.height_texture+")\n            )\n        );\n        return pixels.r;\n    }"}function X(n,e){var o=e.channel,t=e.height_shape,r=e.width_texture,i=e.height_texture,s=e.width_shape;return"\n    vec4 getValueFromTensorPosPacking_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+s*t*o+" + c * "+s*t+" + h * "+s+" + w;\n        // 0.01 hack: 在 PC/WISE 设备上，出现某个值（比如 index 为 3520） float(index) 和 float(3520) 返回值不同的情况，目前 +0.01 hack\n        int pos_w = int(mod(float(index) + 0.01, float("+r+")));\n        int pos_h = index / int("+r+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+r+"),\n                (float(pos_h) + 0.5) / float("+i+")\n            )\n        );\n        return pixels;\n    }"}function G(n,e){var o=e.numbers_shape,t=e.length_shape;if(1===t)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+o[0]+");\n            }\n        ";for(var r="ivec"+t+"("+o.join(", ")+")",i="pos[0] = n / "+o[0]+";",s=1;s<t;s++)i+="\n            n = calMod(n, "+o[s-1]+");\n            pos["+s+"] = calDivision(n, "+o[s]+");\n        ";return"\n    ivec"+t+" shapeVec_"+n+" = "+r+";\n    ivec"+t+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+t+" pos;\n        "+i+"\n        return pos;\n    }\n    "}function H(n){return"\n    #define getPixelsFromTexturePos_"+n+"(pos) TEXTURE2D(texture_"+n+", pos)\n    "}function W(n,e){return"\n    vec2 moveTexture2PosToReal_"+n+"(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float("+e.width_texture+");\n        v2.y = v.y * float("+e.height_texture+");\n        return v2;\n    }\n    "}function z(n){return"uniform sampler2D texture_"+n+";"}function Y(n,e,o,t,s){var a,u,l="",c=e.name,_=e.mainFunc,g=e.textureFuncConf,h=void 0===g?{}:g,d=e.commonFuncConf;try{var p=function(n,e,o){for(var t={},r=Object.assign({},e),i=[],s=0,a=n;s<a.length;s++){for(var u=a[s],l=u.name,f={},c=0,_=w;c<_.length;c++)void 0!==u[P=_[c]]&&(f[P]=u[P]);t[l]=f,i.push(l)}for(var g=0,h=Object.keys(V);g<h.length;g++)for(var d=h[g],p=0,m=V[d];p<m.length;p++){var P;void 0!==e[P=m[p]]&&(r[P]=d+"("+e[P]+")")}return e.active_function&&(r.active_function=e.active_function),r.runtime=o,{textureParams:t,opParams:r,active_function:e.active_function}}(o,t,s),m=p.textureParams,P=p.opParams,v=p.active_function,x=2===f.get("webglVersion")?" #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        ":" #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",T=function(n){var e=n.frameBufferSupportFloat,o=n.isFinalOp,t=n.isFloatTextureReadPixelsEnabled;return 2===f.get("webglVersion")?"\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        "+A()+"\n    ":e?"\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            "+A()+"\n    ":o&&!t?"\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        "+A()+"\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        ":"\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            "+A()+"\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        "}(n),F=function(n){var e="",o="";if(n.fuse_opt)for(var t in n.fuse_opt){var i=t,s=0,a=0;switch(t){case"scale":var u=n.fuse_opt.scale.bias_after_scale;s=void 0!==(f=n.fuse_opt.scale.scale)?f:1,a=n.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i="scaleWidthBias");break;case"relu":i="prelu";break;case"relu6":s=n.fuse_opt[t].threshold;break;case"hard_sigmoid":i="hardSigmoid",s=n.fuse_opt[t].slope||.2,a=n.fuse_opt[t].offset||.5;break;case"leakyRelu":s=n.fuse_opt[t].alpha;break;case"pow":i="pow_func",s=n.fuse_opt[t].factor||2;break;case"tanh":i="tanh_func";break;case"exp":i="exp_func"}if("hard_swish"===t){var l=void 0!==n.fuse_opt.hard_swish.offset?n.fuse_opt.hard_swish.offset:3,f=void 0!==n.fuse_opt.hard_swish.scale?n.fuse_opt.hard_swish.scale:6;o+="res = res * min(max(0.0, res + float("+l+")), float("+(void 0!==n.fuse_opt.hard_swish.threshold?n.fuse_opt.hard_swish.threshold:6)+")) / float("+f+");"}else"dropout"===t?o+="\n                if ("+("downgrade_in_infer"===n.fuse_opt.dropout.dropout_implementation)+") {\n                    res = res * (1.0 - float("+n.fuse_opt.dropout.dropout_prob+"));\n                }":(e+=r[i],o+="res = "+i+"(res, float("+s+"), float("+a+"));")}return"\n        "+e+"\n        \n        float fuse_op(float x) {\n            float res = x;\n            "+o+"\n            return res;\n        }\n    "}(P),b=function(n,e,o,t){if(!n)return"";var r=Object.assign({},n);r["@all"]&&function(n,e){var o=e.filter((function(n){return"out"!==n.name})),t=n["@all"];o.forEach((function(e){var o=e.name;n[o]?n[o].concat(t):n[o]=t})),delete n["@all"]}(r,t);for(var s="",a="",u=0,l=Object.keys(r);u<l.length;u++){var f=l[u];if(e[f]){a+=z(f);for(var c=0,_=r[f];c<_.length;c++){var g=_[c];if(i[g])try{s+=i[g](f,e[f],o)}catch(n){console.error(n)}}}}return"\n    "+a+"\n    "+s+"\n    "}(h,m,P,o),y=function(n){return void 0===n?"":"\n        int layer_run_time = "+n+";\n    "}(s),E=function(n){var e,o,t,r,i;return"\n        \n    vec2 _2d_shape_texture_out = vec2(float("+n.width_texture+"), float("+n.height_texture+"));\n    \n        "+(o=(e=n).height_shape,t=e.width_shape,"\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+e.width_texture+");\n\n        int n1 = int(index / "+(r=t*o*e.channel)+");\n        int c1 = int(calMod(index, "+r+") / "+(i=t*o)+");\n        int h1 = int(calMod(index, "+i+") / "+t+");\n        int w1 = calMod(index, "+t+");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ")}(m.out),O=function(n){if(!n)return"";for(var e="",o=0,t=n;o<t.length;o++){var i=t[o];r[i]&&(e+=r[i])}return e}(d);a=l=" "+x+"\n            "+F+"\n            "+T+"\n            "+O+"\n            "+(v?r[v]:"")+"\n            "+b+"\n            "+y+"\n            "+E+"\n            "+_(m,P)+"\n        ",u=1===f.get("webglVersion")?"texture2D":"texture",l=a.replace(/\bTEXTURE2D\b/g,u)}catch(n){console.error("["+c+"]: "+n)}return l}const q=function(){function n(n,e,o,t){var r=n;this.vShader=e;try{this.fShader=this.initShader(r,o,"fragment"),this.shape=t&&t.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(n){throw new Error(n)}}return n.prototype.initShader=function(n,e,o){void 0===o&&(o="vertex");var t,r="vertex"===o?n.VERTEX_SHADER:n.FRAGMENT_SHADER;if("vertex"===o&&this.vShader)t=this.vShader;else if(t=n.createShader(r),"vertex"===o&&(this.vShader=t),n.shaderSource(t,e),n.compileShader(t),!n.getShaderParameter(t,n.COMPILE_STATUS))throw new Error("compile: "+n.getShaderInfoLog(t));return t},n.prototype.setProgram=function(n,e,o){n.useProgram(this.program),o||this.runVertexShader(n,e)},n.prototype.runVertexShader=function(n,e){var o=n.getAttribLocation(this.program,"position");n.enableVertexAttribArray(o),n.bindBuffer(n.ARRAY_BUFFER,e),n.vertexAttribPointer(o,2,n.FLOAT,!1,0,0)},n.Sampler="uSampler",n}();var Z,K=(Z=function(n,e){return(Z=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o])})(n,e)},function(n,e){function o(){this.constructor=n}Z(n,e),n.prototype=null===e?Object.create(e):(o.prototype=e.prototype,new o)}),Q=function(n,e,o,t){return new(o||(o=Promise))((function(r,i){function s(n){try{u(t.next(n))}catch(n){i(n)}}function a(n){try{u(t.throw(n))}catch(n){i(n)}}function u(n){var e;n.done?r(n.value):(e=n.value,e instanceof o?e:new o((function(n){n(e)}))).then(s,a)}u((t=t.apply(n,e||[])).next())}))},J=function(n,e){var o,t,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(o)throw new TypeError("Generator is already executing.");for(;s;)try{if(o=1,t&&(r=2&i[0]?t.return:i[0]?t.throw||((r=t.return)&&r.call(t),0):t.next)&&!(r=r.call(t,i[1])).done)return r;switch(t=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,t=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=e.call(n,s)}catch(n){i=[6,n],t=0}finally{o=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const $=function(n){function e(){var e=n.call(this)||this;return e.cacheTextures={},e.uniformLocations={},e.texturesMap={},e.queryList=[],e.currentTexture=null,e.width_shape_out=1,e.height_shape_out=1,e.width_texture_out=1,e.height_texture_out=1,e.channel=0,e.total_shape=0,e}return K(e,n),e.prototype.init=function(){return Q(this,void 0,void 0,(function(){var n;return J(this,(function(e){return n=this.gl=F.createWebGLRenderingContext(),this.gl?(this.glVersion=F.getWebglVersion(),this.textureConf=b.getTextureConfig(n),this.MAX_TEXTURE_SIZE=f.get("MAX_TEXTURE_SIZE")||n.getParameter(n.MAX_TEXTURE_SIZE),n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),this.vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,E,n.STATIC_DRAW),this.vShader=F.initShader(n,m.VS_SHADER,y[this.glVersion-1]),this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),this.pbo=n.createBuffer(),[2]):[2]}))}))},e.prototype.createProgram=function(n){var e=this,o=n.op,t=n.outTensor,r=n.inputTensors,i=n.shaderParams,s=n.runtime,a=n.isFinalOp,u=null;try{var l=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([t],r);l.forEach((function(n){return F.genTextureInfoFromTensorShape(e.MAX_TEXTURE_SIZE,n)}));var f=Y(this.textureConf,o,l,i,s);(u=new q(this.gl,this.vShader,f,t)).fsCode=f;var c=b.genOutputTexture(this.gl,this.textureConf,t,a);this.texturesMap[t.tensorId]=c,this.program=u}catch(n){console.error("webgl createProgram: "+o.name+" -- "+n)}return u},e.prototype.runProgram=function(n,e){var o=this,t=function(n,e){if(2===e&&f.get("performance")){var o=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!o)return;var t=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,t),t}return null}(this.gl,this.glVersion),r=n.isPackedOp;n.program.forEach((function(t,i){var s=n.outputTensors[i],a=s.tensorId;o.setOutProps(s),"frameBuffer"===n.bufferType?o.attachFrameBuffer(a):o.attachColorBuffer(),t.setProgram(o.gl,o.vertexBuffer,e),o.program=t,o.render(n,e,i,r)})),n.tensorData=null,t&&(this.queryList.push({name:n.name,query:t,count:1}),t=function(n,e,o){if(2===e&&f.get("performance")){var t=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!t)return;n.endQuery(t.TIME_ELAPSED_EXT)}return o}(this.gl,this.glVersion,t))},e.prototype.read=function(n){return Q(this,void 0,void 0,(function(){var e,o,t;return J(this,(function(r){switch(r.label){case 0:return f.get("webgl_gpu_pipeline")?(e=this.gl,this.frameBuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),[2,[]]):(o=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return r.sent(),t=n?n.shape:[],[2,this.downloadFloat32TensorFromBuffer(o,t)]}}))}))},e.prototype.createPBO=function(){var n,e=this.textureConf;if(2===this.glVersion){var o=this.gl,t=this.pbo;o.bindBuffer(o.PIXEL_PACK_BUFFER,t);var r=16*this.width_texture_out*this.height_texture_out;return o.bufferData(o.PIXEL_PACK_BUFFER,r,o.STREAM_READ),o.readPixels(0,0,this.width_texture_out,this.height_texture_out,o.RGBA,o.FLOAT,0),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),t}var i=this.gl,s=i.FLOAT;return e.isFloatTextureReadPixelsEnabled?n=new Float32Array(this.width_texture_out*this.height_texture_out*4):(n=new Uint8Array(this.width_texture_out*this.height_texture_out*4),s=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,s,n),e.isFloatTextureReadPixelsEnabled?n:new Float32Array(n.buffer)},e.prototype.createAndWaitForFence=function(){return Q(this,void 0,void 0,(function(){var n,e,o,t,r=this;return J(this,(function(i){return n=this.gl,e=null!=n.fenceSync,o=function(){return!0},e&&(t=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0),n.flush(),o=function(){var e=n.clientWaitSync(t,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED}),[2,new Promise((function(n){r.pollItem(o,n)}))]}))}))},e.prototype.pollItem=function(n,e){var o=function(){n()?e():setTimeout(o,1)};o()},e.prototype.downloadFloat32TensorFromBuffer=function(n,e){var o=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var t=this.gl,r=new Float32Array(o);t.bindBuffer(t.PIXEL_PACK_BUFFER,n),t.getBufferSubData(t.PIXEL_PACK_BUFFER,0,r),t.bindBuffer(t.PIXEL_PACK_BUFFER,null);var i=[];if(f.get("webgl_pack_output"))return Array.from(r).slice(0,function(n){return n.reduce((function(n,e){return n*e}),1)}(e));for(var s=0;s<this.width_texture_out*this.height_texture_out;s++)i.push(r[4*s]);return i}var a=n,u=[];for(s=0;s<this.width_texture_out*this.height_texture_out;s++){var l=this.textureConf.isFloatTextureReadPixelsEnabled?4*s:s;u.push(a[l])}return u},e.prototype.setOutProps=function(n){var e=n.width_shape,o=void 0===e?1:e,t=n.height_shape,r=void 0===t?1:t,i=n.width_texture,s=void 0===i?1:i,a=n.height_texture,u=void 0===a?1:a,l=n.channel,f=void 0===l?0:l,c=n.total_shape,_=void 0===c?0:c;this.width_shape_out=o,this.height_shape_out=r,this.width_texture_out=s,this.height_texture_out=u,this.channel=f,this.total_shape=_},e.prototype.attachColorBuffer=function(){var n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.canvas.width=this.width_shape_out,n.canvas.height=this.height_shape_out,n.viewport(0,0,n.canvas.width,n.canvas.height),n.scissor(0,0,n.canvas.width,n.canvas.height)},e.prototype.attachFrameBuffer=function(n){this.currentTexture=this.texturesMap[n];var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.currentTexture,0),e.viewport(0,0,this.width_texture_out,this.height_texture_out),e.scissor(0,0,this.width_texture_out,this.height_texture_out)},e.prototype.render=function(n,e,o,t){var r=this;void 0===e&&(e=!1),void 0===t&&(t=!1);var i=n.inputTensors,s=void 0===i?[]:i,a=n.uniform,u=void 0===a?null:a,l=n.iLayer,f=void 0===l?0:l,c=n.modelName,_=this.gl,g=0;s.forEach((function(n){r.initTexture(g,n,t);var i=r.getUniformLoc("texture_"+n.name,f,e,o,c);i&&_.uniform1i(i,g++)})),u&&this.setUniform(u,f,e,o,c),_.drawArrays(_.TRIANGLE_STRIP,0,4)},e.prototype.initTexture=function(n,e,o){var t,r=this.gl,i=this.textureConf,s=e.tensorId,a=o||e.isPacked,u=e.data;if(e.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[s];l?(t=l,u&&F.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,e)):(t=r.createTexture(),this.cacheTextures[s]=t)}else t=this.texturesMap[s];r.activeTexture(r["TEXTURE"+n]),r.bindTexture(r.TEXTURE_2D,t),u&&(b.uploadDataToTexture(r,i,e,a),e.data=null)},e.prototype.setUniform=function(n,e,o,t,r){var i=this,s=Object.keys(n),a=this.gl;s.forEach((function(s){var u=n[s].type,l=n[s].value,f=i.getUniformLoc(s,e,o,t,r);F.setUniformParam(a,f,u,l)}))},e.prototype.getUniformLoc=function(n,e,o,t,r){var i=r+"_";if(o)return this.uniformLocations[i+e][n+t];var s=this.gl.getUniformLocation(this.program.program,n);return this.uniformLocations[i+e]=this.uniformLocations[i+e]||{},this.uniformLocations[i+e][n+t]=s,s},e.prototype.dispose=function(){},e}((function(){})),nn={mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.filter_nearest_vec4,p=e.filter_remainder_vec4,m=e.act_type,P=void 0===m?"":m,v=e.padding_algorithm,x=void 0===v?"":v,T=e.hard_swish_offset,F=void 0===T?3:T,b=e.hard_swish_scale,y=void 0===b?6:b,E=e.hard_swish_threshold,w=void 0===E?6:E,V=l[0],A=void 0===V?1:V,O=l[1],C=void 0===O?1:O,R=c[0],S=void 0===R?0:R,I=c[1],L=void 0===I?0:I,k=g[0],B=void 0===k?1:k,M=g[1],D=void 0===M?1:M;return"SAME"===x&&Math.ceil((o.width_shape-t.width_shape)/A)+1!==r.width_shape&&(S=1,L=1),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+a+")) * "+t.channel+";\n        int oy = y * "+A+" - "+S+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+B+";\n                continue;\n            }\n            int ox = x * "+C+" - "+L+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+D+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+d+"; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if ("+p+" == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox));\n                } else if ("+p+" == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if ("+p+" == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += "+D+";\n            }\n            oy += "+B+";\n        }\n\n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n\n        if ("+h+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===P)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        else if ("+("hard_swish"===P)+") {\n            res = res * min(\n                max(0.0, res + float("+F+")),\n                float("+w+")\n            ) / float("+y+");\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]};function en(n,e){var o=n[0],t=n[1],r=n[2],i=n[3];if(1===o&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function on(n,e,o){if(1===o)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var t=g(e);return t.push(1),"\n    ivec"+o+" shapeVec_"+n+" = ivec"+o+"("+t.join(", ")+");\n    ivec"+o+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+o+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+o+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function tn(n){return 1===n?"int":"ivec"+n}function rn(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}const sn={mainFunc:function(n,e){var o=n.origin,t=e.transpose_X,r=void 0!==t&&t,i=e.transpose_Y,s=void 0!==i&&i,a=e.trans_x,u=void 0!==a&&a,l=e.trans_y,f=r||u,c=s||void 0!==l&&l;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if ("+f+") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if ("+c+") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < "+(f?o.height_shape:o.width_shape)+"; j++) {\n            if ("+f+") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if ("+c+") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}};function an(n,e){var o=n[0],t=n[1],r=n[2],i=n[3];if(1===o&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,e),a=n.slice(e);return[s,s.length,a,a.length,[s.reduce((function(n,e){return n*e})),a.reduce((function(n,e){return n*e}))]]}function un(n,e,o){if(1===o)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";var t=g(e);return t.push(1),"\n    ivec"+o+" shapeVec_"+n+" = ivec"+o+"("+t.join(", ")+");\n    ivec"+o+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+o+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+o+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function ln(n){return 1===n?"int":"ivec"+n}function fn(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}const cn={mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getTensorPosFromArrayIndex","getValueFromTensorPos"]}},_n={mainFunc:function(n,e){var o=n.out,t=n.origin,r=e.align_mode,i=void 0===r?1:r,s=e.align_corners,a=void 0===s||s;return"\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = "+i+" == 0 && !"+a+";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+a+") {\n            scale_x = float("+o.width_shape+" - 1) / float("+t.width_shape+" - 1);\n            scale_y = float("+o.height_shape+" - 1) / float("+t.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+o.width_shape+") / float("+t.width_shape+");\n            scale_y = float("+o.height_shape+") / float("+t.height_shape+");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, "+t.width_shape+");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, "+t.height_shape+");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},gn=_n;var hn={relu:["transToPrelu"],relu6:["transToRelu6"],leaky_relu:["transToLeakyrelu"],transToLeakyrelu:["transToLeakyrelu"],scale:["transToScale"],sigmoid:["transToSigmoid"],hard_sigmoid:["transToHardSigmoid"],pow:["transToPow"],exp:["transToExp"],sqrt:["transToSqrt"],tanh:["transToTanh"]};function dn(n,e){var o=e.multi_value,t=void 0===o?1:o,r=e.bias_value,i=void 0===r?0:r;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = "+e.active_function+"(o, float("+t+"), float("+i+"));\n        setOutput(res);\n    }\n    "}function pn(n){return{mainFunc:dn,textureFuncConf:{origin:["getPixelsFromTexturePos"]},behaviors:hn[n]}}const mn={mainFunc:function(n,e){var o=e.axes,t=Array.isArray(o)?o:[o],r=[0,1,2,3].filter((function(n){return n>=t.length}));return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+[0,1,2,3].map((function(n){return t.indexOf(n)>-1?0:"oPos["+r.splice(0,1)+"]"})).join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},Pn={mainFunc:function(n,e){var o=n.origin,t=n.out,r=e.align_corners;return"\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+r+") {\n            scale_x = float("+t.width_shape+" -1) / float("+o.width_shape+" - 1);\n            scale_y = float("+t.height_shape+" - 1) / float("+o.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+t.width_shape+") / float("+o.width_shape+");\n            scale_y = float("+t.height_shape+") / float("+o.height_shape+");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, "+r+");\n        int vy = getData(float(oPos.b), scale_y, "+r+");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]};var vn=function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t};const xn={mainFunc:function(n,e){var o=n.origin,t=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.fixed_sizes,u=e.fixed_ratios,l=e.densities,f=e.flatten_to_2d,c=e.clip,_=e.step_w,d=void 0===_?0:_,p=e.step_h,m=void 0===p?0:p,P=e.offset,v=void 0===P?.5:P,x=e.runtime,T=void 0===x?0:x,F=t.height_shape,b=t.width_shape,y=o.height_shape,E=o.width_shape,w=r.total_shape,V=r.channel,A=r.height_shape,O=r.width_shape,C=w/V/A/O,R=g([C,V,A,O]),S=d,I=m;0!==d&&0!==m||(S=b/E,I=F/y);var L=Math.round(.5*(S+I)),k=u.map((function(n){return Math.sqrt(n)})),B=1===k.length?"sqrt_fixed_ratios":"sqrt_fixed_ratios[r]",M=u.length,D=A,U=C,j=V;f&&(U=y,j=E,D=A/y/E);var N=g([U,j,D,O]),X=G("out1",{numbers_shape:vn(N,[1]),length_shape:4}),H=l.map((function(n){return n*n*M})),W=H.length,z=function(n){var e="ivec2 calRemain(int remain, int curAccIndex, int s) {",o=n.length;if(1===o)e+="\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";else for(var t=0;t<o;t++)e+="\n            int accIndex"+t+" = density_acc_shape["+t+"];\n\n            if (remain >= accIndex"+t+") {\n                s++;\n                remain -= accIndex"+t+";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";return e+"\n    }\n    "}(H),Y=c?"v = min(max(v, 0.), 1.);":"",q=1===W?"density_acc_shape":"density_acc_shape[0]",Z="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    "+X+"\n    \n        "+h(l,"densities")+"\n        "+h(a,"fixed_sizes")+"\n        "+h(k,"sqrt_fixed_ratios")+"\n        "+function(n,e){if(1===n.length)return"int "+e+" = int("+n[0]+");";for(var o=n.length,t="\n        ivec"+o+" "+e+" = ivec"+o+"(\n    ",r=0;r<o;r++)t+=n[r]+",";return t.slice(0,-1)+");"}(H,"density_acc_shape")+"\n    \n    "+z+"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * "+R[0]+" + gg * "+R[1]+" + bb * "+R[2]+" + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    ";return 1===T?"\n        "+h(s,"variances")+"\n        "+Z+"\n        setOutput(getFloat4TensorVal(variances, aa));\n        }":"\n            "+Z+"\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = "+q+";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat"+l.length+"TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float("+v+")) * float("+S+");\n            float center_y = (float(h) + float("+v+")) * float("+I+");\n            float fixed_size = getFloat"+a.length+"TensorVal(fixed_sizes, s);\n            float shift = float("+L+") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * "+B+";\n                float density_center_x = center_x - float("+L+") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float("+b+"), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float("+b+"), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / "+B+";\n                float density_center_y = center_y - float("+L+") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float("+F+"), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float("+F+"), 1.);\n                }\n            }\n\n            "+Y+"\n\n            setOutput(v);\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},Tn={mainFunc:function(n,e){var o=n.origin,t=n.image,r=n.out,i=e.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=e.flip,u=e.clip,l=e.step_w,f=void 0===l?0:l,c=e.step_h,g=void 0===c?0:c,m=e.offset,P=void 0===m?.5:m,v=e.runtime,x=void 0===v?0:v,T=e.min_sizes,F=void 0===T?[]:T,b=e.max_sizes,y=void 0===b?[]:b,E=e.aspect_ratios,w=void 0===E?[]:E,V=e.min_max_aspect_ratios_order,A=void 0!==V&&V,O=t.height_shape,C=t.width_shape,R=o.height_shape,S=o.width_shape,I=r.channel,L=r.height_shape,k=f,B=g;0!==f&&0!==g||(k=C/S,B=O/R);var M=[1];w.forEach((function(n){1!==n&&(M.push(Math.sqrt(n)),a&&M.push(Math.sqrt(1/n)))}));var D=M.length,U="\n        "+d(F,"min_sizes",_.FLOAT_TYPE)+"\n        "+d(y,"max_sizes",_.FLOAT_TYPE)+"\n        "+d(M,"aspect_ratios",_.FLOAT_TYPE)+"\n    ",j=u?"res = min(max(res, 0.), 1.);":"",N="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    \n        "+p(F,"min_sizes",_.FLOAT_TYPE)+"\n        "+p(y,"max_sizes",_.FLOAT_TYPE)+"\n        "+p(M,"aspect_ratios",_.FLOAT_TYPE)+"\n    \n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        "+U+"\n\n    ";return 1===x?"\n            "+h(s,"variances")+"\n            "+N+"\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }":"\n            "+N+"\n            int idx = nn * "+I*L+" + cc * "+L+" + hh;\n            int as_num = "+D+";\n            float offset = "+P+";\n            \n            int feature_width = "+S+";\n            int num_priors = "+L+";\n            float step_width = float("+k+");\n            float step_height = float("+B+");\n\n            float im_width = float("+C+");\n            float im_height = float("+O+");\n\n            bool min_max_aspect_ratios_order = "+A+";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = calMod(idx / num_priors, feature_width);\n            int p = calMod(idx, num_priors);\n            int m = "+(y.length>0)+" ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = getValueFromArrByIndex_min_sizes(min_sizes, m);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            "+(y.length>0?"\n            int s = calMod(p, as_num + 1);\n            if ("+!A+") {\n                if (s < as_num) {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = getValueFromArrByIndex_max_sizes(max_sizes, m);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s - 1);\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }":"\n            int s = calMod(p, as_num);\n            float ar = getValueFromArrByIndex_aspect_ratios(aspect_ratios, s);\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ")+"\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            "+j+"\n\n            setOutput(float(res));\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:[]};const Fn={mainFunc:function(n,e){for(var o=n.out,t=function(n,e){var o={};for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&e.indexOf(t)<0&&(o[t]=n[t]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(t=Object.getOwnPropertySymbols(n);r<t.length;r++)e.indexOf(t[r])<0&&Object.prototype.propertyIsEnumerable.call(n,t[r])&&(o[t[r]]=n[t[r]])}return o}(n,["out"]),r=t.origin,i=r.width_shape,s=r.height_shape,a=r.channel,u=r.total_shape,l=r.length_unformatted_shape,f=[u/(i*s*a),a,s,i].slice(4-l),c=Object.keys(t).length,_=e.axis<0?e.axis+f.length+1:e.axis,g=1,h=1,d=0;d<_;d++)g*=f[d];for(d=_;d<f.length;d++)h*=f[d];var p=o.total_shape/g,m="";return m=Array.from(Array(c).keys()).reduce((function(n,e){return n+(0===e?"\n            if (i == 0) {\n                ivec4 co = getTensorPosFromArrayIndex_origin(j);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (i == "+e+") {\n                ivec4 co = getTensorPosFromArrayIndex_origin_"+e+"(j);\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }")}),m),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n\n        int index = calMod(sumVal, "+p+");\n\n        int layer = sumVal / "+p+";\n\n        int i = index / "+h+";\n        int j = calMod(index, "+h+") + layer * "+h+";\n\n        float o = 0.0;\n        "+m+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},bn={mainFunc:function(n,e){var o=n.out,t=n.origin,r=e.axes,i=e.starts,s=e.ends,a=e.decrease_axis;if(r.length>1||i.length>1||s.length>1||a&&0===a.length)throw Error("[slice op feature]: current support one dim, support decrease_axis");var u=t.width_shape,l=t.height_shape,f=t.channel,c=t.total_shape,g=t.length_unformatted_shape,h=[c/(u*l*f),f,l,u],m=r[0];if(m<0&&(m=m+g+1),4!==(m=4-g+m))throw Error("[slice op feature]: unsupport axis value");for(var P=i[0],v=s[0],x=h[0],T=h[1],F=h[2],b=h[3],y=[],E=P;E<v;E++)for(var w=0;w<x;w++)for(var V=0;V<T;V++)for(var A=0;A<F;A++)y.push(w*T*F*b+V*F*b+A*b+E);var O=d(y,"arr",_.INT_TYPE);return"\n    "+p(y,"arr",_.INT_TYPE)+"\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        "+O+"\n\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+o.width_shape+"\n            + oPos.g * "+o.height_shape+" * "+o.width_shape+"\n            + oPos.r * "+o.channel+" * "+o.width_shape+" * "+o.height_shape+";\n\n        int index = getValueFromArrByIndex_arr(arr, sumVal);\n\n        float res = 0.0;\n        ivec4 co = getTensorPosFromArrayIndex_origin(index);\n        res = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}};var yn={arg_max:{mainFunc:function(n,e){var o=n.origin,t=e.axis,r=void 0===t?-1:t,i=e.flatten,s=o.total_shape,a=o.height_shape,u=o.width_shape,l=o.channel,f=o.length_unformatted_shape,c=s/(u*a*l),_=r<0?3:4-f+r,g=[c,l,a,u][_];return"\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+_+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+c+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},arg_min:{mainFunc:function(n,e){for(var o=n.origin,t=e.axis,r=void 0===t?-1:t,i=e.flatten,s=o.total_shape,a=o.height_shape,u=o.width_shape,l=o.channel,f=s/(u*a*l),c=[f,l,a,u],_=0,g=0;g<4&&!(c[g]>1);g++)_++;var h=r<0?4-_+r:r,d=c[h=_+h];return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+h+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+f+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},conv2d:nn,conv2d_packing:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.act_type,p=e.hard_swish_offset,m=void 0===p?3:p,P=e.hard_swish_scale,v=void 0===P?6:P,x=e.hard_swish_threshold,T=void 0===x?6:x,F=l[0],b=void 0===F?1:F,y=l[1],E=void 0===y?1:y,w=c[0],V=void 0===w?0:w,A=c[1],O=void 0===A?0:A,C=g[0],R=void 0===C?1:C,S=g[1],I=void 0===S?1:S;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * "+b+" - "+V+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+R+";\n                continue;\n            }\n            int ox = x * "+E+" - "+O+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+I+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j += 1) {\n                    int c0 = (c / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += "+I+";\n            }\n            oy += "+R+";\n        }\n\n        "+(i?"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);":"")+"\n\n        if ("+h+") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if ("+("relu6"===d)+") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        else if ("+("hard_swish"===d)+") {\n            res = res * min(\n                max(vec4(0.0, 0.0, 0.0, 0.0), res + vec4("+m+")),\n                vec4("+T+")\n            ) / vec4("+v+");\n        }\n\n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPosPacking"],origin:["getValueFromTensorPosPacking"],bias:["getValueFromTensorPosPacking"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},conv2d_transpose:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.bias,s=e.groups,a=void 0===s?1:s,u=e.strides,l=void 0===u?[]:u,f=e.paddings,c=void 0===f?[]:f,_=e.dilations,g=void 0===_?[]:_,h=e.fuse_relu,d=e.act_type,p=l[0],m=void 0===p?1:p,P=l[1],v=void 0===P?1:P,x=c[0],T=void 0===x?0:x,F=c[1],b=void 0===F?0:F;b=t.height_shape-b-1,T=t.width_shape-T-1;var y=g[0],E=void 0===y?1:y,w=g[1],V=void 0===w?1:w;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * "+a+" / "+r.channel+") * "+o.channel+";\n        int oy = y - "+b+";\n        const int groupLen = int("+o.channel+" / "+a+");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy < 0) {\n                oy += "+E+";\n                continue;\n            }\n            int ox = x - "+T+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n\n                if (ox < 0) {\n                    ox += "+V+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int("+v+")) == 0 && calMod(oy, int("+m+")) == 0) {\n                        temp_x = int(floor(float(ox) / float("+v+")));\n                        temp_y = int(floor(float(oy) / float("+m+")));\n                        if (temp_x < "+o.width_shape+" && temp_y < "+o.height_shape+") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / "+a+"),\n                                "+t.height_shape+"-1-fy,\n                                "+t.width_shape+"-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += "+V+";\n            }\n            oy += "+E+";\n        }\n        \n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n        \n        if ("+h+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===d)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n        \n        setOutput(float(res));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},depthwise_conv2d:nn,conv2d_depthwise:nn,conv2d_elementwise_add:{mainFunc:function(n,e){var o=n.origin,t=n.filter,r=n.out,i=n.counter,s=e.active_function,a=e.groups,u=void 0===a?1:a,l=e.axis,f=e.strides,c=void 0===f?[]:f,_=e.paddings,g=void 0===_?[]:_,h=e.dilations,d=void 0===h?[]:h,p=e.multi_value,m=e.bias_value,P=c[0],v=void 0===P?1:P,x=c[1],T=void 0===x?1:x,F=g[0],b=void 0===F?0:F,y=g[1],E=void 0===y?0:y,w=d[0],V=void 0===w?1:w,A=d[1],O=void 0===A?1:A;return"\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float("+i.width_shape+");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos["+l+"];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+u+")) * "+t.channel+";\n        int oy = y * "+v+" - "+b+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+V+";\n                continue;\n            }\n            int ox = x * "+T+" - "+E+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+O+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += "+O+";\n            }\n            oy += "+V+";\n        }\n        setOutput("+s+"(res,  "+p+",  "+m+"));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]},behaviors:["mergeAttrs","checkIsMerge","setActiveFunc"]},pool2d:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.pooling_type,u=e.ksize,l=r[0],f=void 0===l?1:l,c=r[1],_=void 0===c?1:c,g=s[0],h=void 0===g?0:g,d=s[1],p=void 0===d?0:d,m=u[0],P=u[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if ("+a+" == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n        for (int fy = 0; fy < "+m+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+P+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+a+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+a+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_max:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=e.global_pooling,l=e.runtime,f=r[0],c=void 0===f?1:f,_=r[1],g=void 0===_?1:_,h=s[0],d=void 0===h?0:h,p=s[1],m=void 0===p?0:p,P=a[0],v=a[1],x=function(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}(o),T="",F="setOutput(float(res));";return 0===l&&!0===u&&(T="\n            if (curr > res) {\n                index = "+x[2]*x[3]+" * out_pos[1] + "+x[3]+" * oy + ox;\n            }\n        ",F="setOutput(float(index));"),"\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+g+" - "+m+";\n        for (int fy = 0; fy < "+P+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+v+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                "+T+"\n                res = max(res, curr);\n            }\n        }\n        "+F+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_winograd:{mainFunc:function(n,e){var o=n.origin,t=n.pool,r=e.strides,i=void 0===r?[]:r,s=e.paddings,a=void 0===s?[]:s,u=e.type_pool,l=i[0],f=void 0===l?1:l,c=i[1],_=void 0===c?1:c,g=a[0],h=void 0===g?0:g,d=a[1],p=void 0===d?0:d,m=o.height_shape,P=o.width_texture,v=o.height_texture;return"\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = "+m+" + "+o.offset_y+";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float("+P+"),\n            (float(g * height / 2 + y) + 0.5) / float("+v+"))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+u+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+u+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},elementwise_add:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+u/r+") * c + float("+u/s+") * o;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_mul:{mainFunc:function(n,e){var o=n.counter,t=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+o.height_texture/o.height_shape+") {\n            newN = int("+o.height_texture/o.height_shape+");\n        }\n        if (c >= "+o.channel+") {\n            newC = int("+(o.channel-1)+");\n        }\n        if (h >= "+o.height_shape+") {\n            newH = "+(o.height_shape-1)+";\n        }\n        if (w >= "+o.width_shape+") {\n            newW = "+(o.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l/a+") * o * float("+1/i+") * c;\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_div:{mainFunc:function(n,e){var o=n.counter,t=e.counterPos,r=e.Scale_y,i=void 0===r?1:r,s=e.Scale_x,a=void 0===s?1:s,u=e.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+o.height_texture/o.height_shape+") {\n            newN = int("+o.height_texture/o.height_shape+");\n        }\n        if (c >= "+o.channel+") {\n            newC = int("+(o.channel-1)+");\n        }\n        if (h >= "+o.height_shape+") {\n            newH = "+(o.height_shape-1)+";\n        }\n        if (w >= "+o.width_shape+") {\n            newW = "+(o.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l+") * (float("+1/a+") * o / (float("+1/i+") * c));\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_pow:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = pow(float("+u/s+") * o, float("+u/r+") * c);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_sub:{mainFunc:function(n,e){var o=e.counterPos,t=e.Scale_y,r=void 0===t?1:t,i=e.Scale_x,s=void 0===i?1:i,a=e.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+o+");\n        float res = float("+u/s+") * o - float("+u/r+") * c;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},mul:{mainFunc:function(n,e){var o=n.origin,t=n.counter,r=e.x_num_col_dims,i=e.y_num_col_dims,s=rn(o),a=rn(t),u=en(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=en(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+on("x1",l,f)+"\n    "+on("x2",c,_)+"\n    "+on("y1",d,p)+"\n    "+on("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+tn(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+tn(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+tn(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+tn(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+tn(f)+"(x1), "+tn(_)+"(x2));\n            ivec4 yPos = ivec4("+tn(p)+"(y1), "+tn(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},matmul:sn,matmul_v2:sn,fc:{mainFunc:function(n,e){var o=n.origin,t=n.weight,r=e.x_num_col_dims,i=e.y_num_col_dims,s=fn(o),a=fn(t),u=an(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=an(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+un("x1",l,f)+"\n    "+un("x2",c,_)+"\n    "+un("y1",d,p)+"\n    "+un("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+ln(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+ln(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+ln(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+ln(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+ln(f)+"(x1), "+ln(_)+"(x2));\n            ivec4 yPos = ivec4("+ln(p)+"(y1), "+ln(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    "},textureFuncConf:{weight:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]}},dropout:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if ("+("downgrade_in_infer"===e.dropout_implementation)+") {\n            o = o * (1.0 - float("+e.dropout_prob+"));\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},concat:{mainFunc:function(n,e){var o=e.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(e*t*r),r,t,e][o]})),r=t.map((function(n,e){return t.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+o+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            ":"\n            else if (oPos["+o+"] < "+n+") {\n                oPos["+o+"] = oPos["+o+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},concat_mul:{mainFunc:function(n,e){var o=e.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e]})).map((function(n){var e=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(e*t*r),r,t,e][o]})),r=t.map((function(n,e){return t.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),i="";return r.forEach((function(n,e){i+=0===e?"\n            if (oPos["+o+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }":"\n            else if (oPos["+o+"] < "+n+") {\n                oPos["+o+"] = oPos["+o+"] - "+r[e-1]+";\n                o = getValueFromTensorPos_origin_"+e+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},split:{mainFunc:function(n,e){var o=e.target_length,t=e.num,r=e.dim,i=e.sections;return"\n    // start函数\n    void main(void) {\n        int length = int("+(i&&i.length>1?i[0]:o/t)+");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos["+r+"] = oPos["+r+"] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},softmax:{mainFunc:function(n,e){var o=n.origin,t=e.axis,r=t;return(!t||t<0)&&(r=(t||-1)+4),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int("+o.total_shape+"/"+o.channel+"/"+o.height_shape+"/"+o.width_shape+");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if ("+r+" == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if ("+r+" == 1) {\n            for (int i = 0; i < "+o.channel+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < "+o.width_shape+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},batchnorm:{mainFunc:function(n,e){var o=n.bias,t=n.scale,r=n.mean,i=n.variance,s=e.epsilon;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float("+t.width_texture+") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float("+o.width_texture+") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float("+r.width_texture+")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float("+i.width_texture+") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + "+s+");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],scale:["getPixelsFromTexturePos"],bias:["getPixelsFromTexturePos"],mean:["getPixelsFromTexturePos"],variance:["getPixelsFromTexturePos"]}},reshape:cn,reshape2:cn,bilinear_interp:_n,transpose2:{mainFunc:function(n,e){var o=e.perm_arr,t=e.perm_size,r=o[0],i=o[1],s=o[2];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if ("+t+" == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if ("+t+" == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + "+r+") > 3 ? 3 : (2 + "+r+")],\n                oPos[(2 + "+i+") > 3 ? 3 : (2 + "+i+")]\n            );\n        }\n        else if ("+t+" == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + "+r+") > 3 ? 3 : (1 + "+r+")],\n                oPos[(1 + "+i+") > 3 ? 3 : (1 + "+i+")],\n                oPos[(1 + "+s+") > 3 ? 3 : (1 + "+s+")]\n            );\n        }\n        else if ("+t+" == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos["+r+"],\n                oPos["+i+"],\n                oPos["+s+"],\n                oPos["+o[3]+"]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizePerm"]},unpacked_2_packed:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},packed_2_unpacked:{mainFunc:function(n,e){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},unsqueeze2:{mainFunc:function(n,e){var o=n.origin,t=e.axes,r=o.length_unformatted_shape,i=Array.isArray(t)?t:[t],s=4-r-i.length,a=i.map((function(n){return n+s})),u=[0,1,2,3].filter((function(n){return-1===a.indexOf(n)})).map((function(n){return"oPos["+n+"]"})),l=Array.from(new Array(a.length),(function(){return"0"}));return u.splice.apply(u,function(){for(var n=0,e=0,o=arguments.length;e<o;e++)n+=arguments[e].length;var t=Array(n),r=0;for(e=0;e<o;e++)for(var i=arguments[e],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([0,0],l)),"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+u.join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},flatten_contiguous_range:{mainFunc:function(n,e){var o=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+o.channel+",\n            "+o.width_shape+",\n            "+o.height_shape+",\n            "+o.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},flatten2:cn,greater_than:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},reduce_sum:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+e.inputs_dim+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},where:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"],condition:["getValueFromTensorPos"]}},connect:{mainFunc:function(n,e){var o=n.out,t=o.total_shape,r=o.width_shape,i=o.height_shape,s=o.channel,a=g([t/(r*i*s),s,i,r]),u=Object.keys(n).filter((function(n){return"out"!==n})).map((function(e){return n[e].total_shape})),l=u.map((function(n,e){return u.slice(0,e+1).reduce((function(n,e){return n+e}),0)})),f="";return l.forEach((function(n,e){f+=0===e?"\n            if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin_"+e+"(sumVal - "+l[e-1]+");\n                o = getValueFromTensorPos_origin_"+e+"(co.r, co.g, co.b, co.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * "+a[2]+" + oPos.a;\n        "+f+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},reduce_mean:{mainFunc:function(n,e){var o=e.inputs_dim;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+o+"; i++) {\n            oPos["+e.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float("+o+");\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},hard_swish:{mainFunc:function(n,e){var o=e.offset,t=void 0===o?3:o,r=e.scale,i=void 0===r?6:r,s=e.threshold;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float("+t+")), float("+(void 0===s?6:s)+")) / float("+i+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},nearest_interp:Pn,nearest_interp_v2:Pn,cast:{mainFunc:function(n,e){var o="";switch(e.out_dtype){case 0:o="\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);";break;case 1:case 2:case 3:o="\n            int res_int = int(o);\n            setOutput(float(res_int));";break;default:o="       \n            float res_float = o;\n            setOutput(res_float);"}return"\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        "+o+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},fill_constant_batch_size_like:{mainFunc:function(n,e){return"\n    // start函数\n    void main(void) {\n        float res = float("+e.value+");\n        setOutput(res);\n    }\n"}},rnn_matmul:{mainFunc:function(n,e){var o=n.weightlist_0,t=e.input_axis,r=e.state_axis,i=e.batch,s=e.reverse,a=void 0!==s&&s?i-t-1:t;return"\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if ("+(0===t)+") {\n            res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n        for (int j = 0; j < "+o.width_shape+"; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], "+r+", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"]}},rnn_hidden:{mainFunc:function(n,e){var o=e.state_axis,t=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+o+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_cell:{mainFunc:function(n,e){var o=e.state_axis,t=e.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+o+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_origin:{mainFunc:function(n,e){var o=n.weightlist_0,t=n.weightlist_1,r=e.state_axis;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < "+o.width_shape+"; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < "+t.width_shape+"; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, "+r+", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"],weightlist_1:["getValueFromTensorPos"],weightlist_2:["getValueFromTensorPos"],weightlist_3:["getValueFromTensorPos"]}},pool2d_avg:{mainFunc:function(n,e){var o=n.origin,t=e.strides,r=void 0===t?[]:t,i=e.paddings,s=void 0===i?[]:i,a=e.ksize,u=r[0],l=void 0===u?1:u,f=r[1],c=void 0===f?1:f,_=s[0],g=void 0===_?0:_,h=s[1],d=void 0===h?0:h,p=a[0],m=a[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+l+" - "+g+";\n        int ox_base = out_pos[3] * "+c+" - "+d+";\n        for (int fy = 0; fy < "+p+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+o.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+m+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+o.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float("+p+" * "+m+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["setPacked","setAdaptive","isGlobalPooling"]},prelu:pn("prelu"),relu6:pn("relu6"),leakyRelu:pn("leakyRelu"),scale:pn("scale"),sigmoid:pn("sigmoid"),relu:pn("relu"),hard_sigmoid:pn("hard_sigmoid"),pow:pn("pow"),sqrt:pn("sqrt"),tanh:pn("tanh"),exp:pn("exp"),squeeze2:mn,pad3d:{mainFunc:function(n,e){var o=n.origin,t=e.paddings,r=e.mode,i=e.value,s=function(n){var e=n.total_shape,o=n.channel,t=n.height_shape,r=n.width_shape;return[e/o/t/r,o,t,r]}(o),a={reflect:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = "+t[0]+" - oPos.a;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - (oPos.a - "+t[0]+" - "+s[3]+" + 1) - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = "+t[2]+" - oPos.b;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - (oPos.b - "+t[2]+" - "+s[2]+" + 1) - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",replicate:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = 0;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = 0;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",circular:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = int(mod(float("+t[0]+" + oPos.a - 1), float("+s[3]+")));\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = int(mod(float(oPos.a - "+t[0]+" - "+s[3]+"), float("+s[3]+")));\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = int(mod(float("+t[2]+" + oPos.b - 1), float("+s[2]+")));\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = int(mod(float(oPos.b - "+t[2]+" - "+s[2]+"), float("+s[2]+")));\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",constant:"",undefined:""};return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = "+(i||"0.0")+";\n        if (oPos.a - "+t[0]+" >= 0\n            && oPos.b - "+t[2]+" >= 0\n            && oPos.a - "+t[0]+" < "+s[3]+"\n            && oPos.b - "+t[2]+" < "+s[2]+"\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - "+t[2]+", oPos.a - "+t[0]+");\n        }\n        else {\n            "+a[r]+"\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},bilinear_interp_v2:gn,shuffle_channel:{mainFunc:function(n,e){var o=n.out,t=e.group,r=void 0===t?2:t,i=o.total_shape,s=o.height_shape,a=o.width_shape,u=o.channel,l=[1,0,2,3];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * "+a+"\n            + oPos.g * "+s+" * "+a+"\n            + oPos.r * "+u+" * "+a+" * "+s+";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+r+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos["+l[0]+"],\n            transpose_out_pos["+l[1]+"], transpose_out_pos["+l[2]+"], transpose_out_pos["+l[3]+"]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * "+a+"\n            + transpose_in_pos.g * "+s+" * "+a+"\n            + transpose_in_pos.r * "+u/r+" * "+a+" * "+s+";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            "+u+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},pack_out:{mainFunc:function(n,e){return"\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},nhwc_2_nchw:{mainFunc:function(n,e){var o=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * "+t.channel+"\n            + oPos.b * "+t.width_shape+" * "+t.channel+"\n            + oPos.g\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+o.channel+",\n            "+o.width_shape+",\n            "+o.height_shape+",\n            "+o.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},feedPost:{mainFunc:function(n,e){var o=n.out,t=e.mean,r=void 0===t?[0,0,0]:t,i=e.std,s=void 0===i?[1,1,1]:i,a=o.total_shape,u=o.height_shape,l=o.width_shape,f=o.channel;return"\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * "+l+"\n            + nhwcPos.g * "+u+" * "+l+"\n            + nhwcPos.r * "+f+" * "+l+" * "+u+";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+f+",\n            "+l+",\n            "+u+",\n            "+a+"\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float("+r[0]+")) / float("+s[0]+");\n        } else if (c == 1) {\n            res = (res - float("+r[1]+")) / float("+s[1]+");\n        } else if (c == 2) {\n            res = (res - float("+r[2]+")) / float("+s[2]+");\n        }\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]},commonFuncConf:["transferFromNHWCtoNCHW"]},imgFeed:{mainFunc:function(){return"\n    uniform vec2 u_scale;\n    uniform int u_keep_ratio;\n\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        // 支持模型不按比例拉伸\n        if (u_keep_ratio == 0) {\n            vec4 origin = TEXTURE2D(texture_origin, outCoord);\n            setPackedOutput(origin);\n            return;\n        }\n        float startX = (1.0 - u_scale.x) / 2.0;\n        float endX = startX + u_scale.x;\n        float startY = (1.0 - u_scale.y) / 2.0;\n        float endY = startY + u_scale.y;\n\n        if (outCoord.x >= startX && outCoord.x <= endX && outCoord.y >= startY && outCoord.y <= endY) {\n            vec2 newPos = (outCoord - vec2(startX, startY)) / u_scale;\n            vec4 origin = TEXTURE2D(texture_origin, newPos);\n            setPackedOutput(origin);\n        }\n        else {\n            setPackedOutput(vec4(1.0));\n        }\n    }\n    "},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(n,e){var o="decode_center_size"===e.code_type;return"\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        "+(o?"\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        ":"\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ")+"\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == "+(o?2:1)+") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        "+(o?"\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        ":"\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ")+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{targetbox:["getValueFromTensorPos"],priorbox:["getValueFromTensorPos"],priorboxvar:["getValueFromTensorPos"]},behaviors:[]},density_prior_box:xn,prior_box:Tn,stack:Fn,slice:bn},En=new $;!function(n,e,o){n&&(u.backend=n),e&&(u.backendInstance=e),o&&Object.keys(o).forEach((function(n){!function(n,e){var o=n.conf,t=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,l=n.behaviors,f=void 0===l?[]:l,c=u.backend+"_"+e;u.opRegistry.ops[c]||(u.opRegistry.ops[c]={name:e,conf:o,params:t,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:f})}(o[n],n)}))}("webgl",En,yn)}},e={};function o(t){if(e[t])return e[t].exports;var r=e[t]={exports:{}};return n[t](r,r.exports,o),r.exports}return o.d=(n,e)=>{for(var t in e)o.o(e,t)&&!o.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},o.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),o.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),o.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o(400)})()}));

/***/ }),

/***/ "./node_modules/@paddlejs/paddlejs-core/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@paddlejs/paddlejs-core/lib/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(this,(function(){return(()=>{var t={911:(t,e)=>{"use strict";var r=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==r)return r;throw new Error("unable to locate global object")}();t.exports=e=r.fetch,r.fetch&&(e.default=r.fetch.bind(r)),e.Headers=r.Headers,e.Request=r.Request,e.Response=r.Response},994:(t,e,r)=>{"use strict";r.r(e),r.d(e,{PaddlejsBackend:()=>yt,Runner:()=>mt,Transformer:()=>k,coreUtils:()=>n,env:()=>p,interfaces:()=>i,registerBackend:()=>_,registerOp:()=>w});var n={};r.r(n),r.d(n,{AddItemToVars:()=>u,delUselessData:()=>c,findVarByKey:()=>o,getGlobalInterface:()=>s,getOrMakeGlobalProperty:()=>a,traverseVars:()=>h});var i={};function s(){var t;if("undefined"!=typeof window)t=window;else if(void 0!==r.g)t=r.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}return t}function a(t,e){var r=s();return r[t]||(r[t]=e),r[t]}function o(t,e){return Array.isArray(t)?t.find((function(t){return t.name===e})):t[e]}function u(t,e){var r=Array.isArray(t),n=Array.isArray(e)?e:[e];r?n.forEach((function(e){for(var r=null,n=0;n<t.length;n++)if(t[n].name===e.name){r=n;break}null!==r?t[r]=e:t.push(e)})):n.forEach((function(e){t[e.name]=e}))}function h(t,e){Array.isArray(t)?t.forEach((function(t){e(t)})):Object.keys(t).forEach((function(r){e(t[r])}))}function c(t){if(t.ops=null,t.vars instanceof Array)for(var e=0;e<t.vars.length;e++)t.vars[e].data&&delete t.vars[e].data;else for(var r in t.vars)t.vars[r].data&&delete t.vars[r].data}r.r(i),r.d(i,{BufferType:()=>v,GraphType:()=>y,UniformType:()=>m,WasmMemoryType:()=>g});const p=a("env",new(function(){function t(){this.ENV={}}return t.prototype.set=function(t,e){this.ENV[t]=e},t.prototype.get=function(t){return this.ENV[t]},t}()));var f=function(t,e,r,n){return new(r||(r=Promise))((function(i,s){function a(t){try{u(n.next(t))}catch(t){s(t)}}function o(t){try{u(n.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(a,o)}u((n=n.apply(t,e||[])).next())}))},l=function(t,e){var r,n,i,s,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&s[0]?n.return:s[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,s[1])).done)return i;switch(n=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,n=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((i=(i=a.trys).length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){a.label=s[1];break}if(6===s[0]&&a.label<i[1]){a.label=i[1],i=s;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(s);break}i[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],n=0}finally{r=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}};const d=function(){function t(t){this.urlConf={dir:"",main:""},this.separateChunk=!0,this.chunkNum=1,this.dataType="binary",this.params={type:"fetch"},this.inNode=!1,this.isLocalFile=!1,this.realFetch=function(){throw new Error("ERROR: empty fetch funciton")};var e=t,r="model.json";if(t.endsWith(".json")){var n=t.lastIndexOf("/")+1;e=t.substr(0,n),r=t.substr(n)}else"/"!==t.charAt(t.length-1)&&(e=t+"/");this.isLocalFile=0!==e.indexOf("http"),this.urlConf={dir:this.isLocalFile?"/"===e.charAt(0)?""+e:"/"+e:e,main:r},this.inNode="node"===p.get("platform")}return t.prototype.load=function(){return f(this,void 0,void 0,(function(){var e;return l(this,(function(r){switch(r.label){case 0:return[4,this.fetchModel()];case 1:return e=r.sent(),this.separateChunk=!!e.chunkNum&&e.chunkNum>0,this.chunkNum=this.separateChunk?e.chunkNum:0,this.separateChunk?"binary"!==this.dataType?[3,3]:[4,this.fetchChunks().then((function(r){return t.allocateParamsVar(e.vars,r)}))]:[3,3];case 2:r.sent(),r.label=3;case 3:return[2,e]}}))}))},t.prototype.fetchOneChunk=function(t){return f(this,void 0,void 0,(function(){return l(this,(function(e){switch(e.label){case 0:return p.get("fetch")?[4,p.get("fetch")(t,{type:"arrayBuffer"})]:[3,2];case 1:return[2,e.sent()];case 2:return[2,this.fetch(t).then((function(t){return t.arrayBuffer()}))]}}))}))},t.prototype.fetchJson=function(t){return this.fetch(t).then((function(t){return t.json()}))},t.prototype.getFileName=function(t){return"chunk_"+t+".dat"},t.prototype.fetchChunks=function(){return f(this,void 0,void 0,(function(){var t,e,r;return l(this,(function(n){for(t=this.chunkNum,e=[],r=1;r<=t;r++)e.push(this.fetchOneChunk(this.urlConf.dir+this.getFileName(r)));return[2,Promise.all(e).then((function(t){var e,r=0,n=[];t.forEach((function(t){e=new Float32Array(t),n.push(e),r+=e.length}));var i=new Float32Array(r),s=0;return n.forEach((function(t){t.forEach((function(t){i[s]=t,s+=1}))})),i}))]}))}))},t.allocateParamsVar=function(t,e){var r,n=0,i=Array.isArray(e)?e:Object.values(e);h(t,(function(t){r=t.shape.reduce((function(t,e){return t*e})),t.persistable&&(t.data=i.slice(n,n+r),n+=r)}))},t.prototype.fetch=function(t,e){if(p.get("fetch"))return p.get("fetch")(t,e||{});var n=(e||this.params).method||"get",i=new(this.inNode?r(911).Headers:Headers);return this.realFetch=this.inNode?this.isLocalFile?this.fetchLocalFile:r(911):window.fetch.bind(window),this.realFetch(t,{method:n,headers:i})},t.prototype.fetchLocalFile=function(t){var e=r(993);return new Promise((function(r,n){try{r(e.readFileSync(t,"utf8"))}catch(t){n(t)}}))},t.prototype.fetchModel=function(){var t=this,e=this.params,r=this.urlConf.dir+this.urlConf.main,n=null;return"fetch"===e.type&&(n=new Promise((function(n,i){t.fetch(r,e).then((function(e){return p.get("fetch")?e:t.isLocalFile&&t.inNode?JSON.parse(e):e.json()})).then((function(t){return n(t)})).then((function(t){return i(t)}))}))),n},t}();var v,g,m,y;!function(t){t.FrameBuffer="frameBuffer",t.ColorBuffer="colorBuffer"}(v||(v={})),function(t){t.memory100="100",t.memory200="200",t.memory300="300",t.memory400="400",t.memory500="500",t.memory600="600",t.memory700="700",t.memory800="800",t.memory900="900"}(g||(g={})),function(t){t.uniform1f="1f",t.uniform1fv="1fv",t.uniform1i="1i",t.uniform1iv="1iv",t.uniform2f="2f",t.uniform2fv="2fv",t.uniform2i="2i",t.uniform2iv="2iv",t.uniform3f="3f",t.uniform3fv="3fv",t.uniform3i="3i",t.uniform3iv="3iv",t.uniform4f="4f",t.uniform4fv="4fv",t.uniform4i="4i",t.uniform4iv="4iv"}(m||(m={})),function(t){t.SingleOutput="single",t.MultipleOutput="multiple",t.MultipleInput="multipleInput"}(y||(y={}));var b={opRegistry:{ops:{}},backend:"",backendInstance:null};function w(t,e){var r=t.conf,n=t.params,i=t.main,s=t.mainFunc,a=t.textureFuncConf,o=t.commonFuncConf,u=t.behaviors,h=void 0===u?[]:u,c=b.backend+"_"+e;b.opRegistry.ops[c]||(b.opRegistry.ops[c]={name:e,conf:r,params:n,main:i,mainFunc:s,textureFuncConf:a,commonFuncConf:o,behaviors:h})}function _(t,e,r){t&&(b.backend=t),e&&(b.backendInstance=e),r&&Object.keys(r).forEach((function(t){w(r[t],t)}))}b=a("GLOBALS",b);var A=s();A.ImageBitmap||(A.ImageBitmap=function(){});const x=function(){function t(t,e){this.id="",this.type="",this.inputs={},this.outputs={},this.attrs={},this.subAttrs=[],this.next="",this.opData=null,this.isPacked=!1,this.bufferType=v.FrameBuffer,this.uniform=null;var r=t.inputs,n=t.outputs,i=t.attrs,s=void 0===i?{}:i,a=t.type,o=t.isPacked,u=void 0!==o&&o,h=t.bufferType,c=void 0===h?v.FrameBuffer:h,p=t.uniform,f=void 0===p?null:p;this.id=a+"_"+ +new Date+"_"+e,this.inputs=r,this.outputs=n,this.attrs=s,this.subAttrs=t["sub-attrs"]||[],this.uniform=f,this.type=a,this.isPacked=u,this.bufferType=c,this.next="",this.opData=null}return Object.defineProperty(t.prototype,"inputsName",{get:function(){var t=this,e=[];return Object.keys(this.inputs).forEach((function(r){e.push(t.inputs[r][0])})),e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"outputsName",{get:function(){return this.outputs.Output||this.outputs.Out||this.outputs.Y},enumerable:!1,configurable:!0}),t.prototype.execute=function(t){b.backendInstance.runProgram(this.opData,t)},t}(),k=function(t){this.name=t};var O,P=(O=function(t,e){return(O=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(t,e)},function(t,e){function r(){this.constructor=t}O(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}),T={conv2d:function(t,e){var r=t.attrs.strides,n=t.inputs.Input[0],i=t.inputs.Filter[0];if("image"===n)return!1;var s=o(e,n).shape,a=o(e,i).shape;return!r.find((function(t){return t>1}))&&s[s.length-1-2]%4==0&&4===a.length&&a[0]%4==0&&a[1]%4==0}};function j(t){return{type:"packed_2_unpacked",attrs:{},inputs:{Input:[t.inputName]},outputs:{Output:[t.outputName]}}}function M(t){return{type:"unpacked_2_packed",attrs:{},inputs:{Input:[t.inputName]},outputs:{Output:[t.outputName]}}}function E(t,e){Object.keys(t.inputs).forEach((function(e){t.inputs[e]=[t.inputs[e]+"_packed"]})),Object.keys(t.outputs).forEach((function(e){t.outputs[e]=[t.outputs[e]+"_packed"]})),t.type=t.type+"_packing",t.id=t.type+"_"+ +new Date+"_"+e.length,t.isPacked=!0}const F=function(t){function e(){return t.call(this,"TexturePacking")||this}return P(e,t),e.prototype.transform=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];if("webgl"===b.backend&&p.get("webgl_pack_channel")){var r=t[0],n=t[1],i=t[2],s="depthwise_conv2d"===r.type?"conv2d":r.type,a=T[s];if(a&&a(r,n)){var o=r.inputs,u=r.outputs,h=o.Input[0],c=u.Output?u.Output[0]:u.Out[0],f=M({inputName:h,outputName:h+"_packed"}),l=i.length;i.push(new x(f,l)),E(r,i);var d=j({inputName:c+"_packed",outputName:c}),v=i.length+1;i.push(new x(d,v))}}},e}(k);var D=function(){var t=function(e,r){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(e,r)};return function(e,r){function n(){this.constructor=e}t(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}}();const N=function(t){function e(){return t.call(this,"FormatInputsX")||this}return D(e,t),e.prototype.transform=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];var r=t[0],n=["concat","connect","fc","rnn_origin","rnn_matmul","stack"];if(n.includes(r.type)){var i=r.inputs;if(("rnn_origin"===r.type||"rnn_matmul"===r.type)&&i.WeightList.length>0)i.WeightList.forEach((function(t,e){i["weightlist_"+e]=[t]}));else{var s=i.X||i.Input;if("wasm"!==p.get("backend"))s.length>1&&(s.forEach((function(t,e){i["origin"+(e>0?"_"+e:"")]=[t]})),delete i.X,delete i.Input);else{if(s.length>4)throw Error("Not yet supporting concat input tensors more than 4.");if(s.length>1){var a=s[0],o=s[1],u=s[2],h=s[3];i.X=[a],o&&(i.Y=[o]),u&&(i.Z=[u],r.type+="_mul"),h&&(i.M=[h])}}}}},e}(k);var S=function(){var t=function(e,r){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(e,r)};return function(e,r){function n(){this.constructor=e}t(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}}(),C=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var s=arguments[e],a=0,o=s.length;a<o;a++,i++)n[i]=s[a];return n};function I(t,e){var r=o(e,t);return r?r.shape:[]}function L(t,e,r,n){for(var i=C(e),s=0,a=0,o=t;a<o.length;a++)s+=I(o[a],n)[r];return i[r]=s,{name:t[t.length-1]+"_out",shape:i}}const R=function(t){function e(){return t.call(this,"splitOp")||this}return S(e,t),e.prototype.transform=function(){for(var t,e=[],r=0;r<arguments.length;r++)e[r]=arguments[r];for(var n=e[0],i=e[1],s=0,a=n.length;s<a;s++){var o=n[s];if("concat"===o.type&&(null===(t=o.inputs)||void 0===t?void 0:t.X)&&!(o.inputs.X.length<=4)){var h=o.attrs,c=o.inputs,p=o.outputs,f=c.X,l=f.length,d=Math.ceil((l-4)/3)+1,v=p.Out[0],g=I(v,i),m=h.axis||0;m=m>-1?m:g.length+m;for(var y=[],b=[],w=f.slice(0,4),_=void 0,A=0;A<d;A++){var x=0===A?w:f.slice(3*A+1,3*(A+1)+1),k=L(x,g,m,i);0!==A&&x.splice(0,0,_.name),k.shape[m]+=_?_.shape[m]:0;var O={Out:[k.name]};b.push({attrs:h,inputs:{X:x},outputs:O,type:"concat"}),y.push(k),_=k}b[d-1].outputs.Out=[v],n.splice.apply(n,C([s,1],b)),u(i,y)}}},e}(k);var W=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var s=arguments[e],a=0,o=s.length;a<o;a++,i++)n[i]=s[a];return n};function H(t){if(t.length<4){for(var e=[],r=0;r<4-t.length;r++)e.push(1);return e.concat(t)}return W(t)}function B(t){return t.reduce((function(t,e){return t+e}))}function G(t,e){var r=t.length;return 4-r+(e>-1?e:r+e)}function z(t,e){for(var r=e[0],n=e[1],i=e[2],s=e[3],a=i*s,o=n*i*s,u=[],h=0;h<r;h++)for(var c=0;c<s;c++)for(var p=0;p<n;p++)for(var f=0;f<i;f++)u.push(t[h*o+p*a+f*s+c]);return new Float32Array(u)}function X(t){for(var e,r=t.data,n=t.shape,i=W(n).reverse(),s=0,a=i.length-1;s<a;s++)e=V(e||r,i[s]);return e}function V(t,e){for(var r=[],n=0,i=t.length;n<i;n+=e)r.push(t.slice(n,n+e));return r}var U=function(){var t=function(e,r){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(e,r)};return function(e,r){function n(){this.constructor=e}t(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}}(),Y="fetch_pack";const q=function(t){function e(){return t.call(this,"PackOut")||this}return U(e,t),e.prototype.transform=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];if(p.get("webgl_pack_output")&&1!==p.get("webglVersion")){var r=t[0],n=t[1],i=r.find((function(t){return"fetch"===t.type})),s=i.inputs.X[0],a=o(n,s),h=H(a.shape),c=h[0],f=h[1],l=h[2],d=h[3],v={attrs:{},inputs:{X:[s]},outputs:{Y:[Y]},type:"pack_out"},g=f*d,m=Math.ceil(c*l/4),y={name:Y,shape:[1,1,m,g],persistable:!1};i.inputs.X=[Y],i.attrs.origin_shape=[c,f,l,d],r.push(v),u(n,[y])}},e}(k);var J=function(){var t=function(e,r){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(e,r)};return function(e,r){function n(){this.constructor=e}t(e,r),e.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}}(),K="img_pre_processed",Z="img_origin";const $=function(t){function e(){return t.call(this,"FeedProcess")||this}return J(e,t),e.prototype.transform=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];var r=t[0],n=t[1],i=t[2];if(i.webglFeedProcess||p.get("webgl_gpu_pipeline")){var s=i.mean,a=void 0===s?[0,0,0]:s,h=i.std,c=void 0===h?[1,1,1]:h,f=i.scale,l=void 0===f?[1,1]:f,d=i.pos,v=void 0===d?[0,0]:d,g=i.feedShape,y=o(n,"image"),b=y.shape,w=b[2],_=b[3];y.shape=[1,1,w,_];var A=Object.assign({},y);A.name=K,A.shape=[1,3,g.fh,g.fw],A.persistable=!1,delete A.data;var x=Object.assign({},y);x.name=Z,x.shape=[1,1,g.fh,g.fw],x.persistable=!1,delete x.data,u(n,[x,A]);var k=r.find((function(t){var e=t.inputs;return Object.keys(e).find((function(t){return"image"===e[t][0]}))})),O=k.inputs;Object.keys(O).forEach((function(t){"image"===O[t][0]&&(O[t][0]=K)}));var P={attrs:{mean:a,std:c},inputs:{X:[Z]},outputs:{Y:[K]},type:"feedPost"},T={attrs:{mean:a,std:c,scale:l,pos:v},inputs:{X:["image"]},outputs:{Y:[Z]},type:"imgFeed",uniform:{u_scale:{type:m.uniform2fv,value:[1,1]},u_pos:{type:m.uniform2fv,value:[0,0]},u_keep_ratio:{type:m.uniform1i,value:1}},isPacked:!0};r.splice(1,0,P),r.splice(1,0,T)}},e}(k),Q={preTransforms:[new R,new q,new $],transforms:[new N,new F],postTransforms:[]};var tt,et=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var s=arguments[e],a=0,o=s.length;a<o;a++,i++)n[i]=s[a];return n};function rt(t,e){return t&&t[e]||[]}!function(t){t.PreTransforms="preTransforms",t.Transforms="transforms",t.PostTransforms="postTransforms"}(tt||(tt={}));const nt=function(){function t(t,e){this.weightMap=[],this.ops=[],this.vars=[],this.config={},this.type=y.SingleOutput,this.plugins=null,this.ops=t.ops,this.vars=t.vars,this.type=e.type||this.type,this.plugins=e.plugins,this.config=e,t.feedShape&&(this.config.feedShape=t.feedShape)}return t.prototype.createGraph=function(){return this.preTransforms(),this.createOpsMap(),this.arrangeMap(),this.postTransforms(),this.weightMap},t.prototype.preTransforms=function(){var t=this;et(Q.preTransforms,rt(this.plugins,tt.PreTransforms)).forEach((function(e){e.transform(t.ops,t.vars,t.config)}))},t.prototype.transforms=function(t,e){var r=this;et(Q.transforms,rt(this.plugins,tt.Transforms)).forEach((function(n){n.transform(t,r.vars,e)}))},t.prototype.postTransforms=function(){var t=this;et(Q.postTransforms,rt(this.plugins,tt.PostTransforms)).forEach((function(e){e.transform(t.weightMap,t.vars,t.type)}))},t.prototype.createOpsMap=function(){for(var t=[],e=0;e<this.ops.length;e++){var r=t.length,n=this.ops[e],i=new x(n,r);this.transforms(i,t),t.push(i)}this.weightMap=t},t.prototype.arrangeMap=function(){for(var t={},e=[],r={},n=function(n){for(var s=i.weightMap[n],a=0;a<s.outputsName.length;a++){var o=s.outputsName[a];t[o]=!0}e[n]=0,r[s.id]=n,s.inputsName.length>1?s.inputsName.forEach((function(r){!0===t[r]&&e[n]++})):e[n]=s.inputsName.length},i=this,s=0;s<this.weightMap.length;s++)n(s);this.topoSort(this.weightMap,e,r)},t.prototype.topoSort=function(t,e,r){var n=[];n.push(t[0]);for(var i=t.slice(0),s=null,a=t[0];n.length>0;){null!=s&&(t[r[s.id]].next=a.id),s=a,a=n.pop()||{};for(var o=0;o<a.outputsName.length;o++)for(var u=0;u<i.length;u++)for(var h=0;h<i[u].inputsName.length;h++)if(i[u].inputsName[h]===a.outputsName[o]&&(e[r[i[u].id]]--,0===e[r[i[u].id]])){n.push(t[r[i[u].id]]),i.splice(u,1),u--;break}}},t.prototype.getFeedExecutor=function(){return this.weightMap.find((function(t){return"feed"===t.type}))},t.prototype.getFetchExecutor=function(){return this.weightMap.find((function(t){return"fetch"===t.type}))},t.prototype.getExecutorById=function(t){return this.weightMap.find((function(e){return e.id===t}))},t}(),it=function(){function t(t){this.opts={},this.isPacked=!1,this.name="",this.tensorId="",this.total=1,this.shape=[],this.unformattedShapeLength=0,this.shape_texture=[],this.exceedMax=!1,this.data=null,this.persistable=!1,this.interpType="NEAREST",this.dataLayout="",this.runtime=0,this.binding=0;var e=t.isPacked,r=void 0!==e&&e,n=t.name,i=t.runtime,s=void 0===i?0:i,a=t.persistable,o=void 0!==a&&a,u=t.type,h=t.dataLayout,c=t.interpType,p=void 0===c?"NEAREST":c,f=t.shape,l=t.data,d=t.binding,v=void 0===d?0:d;this.opts=t,this.isPacked=r,this.name=n,this.runtime=s,this.binding=v,this.persistable=o,this.interpType=p,this.tensorId=u,this.dataLayout=h,this.unformattedShapeLength=f.length,this.shape=H(f),this.total=this.shape.reduce((function(t,e){return t*e})),t.noLayout||l&&l.length&&(this.data=function(t,e,r,n){if("nhwc"===e){var i=r[0],s=r[1],a=z(t,[i,r[2],r[3],s*(n?4:1)]);return new Float32Array(a)}return new Float32Array(t)}(l,this.dataLayout,this.shape,this.isPacked),t.data=null)}return Object.defineProperty(t.prototype,"width_texture",{get:function(){var t=this.shape_texture.length;return this.shape_texture[t-1]||1},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height_texture",{get:function(){var t=this.shape_texture.length;return this.shape_texture[t-2]||1},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"width_shape",{get:function(){var t=this.shape.length;return this.shape[t-1]},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height_shape",{get:function(){var t=this.shape.length;return this.shape[t-2]},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"channel",{get:function(){var t=this.shape.length;return this.shape[t-3]},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"length_shape",{get:function(){return this.shape.length||0},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"length_unformatted_shape",{get:function(){return this.unformattedShapeLength||0},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"total_shape",{get:function(){return this.total},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"numbers_shape",{get:function(){for(var t=[],e=this.shape.length,r=0;r<e-1;r++){var n=this.shape.slice(r+1).reduce((function(t,e){return t*e}));t.push(n)}return t.push(1),t},enumerable:!1,configurable:!0}),t}(),st={adaptPaddings:function(){for(var t in this.processedAttrs)if(Object.prototype.hasOwnProperty.call(this.processedAttrs,t)&&"paddings"===t){var e=this.processedAttrs[t],r=e[0],n=e[1];return void(0===r&&1===n&&(this.processedAttrs[t][1]=0))}},setAdaptive:function(){this.processedAttrs.adaptive&&2===this.processedAttrs.ksize.length&&1===this.processedAttrs.ksize[0]&&1===this.processedAttrs.ksize[1]&&(this.processedAttrs.adaptive=!1,this.processedAttrs.global_pooling=!0)},isGlobalPooling:function(){var t,e=this.tensorDataMap.origin,r=(null===(t=null==e?void 0:e.shape)||void 0===t?void 0:t.length)||0;r>2&&this.processedAttrs.global_pooling&&(this.processedAttrs.ksize=[e.shape[r-2],e.shape[r-1]])},setPacked:function(){var t=this.processedAttrs.ispacked;this.tensorDataMap.origin&&t&&this.name.indexOf("pool")>-1&&(this.name+="_winograd")},mergeAttrs:function(){this.processedAttrs=this.subAttrs.reduce((function(t,e){return Object.assign(t,e)}),{})},isApplySeparableConv:function(){if(!this.isPackedOp){var t=this.processedAttrs.groups,e=this.tensorDataMap.filter;if("depthwise_conv2d"===this.name&&(this.name="conv2d"),e){var r=e.shape,n=r[0],i=r[1];n===t&&1===i&&(this.name+="_depthwise")}}},batchComputeConv2d:function(){var t=this.tensorDataMap.filter.shape[1];this.processedAttrs.filter_nearest_vec4=4*Math.floor(t/4),this.processedAttrs.filter_remainder_vec4=t%4},processBias:function(){var t=this.tensorDataMap.bias;if(t&&this.isPackedOp){t.packed=!0;var e=t.shape,r=[e[e.length-1]/4,1,1];t.shape=r}},isAdaptiveAvg:function(){var t=this.processedAttrs,e=t.adaptive,r=t.pooling_type;e&&"avg"===r&&(this.name+="_avg_adaptive")},isMax:function(){var t="max"===this.processedAttrs.pooling_type?1:0;this.processedAttrs.pooling_type=t,1===t&&(this.name+="_max")},transToPrelu:function(){this.processedAttrs.multi_value="0.0",this.processedAttrs.active_function="prelu"},transToRelu6:function(){this.processedAttrs.multi_value=this.processedAttrs.threshold,this.processedAttrs.active_function="relu6"},transToHardSigmoid:function(){this.processedAttrs.multi_value=this.processedAttrs.slope||.2,this.processedAttrs.bias_value=this.processedAttrs.offset||.5,this.processedAttrs.active_function="hardSigmoid"},transToLeakyrelu:function(){this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu",this.name="relu"},transToPow:function(){this.processedAttrs.multi_value=this.processedAttrs.factor||2,this.processedAttrs.active_function="pow_func",this.name="pow"},transToSigmoid:function(){this.processedAttrs.active_function="sigmoid"},transToSqrt:function(){this.processedAttrs.active_function="sqrt"},transToTanh:function(){this.processedAttrs.active_function="tanh_func"},transToExp:function(){this.processedAttrs.active_function="exp"},transToScale:function(){var t=this.processedAttrs.scale;this.processedAttrs.multi_value=void 0!==t?t:1,this.processedAttrs.bias_value=this.processedAttrs.bias||0;var e=this.processedAttrs.bias_after_scale;this.processedAttrs.active_function=e||void 0===e?"scale":"scaleWidthBias"},setActiveFunc:function(){var t=this.name.replace("conv2d-elementwise_add-","");this.processedAttrs=Object.assign({active_function:"scale",multi_value:"1.0",bias_value:"0.0",fuse_relu:!1},this.processedAttrs),"leaky_relu"===t&&(this.processedAttrs.multi_value=this.processedAttrs.alpha,this.processedAttrs.active_function="leakyRelu")},normalizePerm:function(){var t=this.tensorDataMap.origin.shape.length,e=this.processedAttrs.axis,r=e.length;if(r-t>0&&(r=(e=e.map((function(t){return t-1})).filter((function(t){return t>=0}))).length),r>4)throw Error("op transpoes2 axis length exceeds maximum length 4, get "+r);for(var n=new Array(r).fill(0),i=0;i<r;i++)n[e[i]]=i;var s=[];for(i=0;i<4;i++)s[i]=n[i]||0;this.processedAttrs.perm_arr=s,this.processedAttrs.perm_size=r},normalizeDim:function(){for(var t=this.tensorDataMap.origin.shape,e=H(t),r=G(t,this.processedAttrs.axis),n=[],i=0;i<e[r];i++)n[i]=i;if(this.processedAttrs.target_length=n.length,this.processedAttrs.target_value=n,this.processedAttrs.inputs_dim=e[r],this.processedAttrs.dim=r,0===this.processedAttrs.num&&(this.processedAttrs.num=Object.values(this.tensorDataMap).filter((function(t){return"out"===t.tensorName})).length||1),"wasm"===p.get("backend")){this.processedAttrs.fourInputs=!1;var s=this.tensorDataMap.counter;if(s){var a=H(s.shape);this.processedAttrs.counter_num=a[r]}var o=this.tensorDataMap.appender;if(o){var u=H(o.shape);this.processedAttrs.append_num=u[r]}var h=this.tensorDataMap.fourth;if(h){this.processedAttrs.fourInputs=!0;var c=H(h.shape);this.processedAttrs.fourth_num=c[r]}}},processElementwiseAxis:function(){var t=this.tensorDataMap.origin.shape,e=this.tensorDataMap.counter.shape,r=void 0===this.processedAttrs.axis?-1:this.processedAttrs.axis;this.processedAttrs.counterLen=e.length,B(t)===B(e)?(this.processedAttrs.axis=0,this.processedAttrs.counterLen=4):(-1===r&&(r=t.length-e.length),this.processedAttrs.axis=G(t,r))},genElementwiseCounterPos:function(){for(var t=this.processedAttrs,e=t.counterLen,r=["0","0","0","0"],n=t.axis,i=4-e;i<4;i++)r[i]="oPos["+n+++"]";this.processedAttrs.counterPos=r.join(",")},flattenShape:function(){var t=Object.values(this.tensorDataMap).find((function(t){return t.shape.length>2}));if(t){var e=H(t.shape);t.shape=[e[0]*e[2],e[1]*e[3]]}},reshape:function(){var t=this.tensorDataMap.origin,e=this.tensorDataMap.counter,r=this.tensorDataMap.out;if(e.shape.length>t.shape.length){var n=e;e=t,t=n}if(t.shape.length>2&&2===e.shape.length){var i=function(t,e){void 0===t&&(t=[]),void 0===e&&(e=[]);var r=t.reduce((function(t,e){return t*e}));return 1===e.length?[1,r]:[e[0],r/e[0]]}(t.shape,r.shape);t.shape=i}},checkIsMerge:function(){var t=this.name.replace("conv2d-elementwise_add-","");this.name="conv2d_elementwise_add","leaky_relu"===t&&(this.processedAttrs.alpha&&(this.processedAttrs.multi_value=this.processedAttrs.alpha),this.processedAttrs.active_function="leakyRelu")}};var at=function(){return(at=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var i in e=arguments[r])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};const ot=function(){function t(t,e,r,n,i){this.name="",this.isPackedOp=!1,this.processedAttrs={},this.subAttrs=[],this.uniform=null,this.inputTensors=[],this.outputTensors=[],this.dataLayout="",this.iLayer=0,this.program=[],this.isFinalOp=!1,this.bufferType=v.FrameBuffer,this.tensorDataMap={},this.tensorData=[];var s=t.type,a=t.inputs,o=t.outputs,u=t.attrs,h=t.isPacked,c=t.bufferType,p=void 0===c?v.FrameBuffer:c,f=t.uniform,l=void 0===f?null:f;this.modelName=i,this.subAttrs=t.subAttrs,this.name=s,this.isPackedOp=h,this.bufferType=p,this.dataLayout=r.dataLayout||"",this.iLayer=e,this.isFinalOp=n,this.uniform=l,this.initExtendedAttrs(u),this.constructTensorData(a,o,r.vars),this.buildTensor();var d=this.buildShaderParams();this.buildProgram(d)}return t.prototype.initExtendedAttrs=function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)){var r=t[e];this.processedAttrs[e]=r}},t.prototype.constructTensorData=function(t,e,r){var n=this;Object.keys(e).forEach((function(t){e[t].forEach((function(i,s){e[t][s]=n.getTensorVar(i,r)}))})),Object.keys(t).forEach((function(e){t[e]=[n.getTensorVar(t[e][0],r)]}));var i=function(t){if(Object.prototype.hasOwnProperty.call(e,t))try{var r=e[t]||[{}],i=s.getExactTensorName(t,"output");i&&r.forEach((function(t,e){t.tensorName=i,n.tensorDataMap[i+"_"+e]=at(at({},t),{tensorName:i,runtime:e})}))}catch(t){console.error(t)}},s=this;for(var a in e)i(a);for(var a in t)if(Object.prototype.hasOwnProperty.call(t,a)){var o=t[a].length>0?t[a]:[{}],u=this.getExactTensorName(a,"input");if(u){var h=o[0];h.tensorName=u,this.tensorDataMap[u]=at(at({},h),{tensorName:u})}}},t.prototype.getExactTensorName=function(t,e){return"input"===e?{input:"origin",x:"origin",y:"counter",w:"weight"}[t.toLowerCase()]||t.toLowerCase():{output:"out",y:"out",out:"out",scale:"scale",bias:"bias",mean:"mean",variance:"variance",mask:"out",boxes:"out",variances:"out"}[t.toLowerCase()]},t.prototype.getTensorVar=function(t,e){var r=o(e,t.replace(/_packed$/,""));return r&&t.endsWith("_packed")?function(t,e){var r=3===t.shape.length?W([1],t.shape):t.shape,n=r[0],i=r[1],s=r[2],a=r[3],o=Object.assign({},t);if(o.name=e,o.packed=!1,i%4==0){var u=i/4;o.packed=!0,o.shape=[n,u,s,a]}return o}(r,t):r},t.prototype.buildProgram=function(t){var e=this,r=this.name,n=b.backend+"_"+r,i=b.opRegistry.ops[n];try{if(!i&&"wasm"!==p.get("backend"))throw new Error("[unregistered op] "+r);var s=this.inputTensors;this.program=this.outputTensors.map((function(r,n){return b.backendInstance.createProgram({op:i,outTensor:r,inputTensors:s,shaderParams:t[n],runtime:n,isFinalOp:e.isFinalOp})}))}catch(t){console.error(t)}},t.prototype.processTensorDataAndAttrs=function(){var t=this;try{this.name.indexOf("conv2d-elementwise_add")>-1?this.name="conv2d_elementwise_add":this.name.indexOf("max_pool2d_with_index")>-1&&(this.name="pool2d_max");var e=b.backend+"_"+this.name;(b.opRegistry.ops[e]&&b.opRegistry.ops[e].behaviors||[]).forEach((function(e){try{st[e].call(t)}catch(t){console.error(t)}}))}catch(t){console.error(t)}},t.prototype.buildTensor=function(){var t=this;this.processTensorDataAndAttrs();var e=Object.values(this.tensorDataMap);e.forEach((function(e,r){var n,i=e.tensorName,s=new it({type:t.modelName+"_"+e.name,name:i,shape:e.shape,data:e.data||null,persistable:e.persistable||!1,interpType:e.interpType||"NEAREST",isPacked:t.isPackedOp||e.packed||!1,binding:r,noLayout:null===(n=b.backendInstance)||void 0===n?void 0:n.noLayout,dataLayout:t.dataLayout,runtime:e.runtime||0});"out"===i?t.outputTensors.push(s):t.inputTensors.push(s),e.shape=s.shape,e.total=s.total})),this.tensorDataMap=null,this.tensorData=e},t.prototype.buildShaderParams=function(){var t=this,e=[];return this.outputTensors.forEach((function(){var r=JSON.parse(JSON.stringify(t.processedAttrs));e.push(r)})),e},t}();var ut=function(){return(ut=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var i in e=arguments[r])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};const ht=function(){function t(){this.targetContext={},this.gapFillWith="#fff",this.mean=[0,0,0],this.std=[1,1,1],this.bgr=!1,this.pixelWidth=1,this.pixelHeight=1,this.inputFeed=[],this.targetCanvas=p.get("canvas2d")||document.createElement("canvas"),this.targetContext=this.targetCanvas.getContext("2d")}return t.prototype.process=function(t,e,r){var n=e.fill,i=e.mean,s=e.std,a=e.bgr,o=e.keepRatio,u=void 0===o||o,h=e.scale,c=void 0===h?0:h,p=r.fc,f=void 0===p?3:p,l=r.fh,d=r.fw,v=t,g={gapFillWith:n||this.gapFillWith,mean:i||this.mean,std:s||this.std,bgr:a||this.bgr,keepRatio:u,scale:c,targetSize:{width:d,height:l},targetShape:[1,f,l,d]};return this.fromPixels(v,g)||[]},t.prototype.fromPixels=function(t,e){var r=[],n={gapFillWith:e.gapFillWith,dx:0,dy:0,dWidth:e.targetSize.width,dHeight:e.targetSize.height},i=t,s=t.path&&t.width&&t.height;if(!s&&!(t instanceof ImageBitmap||t instanceof HTMLVideoElement||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement))return[{data:r,shape:e.shape||e.targetShape,name:"image",persistable:!0}];this.pixelWidth=t.naturalWidth||t.width,this.pixelHeight=t.naturalHeight||t.height;var a=p.get("webgl_gpu_pipeline")||e.webglFeedProcess;return this.fitToTargetSize(s?i.path:i,n,ut(ut({},e),{inGPU:a})),r=this.getImageData(n),a?[{data:r=Float32Array.from(r.data),shape:[1,1,n.dHeight,n.dWidth],name:"image",persistable:!0}]:[{data:r=this.allReshapeToRGB(r,e),shape:e.targetShape||e.shape,name:"image",persistable:!0}]},t.prototype.allReshapeToRGB=function(t,e){for(var r=e.mean,n=e.std,i=e.targetShape,s=e.bgr,a=e.normalizeType,o=void 0===a?0:a,u=i[1],h=i[2],c=i[3],p=t.data||t,f=new Float32Array(h*c*u),l=0,d=0;d<h;++d)for(var v=d*c,g=0;g<c;++g)for(var m=v+g,y=0;y<u;++y){var b=s?4*m+(2-y):4*m+y;f[l]=0===o?p[b]/255:(p[b]-128)/128,f[l]-=r[y],f[l]/=n[y],l++}return z(f,[1,h,c,u])},t.prototype.fitToTargetSize=function(t,e,r){var n=r||{},i=n.keepRatio,s=void 0===i||i,a=n.inGPU,o=void 0!==a&&a,u=n.scale,h=void 0===u?0:u,c=e.dWidth,p=e.dHeight,f=o?this.pixelWidth:c,l=o?this.pixelHeight:p,d=o?this.pixelWidth:c,v=o?this.pixelHeight:p,g=0,m=0;if(h){if(d-c<0||v-p<0)throw new Error("scale size smaller than target size");this.pixelWidth>this.pixelHeight?(v=h,d=Math.round(v*this.pixelWidth/this.pixelHeight)):(d=h,v=Math.round(d*this.pixelHeight/this.pixelWidth)),this.targetCanvas.width=f=d,this.targetCanvas.height=l=v,e.dx=(d-c)/2,e.dy=(v-p)/2}else s&&(c/p*this.pixelHeight/this.pixelWidth>=1?o?(f=Math.round(v*c/p),g=Math.floor((f-d)/2)):(d=Math.round(v*this.pixelWidth/this.pixelHeight),g=Math.floor((c-d)/2)):o?(l=Math.round(d*p/c),m=Math.floor((l-v)/2)):(v=Math.round(d*this.pixelHeight/this.pixelWidth),m=Math.floor((p-v)/2))),this.targetCanvas.width=e.dWidth=f,this.targetCanvas.height=e.dHeight=l;this.targetContext.fillStyle=e.gapFillWith,this.targetContext.fillRect(0,0,this.targetCanvas.width,this.targetCanvas.height),this.targetContext.drawImage(t,g,m,d,v)},t.prototype.getImageData=function(t){var e=t.dx,r=t.dy,n=t.dWidth,i=t.dHeight;return this.targetContext.getImageData(e,r,n,i)},t.prototype.cover=function(t,e,r,n){var i=r,s=n;return r/n*e/t>=1?i=Math.round(s*t/e):s=Math.round(i*e/t),[i/r,s/n]},t}();var ct=function(){return(ct=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var i in e=arguments[r])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};function pt(t,e,r){for(var n=[],i=0,s=t.length;i<s;i++){var a=t[i];a>e&&n.push({score:a,i})}return n.sort((function(t,e){return e.score-t.score})).slice(0,r)}function ft(t){var e=t[0],r=t[1],n=t[2],i=t[3];return n<e||i<r?0:(n-e)*(i-r)}function lt(t,e){if(e[0]>t[2]||e[2]<t[0]||e[1]>t[3]||e[3]<t[1])return 0;var r=ft(t),n=ft(e),i=function(t,e){var r=t[0],n=t[1],i=t[2],s=t[3],a=e[0],o=e[1],u=e[2],h=e[3],c=Math.max(r,a),p=Math.max(n,o);return(Math.min(i,u)-c)*(Math.min(s,h)-p)}(t,e);return i/(r+n-i)}const dt={multiclass_nms:function(t,e){var r=t[0],n=void 0===r?[]:r,i=t[1],s=void 0===i?[]:i,a=X(n),o=X(s);if(!a||!o)return[];if(a=a[0],o=o[0],!(a&&a.length&&o&&o.length))return[];for(var u=e.nms_top_k,h=void 0===u?100:u,c=e.nms_eta,p=void 0===c?1:c,f=e.keep_top_k,l=void 0===f?100:f,d=e.background_label,v=void 0===d?0:d,g=e.nms_threshold,m=void 0===g?.3:g,y=e.score_threshold,b=void 0===y?0:y,w=[],_=0,A=o.length;_<A;_++){var x=[];if(_!==v){var k=pt(o[_],b,h);if(k&&k.length){var O=k.shift(),P=a[O.i];for(x.push(ct(ct({},O),{box:P,label:_}));k.length;){var T=k.shift();P=a[T.i];for(var j=!0,M=0,E=x;M<E.length;M++)if(lt(P,E[M].box)>m){j=!1;break}j&&x.push(ct(ct({},T),{box:P,label:_})),j&&p<1&&m>.5&&(m*=p)}w=w.concat(x)}}}var F=w.sort((function(t,e){return e.score-t.score})).slice(0,l).sort((function(t,e){return t.label-e.label})).map((function(t){return function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var s=arguments[e],a=0,o=s.length;a<o;a++,i++)n[i]=s[a];return n}([t.label,t.score],t.box)}));return F&&F.length?F:[]}};var vt=function(t,e,r,n){return new(r||(r=Promise))((function(i,s){function a(t){try{u(n.next(t))}catch(t){s(t)}}function o(t){try{u(n.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(a,o)}u((n=n.apply(t,e||[])).next())}))},gt=function(t,e){var r,n,i,s,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&s[0]?n.return:s[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,s[1])).done)return i;switch(n=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,n=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((i=(i=a.trys).length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){a.label=s[1];break}if(6===s[0]&&a.label<i[1]){a.label=i[1],i=s;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(s);break}i[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],n=0}finally{r=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}};const mt=function(){function t(t){this.runnerConfig={},this.isPaused=!1,this.model={},this.weightMap=[],this.isExecuted=!1,this.test=!1,this.graphGenerator={},this.mediaProcessor=null,this.needPreheat=!0,this.feedShape={},this.runnerConfig=Object.assign({},t),this.needPreheat=void 0===t.needPreheat||t.needPreheat,this.modelName=t.modelName||Date.now().toString(),this.weightMap=[],p.set("ns",s()),"node"!==p.get("platform")&&(this.mediaProcessor=new ht)}return t.prototype.init=function(){return vt(this,void 0,void 0,(function(){var t;return gt(this,(function(e){switch(e.label){case 0:return b.backendInstance?(this.isExecuted=!1,"wasm"!==p.get("backend")?[3,2]:[4,Promise.all([this.load(),b.backendInstance.init()])]):(console.error("ERROR: Haven't register backend"),[2]);case 1:return e.sent(),[3,5];case 2:return[4,b.backendInstance.init()];case 3:return e.sent(),[4,this.load()];case 4:e.sent(),e.label=5;case 5:return this.genFeedData(),this.genGraph(),this.genOpData(),"wasm"!==p.get("backend")?[3,7]:(this.model=Object.assign(this.model,this.runnerConfig),t=this.model,[4,b.backendInstance.initWasm(this.model,this.weightMap)]);case 6:return t.index=e.sent(),[2,[]];case 7:return this.needPreheat?[4,this.preheat()]:[3,9];case 8:return[2,e.sent()];case 9:return[2]}}))}))},t.prototype.load=function(){return vt(this,void 0,void 0,(function(){var t,e,r,n,i,s,a,o;return gt(this,(function(u){switch(u.label){case 0:return t=this.runnerConfig,e=t.modelPath,r=t.modelObj,n=void 0===r?null:r,e?(i=new d(e),s=this,[4,i.load()]):[3,2];case 1:return s.model=u.sent(),[3,3];case 2:(null==n?void 0:n.model)&&(null==n?void 0:n.params)&&(a=n.model,o=n.params,d.allocateParamsVar(a.vars,o),this.model=a),u.label=3;case 3:return[2]}}))}))},t.prototype.genGraph=function(){this.graphGenerator=new nt(this.model,this.runnerConfig),this.weightMap=this.graphGenerator.createGraph()},t.prototype.genOpData=function(){var t=this,e=0;this.weightMap.forEach((function(r,n){var i=r.type;if("feed"!==i&&"fetch"!==i){e++;var s=n===t.weightMap.length-2,a=new ot(r,e,t.model,s,t.modelName);r.opData=a}})),c(this.model)},t.prototype.preheat=function(){return vt(this,void 0,void 0,(function(){var t;return gt(this,(function(e){switch(e.label){case 0:return[4,this.checkModelLoaded()];case 1:return e.sent(),[4,this.execute()];case 2:return t=e.sent(),this.isExecuted=!0,[2,t]}}))}))},t.prototype.checkModelLoaded=function(){return vt(this,void 0,void 0,(function(){return gt(this,(function(t){switch(t.label){case 0:return 0!==this.weightMap.length?[3,2]:(console.info("It's better to preheat the model before running."),[4,this.load()]);case 1:t.sent(),this.genFeedData(),this.genGraph(),this.genOpData(),this.isExecuted=!1,t.label=2;case 2:return[2]}}))}))},t.prototype.predict=function(t,e){return vt(this,void 0,void 0,(function(){var r,n,i;return gt(this,(function(s){switch(s.label){case 0:return this.isPaused||!this.mediaProcessor?[2]:(r=[],r=this.runnerConfig.webglFeedProcess?[t]:this.mediaProcessor.process(t,this.runnerConfig,this.feedShape),n=[],"wasm"!==p.get("backend")?[3,3]:[4,b.backendInstance.predict(r[0].data,this.model.index)]);case 1:return s.sent(),[4,this.read()];case 2:return i=s.sent(),n=this.postProcess(i),[3,5];case 3:return this.updateFeedData(r),[4,this.execute()];case 4:n=s.sent(),s.label=5;case 5:return this.isExecuted=!0,[2,e?e(n):n]}}))}))},t.prototype.predictWithFeed=function(t,e,r){var n;return vt(this,void 0,void 0,(function(){var i,s,a,o,u,h,c,f,l,d,v,g;return gt(this,(function(m){switch(m.label){case 0:return i=this.feedShape,s=i.fc,a=void 0===s?3:s,o=i.fw,u=i.fh,Array.isArray(t)?(null===(n=t[0])||void 0===n?void 0:n.data)?((d=t[0].data)instanceof Float32Array||(t[0].data=new Float32Array(d)),h=t):h=[{data:new Float32Array(t),shape:r||[1,a,u,o],name:"image",persistable:!0}]:(f=(c=t).width,l=c.height,d=c.data,h=[{data:new Float32Array(d),shape:r||[1,a,l||u,f||o],name:"image",persistable:!0}]),v=[],"wasm"!==p.get("backend")?[3,3]:[4,b.backendInstance.predict(h[0].data,this.model.index)];case 1:return m.sent(),[4,this.read()];case 2:return g=m.sent(),v=this.postProcess(g),[3,5];case 3:return this.updateFeedData(h),[4,this.execute()];case 4:v=m.sent(),m.label=5;case 5:return this.isExecuted=!0,[2,e?e(v):v]}}))}))},t.prototype.genFeedData=function(){var t,e=this.runnerConfig,r=e.type,n=e.feedShape,i=e.webglFeedProcess;this.feedShape=this.model.feedShape||n;var s,a=this.feedShape,h=a.fc,c=void 0===h?3:h,f=a.fh,l=a.fw,d=this.model.vars;if(r===y.MultipleInput){var v=this.model.ops&&this.model.ops[0]&&(null===(t=this.model.ops[0].inputs)||void 0===t?void 0:t.X);v.length>1&&(s=v.map((function(t){var e=o(d,t),r=e.shape.reverse(),n=r[0],i=r[1],s=r[2],a=r[3],u=void 0===a?1:a;return e.data=new Float32Array(u*s*i*n),e})))}else{var g="wasm"!==p.get("backend")&&i?4:c;s=o(d,"image");var m={name:"image",shape:[1,g,f,l]};s=Object.assign(m,s,{data:new Float32Array(g*f*l).fill(1),persistable:!0})}u(d,s)},t.prototype.updateFeedData=function(t){var e=t[0],r=this.weightMap.find((function(t){return t.opData?t.opData.inputTensors.find((function(t){return t.tensorId.endsWith("_image")})):null})),n=r.opData.inputTensors.find((function(t){return t.tensorId.endsWith("_image")}));n.data=e.data;var i=this.runnerConfig,s=i.webglFeedProcess,a=void 0!==s&&s,o=i.keepRatio,u=void 0===o||o;if(a||p.get("webgl_gpu_pipeline")){var h=e.shape||[1,1,e.height,e.width],c=new Uint8Array(e.data||[]);if(e.width&&e.height&&!e.data){var f=e.naturalWidth||e.width;h=[1,1,e.naturalHeight||e.height,f],c=e}var l=n.opts;l.shape=h;var d=r.opData,v=new it(l);v.data=c,d.inputTensors=[v];var g=h.slice(-2),m=g[0],y=g[1],b=d.outputTensors[0].shape.slice(-2),w=b[0],_=b[1],A=this.mediaProcessor.cover(y,m,_,w);r.uniform.u_scale.value=A,r.uniform.u_keep_ratio.value=+u}},t.prototype.execute=function(){return vt(this,void 0,void 0,(function(){var t,e;return gt(this,(function(r){switch(r.label){case 0:return t=this.graphGenerator.getFeedExecutor(),this.executeOp(t),[4,this.read()];case 1:return e=r.sent(),[2,this.postProcess(e)]}}))}))},t.prototype.postProcess=function(t){var e="wasm"===p.get("backend");if(p.get("debug"))return t;var r=t,n=this.model,i=n.multiOutputs,s=n.postOps;if(i)if(e)r=i.map((function(e,r){var n;return(n={})[e.name]=t[r],n}));else{var a=0;r=i.map((function(e){var r,n=e.shape.reduce((function(t,e){return t*e})),i=t.slice(a,n+a);return a+=n,(r={})[e.name]=i,r}))}if(i&&s&&s.length)for(var o=function(t,e){var n=s[t],i=n.type,a=n.attrs,o=n.inputs,u=dt[i];if(!u)return{value:void 0};var h=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var s=arguments[e],a=0,o=s.length;a<o;a++,i++)n[i]=s[a];return n}(r),c=Object.keys(o).map((function(t){var e=o[t],r=e.name,n=e.shape,i=h.filter((function(t){return t[r]}));return i&&i[0]&&i[0][r]?{name:t,tensorId:r,data:i[0][r],shape:n}:(console.error("未获取到"+r+"的数据"),null)}));r=u(c,a)},u=0,h=s.length;u<h;u++){var c=o(u);if("object"==typeof c)return c.value}return r},t.prototype.executeOp=function(t){var e;if("fetch"!==t.type)if("feed"!==t.type&&t.execute(this.isExecuted),p.get("debug")&&(null===(e=t.opData)||void 0===e?void 0:e.outputTensors)&&t.opData.outputTensors[t.opData.outputTensors.length-1]&&t.opData.outputTensors[t.opData.outputTensors.length-1].tensorId===this.modelName+"_"+(p.get("ns").layerName||p.get("layerName")))console.info(t.opData.name+"_"+t.opData.iLayer,"runner op");else if(t.next){var r=t.next,n=this.graphGenerator.getExecutorById(r);this.executeOp(n)}},t.prototype.read=function(){return vt(this,void 0,void 0,(function(){var t,e,r;return gt(this,(function(n){switch(n.label){case 0:return t=this.graphGenerator.getFetchExecutor(),e=o(this.model.vars,t.inputs.X[0]),r={name:e.name,shape:t.attrs.origin_shape||e.shape,index:this.model.index},[4,b.backendInstance.read(r)];case 1:return[2,n.sent()]}}))}))},t.prototype.stopPredict=function(){this.isPaused=!0},t}(),yt=function(){}},993:()=>{}},e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}return r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r(994)})()}));

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vaW5mZXJlbmNlX2VuZ2luZS9jdXN0b21PcC9zZWdJbWcudHMiLCJ3ZWJwYWNrOi8vLy4vaW5mZXJlbmNlX2VuZ2luZS9jdXN0b21UcmFuc2Zvcm1lci9hcHBlbmRDdXN0b21PcFRvTk4udHMiLCJ3ZWJwYWNrOi8vLy4vaW5mZXJlbmNlX2VuZ2luZS9pbmRleF9ncHUudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwYWRkbGVqcy1tZWRpYXBpcGUvY2FtZXJhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBhZGRsZWpzL3BhZGRsZWpzLWJhY2tlbmQtd2ViZ2wvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcGFkZGxlanMvcGFkZGxlanMtY29yZS9saWIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRmdEO0FBQ2dCO0FBSWhFLElBQU0sZUFBZSxHQUFHLElBQUksQ0FBQztBQUM3QixJQUFNLDBCQUEwQixHQUFHLEVBQUUsQ0FBQztBQUd0QyxJQUFNLFdBQVcsR0FBRyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLElBQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDL0MsSUFBSSxTQUFTLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUM7QUFHcEQsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN4RCxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBcUIsQ0FBQztBQUNuRSxJQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzNELElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFzQixDQUFDO0FBQ3hFLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFzQixDQUFDO0FBQ3pFLElBQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7QUFHNUQsSUFBTSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzFELGdCQUFnQixDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDO0FBQzFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBRTVDLElBQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7QUFDMUIsS0FBSyxDQUFDLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQztBQUMvQixLQUFLLENBQUMsTUFBTSxHQUFHO0lBQ1gsSUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hGLENBQUMsQ0FBQztBQUdGLElBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDM0QsWUFBWSxDQUFDLFNBQVMsR0FBRyxjQUFjLEdBQUcsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBR2xFLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUMvQixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFHbkIsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDekIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBR2xCLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDO0FBQ2xFLElBQUksU0FBUyxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO0FBS2pFLFNBQVMsV0FBVztJQUNoQixNQUFNLEdBQUcsSUFBSSxpRUFBTSxDQUFDLEtBQUssRUFBRTtRQUN2QixNQUFNLEVBQUUsSUFBSTtRQUNaLHFCQUFxQixFQUFFLElBQUk7UUFDM0IsT0FBTyxFQUFFLGFBQWE7S0FDekIsQ0FBQyxDQUFDO0lBRUgsSUFBSSxTQUFTLEtBQUssTUFBTSxFQUFFO1FBQ3RCLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNmLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDaEM7QUFDTCxDQUFDO0FBS0QsU0FBZSxhQUFhOzs7Ozs7b0JBQ2xCLFdBQVcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMvQyxjQUFjLEdBQUcsV0FBVyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFFcEQsV0FBVyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO29CQUNoQyxXQUFXLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7b0JBRWxDLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTt3QkFDZCxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxXQUFXLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDaEcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO3FCQUNuQzt5QkFDSTt3QkFDRCxjQUFjLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUNqRSx3RUFBNEIsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7cUJBQzNFO29CQUNELFdBQU0sU0FBUyxFQUFFOztvQkFBakIsU0FBaUIsQ0FBQzs7Ozs7Q0FDckI7QUFHRCxTQUFlLHNCQUFzQixDQUFDLEdBQUc7Ozs7O29CQUVyQyxJQUFJLGVBQWUsR0FBRyxDQUFDO3dCQUNuQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxlQUFlO3dCQUNoRCxHQUFHLEdBQUcsMEJBQTBCLEVBQ3BDO3dCQUNJLFVBQVUsSUFBSSxDQUFDLENBQUM7d0JBQ2hCLFNBQVMsSUFBSSxDQUFDLENBQUM7d0JBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztxQkFDMUI7eUJBQU0sSUFBRyxHQUFHLElBQUksMEJBQTBCLEVBQUU7d0JBRXpDLFVBQVUsSUFBSSxTQUFTLENBQUM7d0JBQ3hCLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQztxQkFDeEM7eUJBQ0csVUFBUyxLQUFLLE9BQU8sSUFBSSxVQUFVLEdBQUcsR0FBRyxHQUF6QyxjQUF5QztvQkFDekMsV0FBTSxhQUFhLENBQUMsT0FBTyxDQUFDOztvQkFBNUIsU0FBNEIsQ0FBQzs7O3lCQUc3QixVQUFTLEtBQUssT0FBTyxJQUFJLFVBQVUsR0FBRyxHQUFHLEdBQXpDLGNBQXlDO29CQUN6QyxXQUFNLGFBQWEsQ0FBQyxPQUFPLENBQUM7O29CQUE1QixTQUE0QixDQUFDOzs7b0JBR2pDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsY0FBYyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7O0NBQ3BFO0FBS0QsU0FBZSxTQUFTOzs7Ozs7b0JBQ2QsVUFBVSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2xELElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTt3QkFDZCxVQUFVLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQzt3QkFDaEMsV0FBTztxQkFDVjtvQkFFRCxVQUFVLEVBQUUsQ0FBQztvQkFDUCxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNqQixRQUFRLEdBQUcsR0FBRyxHQUFHLGFBQWEsQ0FBQzt5QkFDakMsU0FBUSxHQUFHLElBQUksR0FBZixjQUFlO29CQUNYLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO29CQUNyRCxVQUFVLENBQUMsU0FBUyxHQUFHLE9BQU8sR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBRWhELElBQUksR0FBRyxHQUFHLDBCQUEwQixFQUFFO3dCQUNsQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7cUJBQ2xDO3lCQUFNLElBQUksR0FBRyxHQUFHLEVBQUUsRUFBRTt3QkFDakIsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO3FCQUNyQzt5QkFDSTt3QkFDRCxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUM7cUJBQ3BDO29CQUdELFdBQU0sc0JBQXNCLENBQUMsR0FBRyxDQUFDOztvQkFBakMsU0FBaUMsQ0FBQztvQkFFbEMsVUFBVSxHQUFHLENBQUMsQ0FBQztvQkFDZixhQUFhLEdBQUcsR0FBRyxDQUFDOzs7Ozs7Q0FFM0I7QUFNRCxTQUFlLGFBQWEsQ0FBQyxJQUFJOzs7OztvQkFFN0IsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUNmLFdBQU0scUVBQXlCLENBQUM7NEJBQzVCLFdBQVcsRUFBRSxJQUFJOzRCQUNqQixTQUFTLEVBQUUsSUFBSTt5QkFDbEIsQ0FBQzs7b0JBSEYsU0FHRSxDQUFDO29CQUVILGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQzdCLFlBQVksQ0FBQyxTQUFTLEdBQUcsY0FBYyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDN0QsU0FBUyxHQUFHLElBQUksQ0FBQztvQkFDakIsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDOzs7OztDQUNsQjtBQUtELFNBQWUsU0FBUzs7Ozs7O29CQUVaLGNBQVM7OzZCQUNSLE9BQU8sQ0FBQyxDQUFSLGNBQU87NkJBUVAsUUFBUSxDQUFDLENBQVQsY0FBUTs2QkFRUixPQUFPLENBQUMsQ0FBUixjQUFPOzs7d0JBZlIsV0FBTSxnRUFBb0IsQ0FDdEI7d0JBQ0ksV0FBVyxFQUFFLElBQUk7d0JBQ2pCLFNBQVMsRUFBRSxPQUFPO3FCQUNyQixDQUNKOztvQkFMRCxTQUtDLENBQUM7b0JBQ0YsY0FBTTt3QkFFTixXQUFNLGdFQUFvQixDQUN0Qjt3QkFDSSxXQUFXLEVBQUUsSUFBSTt3QkFDakIsU0FBUyxFQUFFLFFBQVE7cUJBQ3RCLENBQ0o7O29CQUxELFNBS0MsQ0FBQztvQkFDRixjQUFNO3dCQUVOLFdBQU0sZ0VBQW9CLENBQ3RCO3dCQUNJLFdBQVcsRUFBRSxJQUFJO3dCQUNqQixTQUFTLEVBQUUsT0FBTztxQkFDckIsQ0FDSjs7b0JBTEQsU0FLQyxDQUFDO29CQUNGLGNBQU07d0JBRU4sV0FBTSxnRUFBb0IsRUFBRTs7b0JBQTVCLFNBQTRCLENBQUM7b0JBQzdCLGNBQU07O29CQUdkLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQWlCLFNBQVcsQ0FBQyxDQUFDO29CQUMxQyxXQUFXLEVBQUUsQ0FBQzs7Ozs7Q0FDakI7QUFHRCxLQUFLLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRTtJQUMxQyxVQUFVLElBQUksVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDO0FBRUgsWUFBWSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFVLENBQVE7SUFDckQsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQXFCLENBQUM7SUFDdkMsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLE9BQU8sRUFBRTtRQUN2QixNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDZixlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLE9BQU8sRUFBRTtRQUN2QixNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDbEI7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILFNBQVMsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDdk5aO0FBQUEsU0FBUyxRQUFRLENBQUMsRUFFakI7UUFERyxHQUFHO0lBRUgsSUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDO0lBQ3ZCLE9BQU8sbVdBZTZCLEdBQUcsQ0FBQyxXQUFXLFVBQUssR0FBRyxDQUFDLFlBQVksaWhCQWMvQixHQUFHLENBQUMsV0FBVyx1REFDZixHQUFHLENBQUMsWUFBWSxpc0JBZ0I1QixVQUFVLDhPQVNWLFVBQVUseUtBUXRDLENBQUM7QUFDTixDQUFDO0FBRWM7SUFDWCxRQUFRO0lBQ1IsZUFBZSxFQUFFO1FBQ2IsTUFBTSxFQUFFLEVBQUU7UUFDVixPQUFPLEVBQUUsRUFBRTtLQUNkO0NBQ0osRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1RXFFO0FBRXZFLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQztBQUMzQixJQUFNLGtCQUFrQixHQUFHLFlBQVksQ0FBQztBQUN4QyxJQUFNLGFBQWEsR0FBRyxHQUFHLENBQUM7QUFDMUIsSUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDO0FBRTNCO0lBQXdDLDhCQUFXO0lBSS9DLG9CQUFZLEtBQWMsRUFBRSxNQUFlO1FBQTNDLFlBQ0ksa0JBQU0sWUFBWSxDQUFDLFNBR3RCO1FBRkcsS0FBSSxDQUFDLEtBQUssR0FBRyxLQUFLLElBQUksYUFBYSxDQUFDO1FBQ3BDLEtBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxJQUFJLGNBQWMsQ0FBQzs7SUFDM0MsQ0FBQztJQUVELDhCQUFTLEdBQVQ7UUFBVSxjQUFZO2FBQVosVUFBWSxFQUFaLHFCQUFZLEVBQVosSUFBWTtZQUFaLHlCQUFZOztRQUNsQixJQUFJLENBQUMsMkRBQUcsQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBRTtZQUNoQyxPQUFPO1NBQ1Y7UUFDTSxPQUFHLEdBQVUsSUFBSSxHQUFkLEVBQUUsSUFBSSxHQUFJLElBQUksR0FBUixDQUFTO1FBQ3pCLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBSSxJQUFJLFdBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFyQixDQUFxQixDQUFDLENBQUM7UUFDakQsYUFBUyxHQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFwQixDQUFxQjtRQUVyQyxJQUFNLFFBQVEsR0FBRztZQUNiLEtBQUssRUFBRSxFQUFFO1lBQ1QsTUFBTSxFQUFFO2dCQUNKLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQztnQkFDZCxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUM7YUFDbEI7WUFDRCxPQUFPLEVBQUU7Z0JBQ0wsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7YUFDNUI7WUFDRCxJQUFJLEVBQUUsUUFBUTtZQUNkLFFBQVEsRUFBRSxJQUFJO1lBQ2QsVUFBVSxFQUFFLGtFQUFVLENBQUMsVUFBVSxDQUFDLFdBQVc7WUFDN0MsT0FBTyxFQUFFO2dCQUNMLElBQUksRUFBRTtvQkFDRixJQUFJLEVBQUUsSUFBSTtvQkFDVixLQUFLLEVBQUUsQ0FBQztpQkFDWDthQUNKO1NBQ0osQ0FBQztRQUVGLElBQU0sVUFBVSxHQUFHO1lBQ2YsSUFBSSxFQUFFLGtCQUFrQjtZQUN4QixLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUN0QyxXQUFXLEVBQUUsS0FBSztTQUNyQixDQUFDO1FBRUYsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3hDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbkIsSUFBSSxJQUFJLFlBQVksS0FBSyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxJQUFJLE9BQVQsSUFBSSxFQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7U0FDOUI7YUFDSTtZQUNELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLFVBQVUsQ0FBQztTQUN6QztJQUNMLENBQUM7SUFDTCxpQkFBQztBQUFELENBQUMsQ0FyRHVDLG1FQUFXLEdBcURsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRpRTtBQUNOO0FBQ3JCO0FBQ3FDO0FBUzVFLElBQUksTUFBTSxHQUFHLElBQWMsQ0FBQztBQUU1QixJQUFNLEtBQUssR0FBRyxHQUFHLENBQUM7QUFDbEIsSUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBRW5CLFNBQVMsZ0JBQWdCO0lBQ3JCLDBFQUFVLENBQUMsd0RBQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRUQsZ0JBQWdCLEVBQUUsQ0FBQztBQUduQixJQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLHlFQUFRLENBQUMsZ0JBQWdCLEVBQUU7SUFDbEUsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDLENBQUM7QUFFSCxTQUFTLGtCQUFrQixDQUFDLE1BQXlCO0lBQ2pELElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFpQyxDQUFDO0lBQ3ZGLElBQUksRUFBRSxFQUFFO1FBQ0osMkRBQUcsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQzlCO1NBQ0k7UUFDRCwyREFBRyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0IsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLENBQUM7ZUFDM0MsTUFBTSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsRUFBRSxnQkFBZ0IsQ0FBQyxDQUEwQixDQUFDO0tBQzlGO0lBRUQsT0FBTyxFQUEyQixDQUFDO0FBQ3ZDLENBQUM7QUFFRCxJQUFJLFlBQVksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3BELFlBQVksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO0FBQ3pCLFlBQVksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQzFCLElBQUksRUFBRSxHQUFHLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFDO0FBRTFDLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztBQUdiLFNBQWUsU0FBUyxDQUFDLE9BSy9CO0lBTCtCO1FBQzVCLFdBQVcsRUFBRSxJQUFJO1FBQ2pCLFNBQVMsRUFBRSxPQUFPO1FBQ2xCLFdBQVcsRUFBRSxHQUFHO1FBQ2hCLFlBQVksRUFBRSxHQUFHO0tBQ3BCOzs7OztvQkFFRyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7b0JBQ3JCLE1BQU0sR0FBRyxJQUFJLENBQUM7b0JBQ2QsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFFaEIsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUV0QixZQUFZLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDaEQsWUFBWSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7b0JBQ3pCLFlBQVksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO29CQUMxQixFQUFFLEdBQUcsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBRXRDLFdBQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQzs7b0JBQW5CLFNBQW1CLENBQUM7Ozs7O0NBQ3ZCO0FBRU0sU0FBZSxJQUFJLENBQUMsT0FLMUI7SUFMMEI7UUFDdkIsV0FBVyxFQUFFLElBQUk7UUFDakIsU0FBUyxFQUFFLE9BQU87UUFDbEIsV0FBVyxFQUFFLEdBQUc7UUFDaEIsWUFBWSxFQUFFLEdBQUc7S0FDcEI7Ozs7OztvQkFFUyxjQUFjLEdBQUcsaUdBQWlHLENBQUM7b0JBQ25ILGdCQUFnQixHQUFHLDhEQUE4RCxDQUFDO29CQUNsRixjQUFjLEdBQUcsaUdBQWlHLENBQUM7b0JBQ25ILFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztvQkFHdEksTUFBTSxHQUFHLElBQUksOERBQU0sQ0FBQzt3QkFDaEIsU0FBUyxFQUFFLFNBQVM7d0JBQ3BCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSTt3QkFDM0UsU0FBUyxFQUFFOzRCQUNQLEVBQUUsRUFBRSxLQUFLOzRCQUNULEVBQUUsRUFBRSxNQUFNO3lCQUNiO3dCQUNELElBQUksRUFBRSxNQUFNO3dCQUNaLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO3dCQUNyQixHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQzt3QkFDcEIsT0FBTyxFQUFFOzRCQUNMLGFBQWEsRUFBRSxDQUFDLElBQUksNkVBQXNCLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7eUJBQ3pGO3FCQUNKLENBQUMsQ0FBQztvQkFFSCx5RUFBUSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUV0QywyREFBRyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDcEMsMkRBQUcsQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUM7b0JBQ3BDLDJEQUFHLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUVoRCxXQUFNLE1BQU0sQ0FBQyxJQUFJLEVBQUU7O29CQUFuQixTQUFtQixDQUFDOzs7OztDQUN2QjtBQUVNLFNBQWUsT0FBTzs7Ozt3QkFDbEIsV0FBTSxNQUFNLENBQUMsT0FBTyxFQUFFO3dCQUE3QixXQUFPLFNBQXNCLEVBQUM7Ozs7Q0FDakM7QUFTTSxTQUFlLFlBQVksQ0FDOUIsS0FBOEQsRUFDOUQsTUFBeUIsRUFDekIsSUFBd0I7Ozs7OztvQkFFeEIsSUFBSSxDQUFDLFFBQVEsRUFBRTt3QkFDWCxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7cUJBQ25FO29CQUNELFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7b0JBQ2hDLFdBQU0sTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7O29CQUEzQixTQUEyQixDQUFDO29CQUN0QixjQUFjLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hELE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztvQkFDM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO29CQUN2QixPQUFPLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDeEMsSUFBSSxJQUFJLEVBQUU7d0JBQ04sT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztxQkFDekc7b0JBQ0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7Ozs7O0NBQzlHO0FBT00sU0FBZSxjQUFjLENBQ2hDLEtBQThELEVBQzlELE1BQXlCOzs7Ozs7b0JBRXpCLElBQUksQ0FBQyxRQUFRLEVBQUU7d0JBQ1gsUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO3FCQUNuRTtvQkFDRCxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO29CQUNoQyxXQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDOztvQkFBM0IsU0FBMkIsQ0FBQztvQkFDNUIsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO29CQUMzQixNQUFNLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7b0JBQ3ZCLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDMUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3hDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7OztDQUM5RztBQVFNLFNBQWUsUUFBUSxDQUMxQixLQUE4RCxFQUM5RCxNQUF5QixFQUN6QixJQUF1Qjs7Ozs7O29CQUV2QixJQUFJLENBQUMsUUFBUSxFQUFFO3dCQUNYLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztxQkFDbkU7b0JBQ0QsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztvQkFDaEMsV0FBTSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQzs7b0JBQTNCLFNBQTJCLENBQUM7b0JBQzVCLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztvQkFDM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO29CQUN2QixjQUFjLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzFDLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN4QyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUN0RyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Ozs7Q0FDOUc7QUFFRCxTQUFTLGlCQUFpQixDQUFDLFlBQVk7SUFFbkMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ2YsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQ2hCLElBQU0sS0FBSyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDdEIsSUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDO0lBQ25FLElBQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxhQUFhLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUN0RSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDWCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDWCxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUM7SUFDckIsSUFBSSxFQUFFLEdBQUcsVUFBVSxDQUFDO0lBQ3BCLElBQU0sWUFBWSxHQUFHLFVBQVUsR0FBRyxXQUFXLENBQUM7SUFFOUMsSUFBSSxLQUFLLEdBQUcsWUFBWSxJQUFJLENBQUMsRUFBRTtRQUMzQixFQUFFLEdBQUcsRUFBRSxHQUFHLFlBQVksQ0FBQztRQUN2QixDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNqQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUNoQixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUMxQztTQUVJO1FBQ0QsRUFBRSxHQUFHLEVBQUUsR0FBRyxZQUFZLENBQUM7UUFDdkIsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbEMsRUFBRSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUM7UUFDaEIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDM0M7SUFDRCxPQUFPO1FBQ0gsQ0FBQztRQUNELENBQUM7UUFDRCxFQUFFO1FBQ0YsRUFBRTtRQUNGLEVBQUU7UUFDRixFQUFFO1FBQ0YsRUFBRTtRQUNGLEVBQUU7S0FDTCxDQUFDO0FBQ04sQ0FBQzs7Ozs7Ozs7Ozs7O0FDdk9ELGVBQWUsS0FBaUQsb0JBQW9CLFNBQTJILENBQUMsa0JBQWtCLFlBQVksYUFBYSxPQUFPLGNBQWMsY0FBYyxjQUFjLEVBQUUsbUJBQW1CLGdCQUFnQixpQkFBaUIsd0JBQXdCLHFCQUFxQix5SkFBeUosMkNBQTJDLHNFQUFzRSw4Q0FBOEMsMEJBQTBCLDRCQUE0QixHQUFHLElBQUksc0tBQXNLLHFDQUFxQyxjQUFjLFVBQVUseUJBQXlCLDhFQUE4RSxpR0FBaUcsUUFBUSxvQkFBb0IsOEJBQThCLGdOQUFnTixRQUFRLGNBQWMsOEJBQThCLHVEQUF1RCx5Q0FBeUMsV0FBVyw0SEFBNEgsU0FBUyx1QkFBdUIsMENBQTBDLHlKQUF5SixzQkFBc0IsMEZBQTBGLDhEQUE4RCx1Q0FBdUMsV0FBVyx5QkFBeUIsZ0VBQWdFLGdDQUFnQyxpQ0FBaUMsU0FBUywyREFBMkQscURBQXFELHFKQUFxSixHQUFHLHdDQUF3QyxRQUFRLHVHQUF1RyxTQUFTLEdBQUcsbUNBQW1DLGlSQUFpUixtREFBbUQsd0JBQXdCLG1KQUFtSixJQUFJLDhCQUE4Qix5RkFBeUYsOEJBQThCLGtKQUFrSixzQ0FBc0MsaUVBQWlFLHVCQUF1Qix1QkFBdUIsaURBQWlELHlCQUF5QiwyR0FBMkcsR0FBRyxJQUFJLE1BQU0sY0FBYyw0QkFBNEIsWUFBWSxZQUFZLHFDQUFxQyxtQkFBbUIsK0RBQStELHVCQUF1QixFQUFFLDhEQUE4RCw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLFFBQVEsSUFBSSxHOzs7Ozs7Ozs7OztBQ0FuekksZUFBZSxLQUFpRCxvQkFBb0IsU0FBd0osQ0FBQyxrQkFBa0IsWUFBWSxhQUFhLE9BQU8sY0FBYyxjQUFjLDhEQUE4RCxFQUFFLFNBQVMsY0FBYyxrQkFBa0IsRUFBRSxTQUFTLGNBQWMsK0xBQStMLEVBQUUsU0FBUyxhQUFhLE1BQU0sdUNBQXVDLDJCQUEyQixLQUFLLDhFQUE4RSxPQUFPLFNBQVMsZ0JBQWdCLFVBQVUsMkJBQTJCLGNBQWMsK0tBQStLLEVBQUUsT0FBTyxZQUFZLE9BQU8sa0NBQWtDLGlCQUFpQixVQUFVLDBDQUEwQyxFQUFFLCtCQUErQixhQUFhLFlBQVkscUNBQXFDLGNBQWMsNkJBQTZCLG1CQUFtQixHQUFHLEtBQUssTUFBTSxhQUFhLGdTQUFnUyxTQUFTLEdBQUcsTUFBTSxjQUFjLGdDQUFnQyxtQ0FBbUMsSUFBSSwyQkFBMkIsbUJBQW1CLFFBQVEsSUFBSSwwQ0FBMEMsSUFBSSxrQkFBa0IsU0FBUyxTQUFTLElBQUksOENBQThDLFdBQVcsUUFBUSxTQUFTLGdCQUFnQixxREFBcUQsRUFBRSxzRUFBc0UsSUFBSSwwQkFBMEIsd0JBQXdCLEVBQUUsa0JBQWtCLHlCQUF5Qiw4REFBOEQsaURBQWlELEdBQUcsMkJBQTJCLGdDQUFnQyxvREFBb0QsRUFBRSxNQUFNLDJDQUEyQyx1QkFBdUIsa0JBQWtCLHlCQUF5QixnQ0FBZ0Msb0RBQW9ELG1DQUFtQyxtQ0FBbUMsZUFBZSwyQ0FBMkMsbUNBQW1DLGVBQWUsR0FBRyxNQUFNLHFGQUFxRiw0REFBNEQsMkJBQTJCLE9BQU8sUUFBUSxhQUFhLHNDQUFzQyxTQUFTLEdBQUcsUUFBUSxhQUFhLDBEQUEwRCxTQUFTLGVBQWUsK2hCQUEraEIsU0FBUyxHQUFHLHdCQUF3Qix3Q0FBd0MsbUJBQW1CLHdDQUF3QyxjQUFjLGNBQWMsb0NBQW9DLDZCQUE2QiwyQkFBMkIsbUVBQW1FLCtCQUErQix3QkFBd0Isd0NBQXdDLG1CQUFtQix1Q0FBdUMsMERBQTBELDBDQUEwQywwQkFBMEIsMEJBQTBCLGtCQUFrQix1RUFBdUUseURBQXlELE1BQU0sbURBQW1ELHFLQUFxSywyQkFBMkIsb25CQUFvbkIsOEJBQThCLHNPQUFzTyxxQ0FBcUMsd1ZBQXdWLHVDQUF1QywyQ0FBMkMsMEJBQTBCLDRCQUE0QixtQkFBbUIscURBQXFELCtCQUErQiw0R0FBNEcsNkJBQTZCLGdDQUFnQyw4QkFBOEIsNkJBQTZCLG1DQUFtQyw4QkFBOEIsTUFBTSxvSUFBb0ksU0FBUyxpQ0FBaUMseUpBQXlKLDZCQUE2Qix3QkFBd0IsaURBQWlELFNBQVMscUNBQXFDLHdjQUF3YywyQ0FBMkMsMkRBQTJELElBQUksS0FBSyw2QkFBNkIsbUVBQW1FLDRDQUE0Qyx5REFBeUQsSUFBSSxLQUFLLDhCQUE4QixNQUFNLHFDQUFxQywrQ0FBK0MsNEJBQTRCLHVCQUF1QixnREFBZ0QsU0FBUyxrQ0FBa0MsbUVBQW1FLCtGQUErRixxQ0FBcUMsVUFBVSxrQ0FBa0MsTUFBTSxvQ0FBb0MsTUFBTSxrQ0FBa0MsTUFBTSxvQ0FBb0MsTUFBTSwwQ0FBMEMsTUFBTSxvQ0FBb0MsTUFBTSwwQ0FBMEMsTUFBTSxvQ0FBb0MsTUFBTSwrQ0FBK0MsTUFBTSxvQ0FBb0MsTUFBTSwrQ0FBK0MsTUFBTSxvQ0FBb0MsTUFBTSxvREFBb0QsTUFBTSxvQ0FBb0MsTUFBTSxvREFBb0QsTUFBTSxvQ0FBb0MsTUFBTSx3REFBd0QsK0NBQStDLHNFQUFzRSw0Q0FBNEMsS0FBSyxpQkFBaUIsbUNBQW1DLElBQUksMkJBQTJCLG1CQUFtQixRQUFRLElBQUksMENBQTBDLElBQUksa0JBQWtCLFNBQVMsd0JBQXdCLFdBQVcsdUNBQXVDLGFBQWEsZ0NBQWdDLFdBQVcsaUNBQWlDLFFBQVEsbUJBQW1CLEtBQUssWUFBWSxLQUFLLFNBQVMsbUJBQW1CLHlNQUF5TSx1QkFBdUIscUJBQXFCLDRKQUE0SixhQUFhLEdBQUcsYUFBYSx1SEFBdUgsU0FBUyxHQUFHLGlCQUFpQixjQUFjLHNDQUFzQyxrQ0FBa0Msa1pBQWtaLDBPQUEwTyx5REFBeUQsUUFBUSxrQkFBa0IsVUFBVSxzREFBc0QscUhBQXFILGdEQUFnRCw4QkFBOEIsNkJBQTZCLGlPQUFpTyx1RUFBdUUseURBQXlELGdDQUFnQyxZQUFZLCtDQUErQyx3QkFBd0IsdUZBQXVGLDRCQUE0Qiw4R0FBOEcsdUVBQXVFLDBIQUEwSCx5Q0FBeUMsd1BBQXdQLGtGQUFrRiw2RUFBNkUsS0FBSyw2SEFBNkgsOEJBQThCLDhDQUE4QyxxSUFBcUksS0FBSyxzQ0FBc0MsV0FBVywrREFBK0QsS0FBSywyQ0FBMkMsc0NBQXNDLDRFQUE0RSxrVUFBa1UsOFFBQThRLGlHQUFpRyxHQUFHLG1DQUFtQywwQkFBMEIsZ0NBQWdDLDBCQUEwQixxQkFBcUIsOENBQThDLDhDQUE4QyxpQ0FBaUMsT0FBTywrQ0FBK0Msc0JBQXNCLHFCQUFxQiw4Q0FBOEMsOENBQThDLGlDQUFpQyxPQUFPLGdPQUFnTyx1REFBdUQsYUFBYSxnRkFBZ0YsdURBQXVELHlDQUF5QyxpQ0FBaUMsbUJBQW1CLG1DQUFtQyxlQUFlLHFEQUFxRCx1Q0FBdUMsZUFBZSxpR0FBaUcsNkRBQTZELGVBQWUsMERBQTBELCtCQUErQixlQUFlLHNEQUFzRCxzRUFBc0UscUJBQXFCLE9BQU8sY0FBYyx3S0FBd0ssK0VBQStFLDhDQUE4QyxtREFBbUQsK0NBQStDLG9EQUFvRCwwQ0FBMEMsK0NBQStDLDJDQUEyQyw0Q0FBNEMsR0FBRyxJQUFJLGlEQUFpRCx1QkFBdUIsb0JBQW9CLHlCQUF5QixPQUFPLHNCQUFzQixHQUFHLHVEQUF1RCxpREFBaUQsb0JBQW9CLEdBQUcsbURBQW1ELG1DQUFtQyxvQkFBb0IsR0FBRywrQ0FBK0MsK0JBQStCLG9CQUFvQixHQUFHLHdEQUF3RCxpQ0FBaUMsb0JBQW9CLEdBQUcsaURBQWlELDJDQUEyQyxvQkFBb0IsR0FBRyxrRUFBa0UsZ0VBQWdFLHdCQUF3QixPQUFPLDZEQUE2RCx5QkFBeUIsT0FBTyxrRUFBa0UsZ0NBQWdDLE9BQU8scURBQXFELDBCQUEwQixHQUFHLGtEQUFrRCw0QkFBNEIsb0JBQW9CLEdBQUcsRUFBRSxnQkFBZ0IsbUVBQW1FLDRFQUE0RSxrRUFBa0UsZ0xBQWdMLHlDQUF5Qyx5TkFBeU4sMEJBQTBCLE9BQU8sRUFBRSxnQkFBZ0Isc0ZBQXNGLGtGQUFrRixrRUFBa0UsZ0xBQWdMLHlDQUF5QywwTUFBME0sd0JBQXdCLE9BQU8sRUFBRSxnQkFBZ0IsdUNBQXVDLDJFQUEyRSw2Q0FBNkMsZUFBZSxZQUFZLGlFQUFpRSxNQUFNLElBQUksZ0RBQWdELG9EQUFvRCxZQUFZLDhDQUE4Qyx5REFBeUQsd0JBQXdCLG9DQUFvQyxPQUFPLFFBQVEsY0FBYyw2RkFBNkYsZ0JBQWdCLHVEQUF1RCxrQkFBa0Isa0RBQWtELG1EQUFtRCxvQkFBb0IsT0FBTyxRQUFRLGNBQWMsdUNBQXVDLEVBQUUsc0JBQXNCLHNFQUFzRSxzQkFBc0IsSUFBSSxzQkFBc0IsWUFBWSxtQkFBbUIsaUJBQWlCLFdBQVcsS0FBSyw0QkFBNEIsU0FBUyxXQUFXLG9DQUFvQyxpQkFBaUIsNkJBQTZCLFdBQVcsOEJBQThCLFdBQVcsS0FBSyxNQUFNLDBDQUEwQyw2RUFBNkUsOERBQThELDJMQUEyTCxrQ0FBa0MscURBQXFELG9DQUFvQyx5R0FBeUcsa0NBQWtDLG1EQUFtRCxrQ0FBa0MsMENBQTBDLGtGQUFrRix1RkFBdUYsNEJBQTRCLHdDQUF3Qyx1Q0FBdUMsa0NBQWtDLFdBQVcsNkNBQTZDLGdDQUFnQyxXQUFXLHFDQUFxQyxvREFBb0QsV0FBVyw4REFBOEQsb0NBQW9DLDRDQUE0QywyQ0FBMkMsMENBQTBDLGVBQWUsaURBQWlELHdDQUF3QyxlQUFlLHlDQUF5Qyx3REFBd0QsZUFBZSxrRUFBa0UsZ0NBQWdDLGtEQUFrRCxpREFBaUQsNEZBQTRGLHdFQUF3RSxXQUFXLDBEQUEwRCxvREFBb0QsV0FBVyxtREFBbUQsNkJBQTZCLDhDQUE4QyxlQUFlLHdDQUF3QyxvQ0FBb0MsOENBQThDLGVBQWUseUJBQXlCLDBEQUEwRCxlQUFlLDBCQUEwQiwyREFBMkQsZUFBZSw2Q0FBNkMsZ0RBQWdELDBEQUEwRCx3Q0FBd0MsZ0NBQWdDLHdDQUF3QyxrQ0FBa0MsMENBQTBDLDhDQUE4Qyx3Q0FBd0Msa0NBQWtDLDJDQUEyQyw4Q0FBOEMsaUNBQWlDLFdBQVcsMENBQTBDLDJDQUEyQyxzREFBc0QsV0FBVywrR0FBK0csNEVBQTRFLGVBQWUsb0NBQW9DLG9DQUFvQyw0Q0FBNEMsMkNBQTJDLHFDQUFxQywyQ0FBMkMsbUJBQW1CLE1BQU0sOENBQThDLG1CQUFtQixlQUFlLG1EQUFtRCx3Q0FBd0MsZUFBZSxrRUFBa0Usd0RBQXdELGVBQWUsWUFBWSxrQkFBa0IsY0FBYyx1Q0FBdUMsZ0JBQWdCLFVBQVUsb0RBQW9ELDhHQUE4RyxNQUFNLHFCQUFxQixNQUFNLHNDQUFzQyxNQUFNLHdGQUF3RixNQUFNLHNDQUFzQyxNQUFNLGlEQUFpRCxNQUFNLHlCQUF5QixNQUFNLHVCQUF1QixxQkFBcUIsZ0pBQWdKLDBKQUEwSixFQUFFLHFIQUFxSCxxRkFBcUYsbUJBQW1CLDREQUE0RCxHQUFHLGtFQUFrRSw0QkFBNEIsNENBQTRDLFdBQVcsUUFBUSx3QkFBd0IsZUFBZSxzQkFBc0IsSUFBSSx5QkFBeUIsNEJBQTRCLHFCQUFxQixlQUFlLHVCQUF1QixhQUFhLDJCQUEyQixvQkFBb0IsTUFBTSx1Q0FBdUMsV0FBVyxLQUFLLFdBQVcsU0FBUyxRQUFRLG1CQUFtQixXQUFXLEtBQUssV0FBVyxZQUFZLGtCQUFrQixTQUFTLG9CQUFvQixxQ0FBcUMsd0JBQXdCLDJEQUEyRCxRQUFRLGtCQUFrQixjQUFjLGtIQUFrSCwyRkFBMkYsOERBQThELG1GQUFtRix3REFBd0QsMkRBQTJELHFEQUFxRCx3Q0FBd0MsdUNBQXVDLE9BQU8sZUFBZSxzQkFBc0IsZUFBZSxxQkFBcUIsV0FBVyxLQUFLLFdBQVcsZ0JBQWdCLFNBQVMsSUFBSSxnUkFBZ1IsU0FBUyw2QkFBNkIsU0FBUyxtQkFBbUIsb0JBQW9CLFFBQVEsZUFBZSxJQUFJLG1FQUFtRSxxQ0FBcUMsK0VBQStFLFNBQVMsb0JBQW9CLDhDQUE4Qyx5QkFBeUIsdURBQXVELDZDQUE2QywrTEFBK0wsU0FBUyx3Q0FBd0Msd0RBQXdELDJDQUEyQyxtREFBbUQsc0dBQXNHLHdCQUF3QixHQUFHLHlCQUF5QixpQ0FBaUMsYUFBYSxnQ0FBZ0MsY0FBYyxnQkFBZ0Isc0VBQXNFLE9BQU8sZUFBZSxhQUFhLG1CQUFtQiw2RUFBNkUsc0JBQXNCLDBDQUEwQyxjQUFjLElBQUksYUFBYSxTQUFTLE1BQU0sY0FBYyxJQUFJLGNBQWMsU0FBUyxNQUFNLGNBQWMsTUFBTSxpRUFBaUUsS0FBSyxjQUFjLCtCQUErQixHQUFHLGlCQUFpQixlQUFlLHdCQUF3QixxQkFBcUIsWUFBWSxpQkFBaUIsVUFBVSxpQ0FBaUMsMkRBQTJELFlBQVksSUFBSSxjQUFjLG1CQUFtQixtQkFBbUIsNERBQTRELEtBQUssRUFBRSxLQUFLLGtIQUFrSCx5Q0FBeUMsa0JBQWtCLE1BQU0seUJBQXlCLG9CQUFvQiw4QkFBOEIsU0FBUyxrQ0FBa0MsU0FBUywwRUFBMEUsSUFBSSxTQUFTLHlDQUF5QyxhQUFhLE1BQU0sMkJBQTJCLGlCQUFpQixNQUFNLG9CQUFvQiwyQkFBMkIsTUFBTSwrQkFBK0IsU0FBUyxjQUFjLFNBQVMsWUFBWSxRQUFRLE1BQU0scUJBQXFCLE9BQU8sZ0NBQWdDLFdBQVcsb0JBQW9CLGFBQWEseUJBQXlCLHlCQUF5QixzQkFBc0IsaUJBQWlCLDBKQUEwSiwwQ0FBMEMsd0NBQXdDLE1BQU0sMkJBQTJCLHl1QkFBeXVCLEdBQUcsR0FBRyx1Q0FBdUMsbUdBQW1HLElBQUksaUJBQWlCLG1DQUFtQyxJQUFJLDJCQUEyQixtQkFBbUIsUUFBUSxJQUFJLDBDQUEwQyxJQUFJLGtCQUFrQixTQUFTLFFBQVEsdUJBQXVCLDZEQUE2RCxHQUFHLGtDQUFrQyw2Q0FBNkMsdURBQXVELDhDQUE4QyxTQUFTLHVEQUF1RCxTQUFTLHNDQUFzQywyQkFBMkIsZ0NBQWdDLHdEQUF3RCxhQUFhLHNCQUFzQiw0Q0FBNEMsWUFBWSx3Q0FBd0MsaUNBQWlDLHNDQUFzQyw2SkFBNkosOENBQThDLDRCQUE0QixvQkFBb0IsZ0NBQWdDLHdEQUF3RCxhQUFhLCtCQUErQixTQUFTLDRCQUE0Qiw4QkFBOEIsd0NBQXdDLFVBQVUsMkJBQTJCLGdCQUFnQiw0TUFBNE0scUZBQXFGLEdBQUcsR0FBRyxrQ0FBa0MseUJBQXlCLHVCQUF1Qix5QkFBeUIsb0NBQW9DLHdEQUF3RCxvTEFBb0wsd0JBQXdCLGdWQUFnViw4Q0FBOEMsd0NBQXdDLG1CQUFtQiwyQkFBMkIsa0RBQWtELFNBQVMsMEVBQTBFLDhCQUE4Qix5REFBeUQsOEJBQThCLGdCQUFnQixJQUFJLEdBQUcsR0FBRyxvQ0FBb0MsaUJBQWlCLHlCQUF5QixJQUFJLDJEQUEyRCx1REFBdUQsdUJBQXVCLG9DQUFvQyx1SEFBdUgsU0FBUyx1RUFBdUUsK0JBQStCLFdBQVcsS0FBSyxLQUFLLFlBQVksaURBQWlELG1CQUFtQixTQUFTLGFBQWEsUUFBUSxpREFBaUQsS0FBSyw2REFBNkQsYUFBYSxTQUFTLHFDQUFxQyw0TUFBNE0sb0lBQW9JLDBDQUEwQyxjQUFjLDZNQUE2TSwyQ0FBMkMsd0NBQXdDLGNBQWMsME5BQTBOLHNDQUFzQyxXQUFXLHNDQUFzQywrSEFBK0gsdUJBQXVCLHFCQUFxQixpREFBaUQsc0JBQXNCLG9FQUFvRSx5Q0FBeUMseUVBQXlFLGtCQUFrQiwwQ0FBMEMsNEJBQTRCLGtIQUFrSCwyQkFBMkIsOEdBQThHLDRDQUE0QyxzQ0FBc0MsdUJBQXVCLDBEQUEwRCwyQkFBMkIsR0FBRywrQ0FBK0MsWUFBWSw0Q0FBNEMseURBQXlELGdFQUFnRSxxQ0FBcUMsaUNBQWlDLEdBQUcsY0FBYyxPQUFPLHVCQUF1QixrakJBQWtqQixrSUFBa0ksNENBQTRDLHlCQUF5Qix5QkFBeUIseUJBQXlCLHlCQUF5QiwwQkFBMEIsdUdBQXVHLHFDQUFxQywwQkFBMEIseUJBQXlCLFFBQVEsNkNBQTZDLHdCQUF3QixlQUFlLDJCQUEyQiw4QkFBOEIsMkJBQTJCLGVBQWUseUNBQXlDLDhCQUE4Qix3QkFBd0IsUUFBUSxnREFBZ0QsNEJBQTRCLG1CQUFtQiwrQkFBK0Isa0NBQWtDLCtCQUErQixtQkFBbUIsK0RBQStELFdBQVcsVUFBVSxpV0FBaVcseWFBQXlhLHFEQUFxRCxtQkFBbUIscUNBQXFDLHFNQUFxTSxtQkFBbUIsdUJBQXVCLHVOQUF1TiwyUEFBMlAsbURBQW1ELG1CQUFtQix1QkFBdUIsb1NBQW9TLHVWQUF1VixtREFBbUQsbUJBQW1CLGdDQUFnQyxlQUFlLDBCQUEwQixXQUFXLGdFQUFnRSwrQkFBK0Isa0NBQWtDLFdBQVcsdUNBQXVDLDRDQUE0QyxXQUFXLDRDQUE0QywwSUFBMEksV0FBVywyQkFBMkIsT0FBTyxRQUFRLGtCQUFrQixpR0FBaUcsd0ZBQXdGLGlCQUFpQixnQ0FBZ0MsOENBQThDLGdDQUFnQyxzREFBc0QsV0FBVywyQkFBMkIsV0FBVyxLQUFLLG1CQUFtQiwyRUFBMkUsNkNBQTZDLGVBQWUsWUFBWSxXQUFXLCtFQUErRSx5REFBeUQsd0JBQXdCLHlDQUF5Qyx5QkFBeUIsV0FBVyxPQUFPLG1EQUFtRCw2Q0FBNkMsV0FBVyxxQkFBcUIsT0FBTyxRQUFRLGVBQWUsNEJBQTRCLGVBQWUsaUVBQWlFLHNCQUFzQixVQUFVLHVCQUF1QixpSkFBaUosMEJBQTBCLDBCQUEwQix1RUFBdUUscUNBQXFDLHNCQUFzQiw0Q0FBNEMsV0FBVyxzQ0FBc0Msc0JBQXNCLDhDQUE4QyxXQUFXLDJCQUEyQiwwQ0FBMEMsT0FBTywwQkFBMEIsb0NBQW9DLGVBQWUsb0JBQW9CLG9DQUFvQyxlQUFlLDBCQUEwQixxQ0FBcUMsZUFBZSxvQkFBb0IscUNBQXFDLGVBQWUsaUhBQWlILHNIQUFzSCx5Q0FBeUMsV0FBVyx5QkFBeUIsT0FBTyxRQUFRLGtCQUFrQixxRUFBcUUsaUJBQWlCLGdDQUFnQyw4Q0FBOEMsZ0NBQWdDLHNEQUFzRCxXQUFXLDJCQUEyQixXQUFXLEtBQUssbUJBQW1CLDJFQUEyRSw2Q0FBNkMsZUFBZSxZQUFZLFdBQVcsK0VBQStFLHlEQUF5RCx3QkFBd0IseUNBQXlDLHlCQUF5QixXQUFXLE9BQU8sbURBQW1ELDZDQUE2QyxXQUFXLHFCQUFxQixPQUFPLFFBQVEsZUFBZSw0QkFBNEIsZUFBZSxpRUFBaUUsc0JBQXNCLFVBQVUsdUJBQXVCLDhDQUE4Qyw4REFBOEQsdUZBQXVGLHFFQUFxRSwyR0FBMkcseUJBQXlCLE9BQU8sUUFBUSxrQkFBa0IsK0RBQStELEtBQUssdUJBQXVCLHlGQUF5RixnR0FBZ0cseUVBQXlFLGlDQUFpQywrQkFBK0IscUVBQXFFLG9EQUFvRCxrREFBa0Qsa0ZBQWtGLDhCQUE4QixvREFBb0QsT0FBTyx5QkFBeUIsNkRBQTZELG1EQUFtRCxnQ0FBZ0MsOEJBQThCLHNCQUFzQixvRkFBb0Ysc0ZBQXNGLFdBQVcsZ0JBQWdCLDRFQUE0RSw4RUFBOEUsV0FBVyxxRkFBcUYsb0ZBQW9GLCtCQUErQiw2QkFBNkIsMEJBQTBCLDBCQUEwQiw2QkFBNkIsNkJBQTZCLDBCQUEwQiwwQkFBMEIsaUZBQWlGLCtFQUErRSwrRUFBK0UsK0VBQStFLHNHQUFzRyxrQ0FBa0MsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0MsT0FBTyxRQUFRLDBSQUEwUixpQkFBaUIscUVBQXFFLDhDQUE4Qyw4RUFBOEUsMkVBQTJFLHlCQUF5QixPQUFPLFFBQVEsZUFBZSxPQUFPLDZCQUE2QixtQ0FBbUMsa0JBQWtCLFVBQVUsdUJBQXVCLHNFQUFzRSxtQkFBbUIsR0FBRyw4Q0FBOEMsNENBQTRDLGdEQUFnRCx3RUFBd0UsbURBQW1ELGdCQUFnQiw4QkFBOEIsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0MsS0FBSyx1QkFBdUIseUNBQXlDLG9GQUFvRixvRUFBb0UsK0JBQStCLE9BQU8seUJBQXlCLDZEQUE2RCx3Q0FBd0MsOEJBQThCLHNCQUFzQixtRkFBbUYsc0ZBQXNGLFdBQVcsZ0JBQWdCLDRFQUE0RSw4RUFBOEUsV0FBVyxnRUFBZ0UsMERBQTBELG1GQUFtRiw4QkFBOEIsR0FBRyxRQUFRLGtCQUFrQixpQ0FBaUMsNENBQTRDLGtCQUFrQixtQ0FBbUMsSUFBSSwyQkFBMkIsbUJBQW1CLFFBQVEsSUFBSSwwQ0FBMEMsSUFBSSxrQkFBa0IsVUFBVSxVQUFVLHVCQUF1Qix3YUFBd2EsNEJBQTRCLGdEQUFnRCxvQkFBb0Isb0ZBQW9GLHFCQUFxQiwrQkFBK0IsdUNBQXVDLHVCQUF1QixhQUFhLDRCQUE0Qiw0REFBNEQsYUFBYSw2REFBNkQsMENBQTBDLHNCQUFzQixzQ0FBc0MsZUFBZSxvQkFBb0IsMENBQTBDLGVBQWUsZ0JBQWdCLGlCQUFpQixJQUFJLG1FQUFtRSw4Q0FBOEMsc0JBQXNCLDBDQUEwQyxlQUFlLG9CQUFvQiwwQ0FBMEMsZUFBZSxnQkFBZ0IsaUJBQWlCLFFBQVEsaUNBQWlDLG1IQUFtSCwyQkFBMkIsK0JBQStCLFdBQVcsZ0NBQWdDLCtCQUErQixXQUFXLGdDQUFnQywrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsT0FBTyx3REFBd0QsMkJBQTJCLCtCQUErQixXQUFXLGdDQUFnQywrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsT0FBTyx3REFBd0QsMkJBQTJCLCtCQUErQixXQUFXLGdDQUFnQywrQkFBK0IsV0FBVyxPQUFPLHlEQUF5RCx3QkFBd0IsT0FBTyxxREFBcUQsMkJBQTJCLCtCQUErQixXQUFXLGdDQUFnQywrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsZ0NBQWdDLCtCQUErQixXQUFXLE9BQU8scURBQXFELDJCQUEyQiwrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsZ0NBQWdDLCtCQUErQixXQUFXLE9BQU8scURBQXFELDJCQUEyQiwrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsT0FBTyxxREFBcUQsdUJBQXVCLE9BQU8saUpBQWlKLGlEQUFpRCxFQUFFLHdFQUF3RSxJQUFJLGdCQUFnQix3QkFBd0IsRUFBRSxpRkFBaUYsNENBQTRDLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQixtR0FBbUcsb0VBQW9FLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQixRQUFRLGtIQUFrSCxXQUFXLG9GQUFvRiw2QkFBNkIsc0NBQXNDLHFFQUFxRSxxQ0FBcUMsZ0NBQWdDLDZFQUE2RSxvRUFBb0UsOENBQThDLDBEQUEwRCwyREFBMkQsMEVBQTBFLHdFQUF3RSwrRUFBK0UsMERBQTBELDhCQUE4QixxQ0FBcUMsNkRBQTZELHFGQUFxRixzRUFBc0UsK0JBQStCLHlGQUF5RixtQkFBbUIsd0JBQXdCLHlGQUF5RixtQkFBbUIsZUFBZSxvQkFBb0IsOERBQThELHFGQUFxRixzRUFBc0UsK0JBQStCLDBGQUEwRixtQkFBbUIsd0JBQXdCLDBGQUEwRixtQkFBbUIsZUFBZSxrREFBa0QsV0FBVyxZQUFZLGtCQUFrQixrRUFBa0UsS0FBSyx1QkFBdUIsMmNBQTJjLDRCQUE0QixVQUFVLHVCQUF1Qix3REFBd0QsR0FBRyxnTUFBZ00sZ0VBQWdFLDJCQUEyQiwrQkFBK0IsV0FBVyxnQ0FBZ0MsK0JBQStCLFdBQVcsZ0NBQWdDLCtCQUErQixXQUFXLGdDQUFnQywrQkFBK0IsV0FBVyxPQUFPLDRMQUE0TCw0Q0FBNEMsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLDZCQUE2QixpR0FBaUcsc0RBQXNELG9DQUFvQyxXQUFXLDZFQUE2RSxpQ0FBaUMsbUNBQW1DLHNEQUFzRCxxQ0FBcUMsOENBQThDLCtDQUErQyw4Q0FBOEMsNkNBQTZDLHlEQUF5RCxpR0FBaUcsOERBQThELDhDQUE4QyxpRkFBaUYsMERBQTBELDJEQUEyRCw4RUFBOEUsNkJBQTZCLDZCQUE2QiwyRUFBMkUsMkJBQTJCLG1DQUFtQyx3RkFBd0YsK0NBQStDLCtDQUErQyxtQkFBbUIsd0JBQXdCLHNGQUFzRiwyREFBMkQsOEJBQThCLG1CQUFtQixlQUFlLG9CQUFvQiwrQkFBK0IsMENBQTBDLDhCQUE4QixtQkFBbUIsb0NBQW9DLHNGQUFzRiwyREFBMkQsOEJBQThCLG1CQUFtQix3QkFBd0IsNEZBQTRGLHFEQUFxRCxxREFBcUQsbUJBQW1CLGVBQWUsMkNBQTJDLGdGQUFnRix1Q0FBdUMsdUNBQXVDLDRDQUE0Qyw0QkFBNEIsNkNBQTZDLGVBQWUsaUNBQWlDLDhDQUE4QyxlQUFlLGlDQUFpQyw2Q0FBNkMsZUFBZSxvQkFBb0IsOENBQThDLGVBQWUsMkRBQTJELFdBQVcsWUFBWSxrQkFBa0IsaUVBQWlFLGVBQWUsVUFBVSx1QkFBdUIsZ0NBQWdDLFNBQVMsc0ZBQXNGLDZEQUE2RCxRQUFRLHNDQUFzQyxXQUFXLDZGQUE2RixTQUFTLHdOQUF3TixJQUFJLFlBQVksUUFBUSxXQUFXLFlBQVksMkJBQTJCLDJEQUEyRCw0Q0FBNEMsa0VBQWtFLDJFQUEyRSxlQUFlLHVDQUF1Qyx3RUFBd0UsaUZBQWlGLGVBQWUsR0FBRyw2Q0FBNkMsNENBQTRDLDhPQUE4Tyw4Q0FBOEMsdUNBQXVDLGtDQUFrQyx1REFBdUQsMEJBQTBCLDZDQUE2QyxPQUFPLFFBQVEsa0JBQWtCLCtEQUErRCxLQUFLLHVCQUF1QixzRUFBc0UseUlBQXlJLHlIQUF5SCx3RkFBd0YsMkRBQTJELElBQUksZ0JBQWdCLElBQUksZ0JBQWdCLElBQUksZ0JBQWdCLElBQUksZ0NBQWdDLDRCQUE0QiwrREFBK0QsNENBQTRDLCtQQUErUCxnRUFBZ0UsNEJBQTRCLDhEQUE4RCxxRUFBcUUsZ0NBQWdDLE9BQU8sUUFBUSxrQkFBa0IsZ0VBQWdFLFFBQVEsU0FBUyx1QkFBdUIseUxBQXlMLDRCQUE0Qiw0Q0FBNEMsd0JBQXdCLHNCQUFzQix1QkFBdUIsK0JBQStCLHNGQUFzRixxQ0FBcUMsZUFBZSxXQUFXLHNGQUFzRixvQ0FBb0Msa0NBQWtDLHNDQUFzQyx1QkFBdUIsbUJBQW1CLGVBQWUsb0NBQW9DLHNGQUFzRixxQ0FBcUMsZUFBZSxXQUFXLHNGQUFzRixvQ0FBb0Msa0NBQWtDLHNDQUFzQyx1QkFBdUIsbUJBQW1CLGVBQWUsb0NBQW9DLHNGQUFzRixxQ0FBcUMsZUFBZSxXQUFXLHNGQUFzRixvQ0FBb0Msa0NBQWtDLHNDQUFzQyx1QkFBdUIsbUJBQW1CLGVBQWUsb0JBQW9CLHNGQUFzRixxQ0FBcUMsZUFBZSxXQUFXLHNGQUFzRixvQ0FBb0Msa0NBQWtDLHNDQUFzQyx1QkFBdUIsbUJBQW1CLGVBQWUsV0FBVyxnQkFBZ0IsNEJBQTRCLG1FQUFtRSw2QkFBNkIsV0FBVyxPQUFPLGlDQUFpQyxXQUFXLE9BQU8scUNBQXFDLFdBQVcsT0FBTyx5Q0FBeUMsV0FBVyxPQUFPLDJFQUEyRSw0Q0FBNEMsMENBQTBDLDhDQUE4QywrQkFBK0Isc0NBQXNDLDJCQUEyQix1QkFBdUIsbUJBQW1CLGVBQWUsV0FBVyxnQ0FBZ0MsT0FBTyxFQUFFLGtCQUFrQixrQ0FBa0MsVUFBVSx1QkFBdUIsdUpBQXVKLGVBQWUsUUFBUSw2QkFBNkIsMEJBQTBCLDRDQUE0Qyx3QkFBd0Isc0JBQXNCLHVCQUF1QiwrQkFBK0Isc0ZBQXNGLHFDQUFxQyxlQUFlLFdBQVcsc0ZBQXNGLG9DQUFvQyxrQ0FBa0Msc0NBQXNDLHVCQUF1QixtQkFBbUIsZUFBZSxvQ0FBb0Msc0ZBQXNGLHFDQUFxQyxlQUFlLFdBQVcsc0ZBQXNGLG9DQUFvQyxrQ0FBa0Msc0NBQXNDLHVCQUF1QixtQkFBbUIsZUFBZSxvQ0FBb0Msc0ZBQXNGLHFDQUFxQyxlQUFlLFdBQVcsc0ZBQXNGLG9DQUFvQyxrQ0FBa0Msc0NBQXNDLHVCQUF1QixtQkFBbUIsb0JBQW9CLG9CQUFvQixzRkFBc0YscUNBQXFDLGVBQWUsV0FBVyxzRkFBc0Ysb0NBQW9DLGtDQUFrQyxzQ0FBc0MsdUJBQXVCLG1CQUFtQixlQUFlLFdBQVcsZ0JBQWdCLDRCQUE0QixtRUFBbUUsNkJBQTZCLFdBQVcsT0FBTyxpQ0FBaUMsV0FBVyxPQUFPLHFDQUFxQyxXQUFXLE9BQU8seUNBQXlDLFdBQVcsT0FBTywyRUFBMkUsNENBQTRDLDBDQUEwQyw4Q0FBOEMsK0JBQStCLHNDQUFzQywyQkFBMkIsdUJBQXVCLG1CQUFtQixlQUFlLFdBQVcsZ0NBQWdDLE9BQU8sRUFBRSxrQkFBa0Isa0NBQWtDLDJCQUEyQix1QkFBdUIsc2NBQXNjLDBCQUEwQiw0Q0FBNEMseUJBQXlCLHlCQUF5Qix5QkFBeUIseUJBQXlCLDhDQUE4Qyx1Q0FBdUMsMEJBQTBCLHlCQUF5QixRQUFRLDZDQUE2Qyx3QkFBd0IsZUFBZSwyQkFBMkIsOEJBQThCLDJCQUEyQixlQUFlLHlDQUF5Qyw4QkFBOEIsd0JBQXdCLFFBQVEsZ0RBQWdELDRCQUE0QixtQkFBbUIsK0JBQStCLGtDQUFrQywrQkFBK0IsbUJBQW1CLCtEQUErRCxtQkFBbUIsVUFBVSxxRkFBcUYsMEZBQTBGLHVGQUF1RixrREFBa0Qsa0JBQWtCLGtCQUFrQixrREFBa0QsMkRBQTJELDJCQUEyQiw4QkFBOEIsbUdBQW1HLDBGQUEwRixpR0FBaUcsMkRBQTJELDJCQUEyQiw4QkFBOEIsbUdBQW1HLDBGQUEwRixpR0FBaUcsMkRBQTJELDJCQUEyQiw4QkFBOEIsbUdBQW1HLDBGQUEwRixpR0FBaUcsMkRBQTJELDJCQUEyQix1QkFBdUIsbUJBQW1CLDhCQUE4QixlQUFlLDBCQUEwQixXQUFXLHVFQUF1RSwrQkFBK0IsdURBQXVELFdBQVcsdUNBQXVDLHNGQUFzRixXQUFXLDRDQUE0Qyw0SkFBNEosV0FBVyxpQ0FBaUMsT0FBTyxRQUFRLGtCQUFrQixzSEFBc0gsdUZBQXVGLG1CQUFtQix1QkFBdUIsK1JBQStSLHlDQUF5QyxvREFBb0QsOENBQThDLDRDQUE0Qyx5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsMEJBQTBCLHlCQUF5Qix5QkFBeUIsd0JBQXdCLHdCQUF3Qix3R0FBd0csNkJBQTZCLDBEQUEwRCw2Q0FBNkMsNEJBQTRCLHlCQUF5QixRQUFRLDJCQUEyQiw4QkFBOEIsMkJBQTJCLGVBQWUsaUNBQWlDLDhCQUE4Qix3QkFBd0IsUUFBUSxpQ0FBaUMsa0NBQWtDLCtCQUErQixtQkFBbUIsK0RBQStELGNBQWMsT0FBTyxzREFBc0QsdUZBQXVGLHdFQUF3RSx3RUFBd0UsMEZBQTBGLDZGQUE2Riw2U0FBNlMsMkNBQTJDLDJCQUEyQix1QkFBdUIsbUJBQW1CLDhCQUE4QixlQUFlLDBCQUEwQixXQUFXLHdFQUF3RSx1Q0FBdUMsa0NBQWtDLFdBQVcsdUNBQXVDLDRDQUE0QyxXQUFXLDBDQUEwQyxPQUFPLElBQUksa0JBQWtCLGlHQUFpRyx1RkFBdUYsaUVBQWlFLHVCQUF1QixtWEFBbVgscUVBQXFFLCtEQUErRCxvRUFBb0UsMEJBQTBCLE9BQU8sdUJBQXVCLDRDQUE0QywyQkFBMkIseUJBQXlCLHlCQUF5Qix5QkFBeUIsb0NBQW9DLG1EQUFtRCx1R0FBdUcscUNBQXFDLDBCQUEwQix5QkFBeUIsUUFBUSw2Q0FBNkMsd0JBQXdCLGVBQWUsMkJBQTJCLDhCQUE4QiwyQkFBMkIsZUFBZSx5Q0FBeUMsOEJBQThCLHdCQUF3QixRQUFRLGdEQUFnRCw0QkFBNEIsbUJBQW1CLCtCQUErQixrQ0FBa0MsK0JBQStCLG1CQUFtQiwrREFBK0QsbUJBQW1CLE9BQU8sMkVBQTJFLDRGQUE0RixtQ0FBbUMsbUJBQW1CLDhCQUE4QixlQUFlLDBCQUEwQixXQUFXLGdEQUFnRCxPQUFPLElBQUksa0JBQWtCLG9HQUFvRyx5REFBeUQsU0FBUyx1QkFBdUIscU5BQXFOLDhDQUE4QywwQkFBMEIsMkJBQTJCLG1DQUFtQyxXQUFXLHVFQUF1RSxvREFBb0QsbURBQW1ELG1EQUFtRCwwQkFBMEIsWUFBWSxRQUFRLG9DQUFvQyw2Q0FBNkMsd0JBQXdCLGVBQWUsMkJBQTJCLDJCQUEyQixlQUFlLDhCQUE4QixZQUFZLFFBQVEsd0NBQXdDLGdEQUFnRCw0QkFBNEIsbUJBQW1CLCtCQUErQiwrQkFBK0IsbUJBQW1CLHlIQUF5SCxtQ0FBbUMsdUNBQXVDLHFDQUFxQyx1QkFBdUIsbUJBQW1CLE9BQU8sa0NBQWtDLDBGQUEwRixtQkFBbUIsZUFBZSxXQUFXLDJCQUEyQiw0Q0FBNEMsV0FBVyx5QkFBeUIsT0FBTyxRQUFRLGtCQUFrQixpQ0FBaUMsaUVBQWlFLGFBQWEsdUJBQXVCLGlQQUFpUCxpRUFBaUUsc0JBQXNCLGtDQUFrQyxFQUFFLHlEQUF5RCwwRUFBMEUsZUFBZSx1Q0FBdUMsMkNBQTJDLHFDQUFxQyx3QkFBd0IsdUVBQXVFLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2QiwwRUFBMEUsbURBQW1ELDBCQUEwQixZQUFZLFFBQVEsb0NBQW9DLDZDQUE2Qyx3QkFBd0IsZUFBZSwyQkFBMkIsMkJBQTJCLGVBQWUsOEJBQThCLFlBQVksUUFBUSx3Q0FBd0MsZ0RBQWdELDRCQUE0QixtQkFBbUIsK0JBQStCLCtCQUErQixtQkFBbUIseUhBQXlILDhEQUE4RCxlQUFlLFdBQVcsc0JBQXNCLFFBQVEsa0JBQWtCLGlDQUFpQyxpRUFBaUUsa0JBQWtCLHVCQUF1Qix5UEFBeVAscUZBQXFGLHdCQUF3QixxQ0FBcUMsd0JBQXdCLHFDQUFxQyw4Q0FBOEMsNkxBQTZMLHdCQUF3Qiw2Q0FBNkMsK0JBQStCLFdBQVcsa0RBQWtELCtCQUErQixXQUFXLGtEQUFrRCwrQkFBK0IsV0FBVywyQkFBMkIsT0FBTyx5Q0FBeUMsMENBQTBDLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0Msb0RBQW9ELG1EQUFtRCxtREFBbUQsNEJBQTRCLHlCQUF5QixRQUFRLG9DQUFvQyw2Q0FBNkMsd0JBQXdCLGVBQWUsMkJBQTJCLDJCQUEyQixlQUFlLDhCQUE4Qix3QkFBd0IsUUFBUSx3Q0FBd0MsZ0RBQWdELDRCQUE0QixtQkFBbUIsK0JBQStCLCtCQUErQixtQkFBbUIsK0hBQStILG1DQUFtQyx1Q0FBdUMscUNBQXFDLHVCQUF1QixtQkFBbUIsT0FBTyxrQ0FBa0MsMEZBQTBGLG1CQUFtQixlQUFlLFdBQVcsMkJBQTJCLDRDQUE0QyxXQUFXLHlCQUF5QixPQUFPLFFBQVEsaUVBQWlFLGtCQUFrQix1QkFBdUIsNEdBQTRHLDhCQUE4Qiw2REFBNkQsaUZBQWlGLDJEQUEyRCw4REFBOEQsZ0NBQWdDLE9BQU8sUUFBUSxrQkFBa0IsbUVBQW1FLGlFQUFpRSxrQkFBa0IsdUJBQXVCLHdIQUF3SCwyREFBMkQsdUJBQXVCLHVCQUF1Qix1QkFBdUIsdUJBQXVCLDJEQUEyRCw4REFBOEQsV0FBVyxtQ0FBbUMsNENBQTRDLFdBQVcsd0NBQXdDLDRDQUE0QyxXQUFXLHVDQUF1QywyQ0FBMkMsV0FBVywrQ0FBK0MsT0FBTyxxQ0FBcUMsOERBQThELHFGQUFxRixzRUFBc0UsMkRBQTJELDhEQUE4RCxnQ0FBZ0MsT0FBTyxVQUFVLGtCQUFrQixtRUFBbUUsaUVBQWlFLGtCQUFrQix1QkFBdUIsd0hBQXdILDJEQUEyRCx1QkFBdUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsMkRBQTJELDhEQUE4RCxXQUFXLG1DQUFtQyw0Q0FBNEMsV0FBVyx3Q0FBd0MsNENBQTRDLFdBQVcsdUNBQXVDLDJDQUEyQyxXQUFXLCtDQUErQyxPQUFPLHFDQUFxQyw4REFBOEQscUZBQXFGLHNFQUFzRSwyREFBMkQsaUZBQWlGLGdDQUFnQyxPQUFPLFVBQVUsa0JBQWtCLG1FQUFtRSxpRUFBaUUsa0JBQWtCLHVCQUF1Qiw0R0FBNEcsOEJBQThCLDZEQUE2RCxpRkFBaUYsMkRBQTJELGtFQUFrRSxnQ0FBZ0MsT0FBTyxRQUFRLGtCQUFrQixtRUFBbUUsaUVBQWlFLGtCQUFrQix1QkFBdUIsNEdBQTRHLDhCQUE4Qiw2REFBNkQsaUZBQWlGLDJEQUEyRCw4REFBOEQsZ0NBQWdDLE9BQU8sUUFBUSxrQkFBa0IsbUVBQW1FLGlFQUFpRSxNQUFNLHVCQUF1QixvS0FBb0ssd0lBQXdJLDBCQUEwQixvRUFBb0UsMkJBQTJCLG9EQUFvRCx5QkFBeUIsNERBQTRELDBEQUEwRCwyQkFBMkIsY0FBYyxPQUFPLDhEQUE4RCw4REFBOEQsaUVBQWlFLCtEQUErRCx1RkFBdUYsc0ZBQXNGLDJCQUEyQixXQUFXLDJCQUEyQixPQUFPLFFBQVEsa0JBQWtCLG9FQUFvRSw0QkFBNEIsdUJBQXVCLG1LQUFtSyx3SUFBd0ksMEJBQTBCLG9FQUFvRSxrRkFBa0YsMkJBQTJCLG9EQUFvRCx5QkFBeUIsNERBQTRELDBEQUEwRCwyQkFBMkIsY0FBYyxPQUFPLDhEQUE4RCw4REFBOEQsaUVBQWlFLCtEQUErRCx1RkFBdUYscUZBQXFGLDJCQUEyQixXQUFXLDZCQUE2Qix5QkFBeUIsT0FBTyxRQUFRLGtCQUFrQixrR0FBa0csVUFBVSx1QkFBdUIsOENBQThDLDRDQUE0QyxnREFBZ0QsMkVBQTJFLHNFQUFzRSx3REFBd0QsV0FBVyw4QkFBOEIsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0MsU0FBUyx1QkFBdUIsaURBQWlELGdCQUFnQixvQkFBb0IsWUFBWSxvQkFBb0IsaURBQWlELHVDQUF1QywwQkFBMEIsNENBQTRDLFdBQVcsS0FBSyxRQUFRLGdDQUFnQyxrREFBa0QsbUZBQW1GLGVBQWUsOERBQThELHlEQUF5RCx5RkFBeUYsZUFBZSxnQkFBZ0IsMkNBQTJDLDRDQUE0QyxnREFBZ0QsNkNBQTZDLE9BQU8sUUFBUSxrQkFBa0IsaUNBQWlDLDRCQUE0QixhQUFhLHVCQUF1QixpREFBaUQsZ0JBQWdCLG9CQUFvQixZQUFZLG9CQUFvQixpREFBaUQsdUNBQXVDLDBCQUEwQiw0Q0FBNEMsV0FBVyxLQUFLLFFBQVEsZ0NBQWdDLGtEQUFrRCxtRkFBbUYsZUFBZSxnREFBZ0QseURBQXlELHlGQUF5RixlQUFlLGdCQUFnQiwyQ0FBMkMsNENBQTRDLGdEQUFnRCw2Q0FBNkMsT0FBTyxRQUFRLGtCQUFrQixpQ0FBaUMsNEJBQTRCLFFBQVEsdUJBQXVCLG1EQUFtRCw4Q0FBOEMseURBQXlELDRDQUE0QyxzRkFBc0YsaUZBQWlGLDhCQUE4QixPQUFPLFFBQVEsa0JBQWtCLGlDQUFpQyw0QkFBNEIsVUFBVSx1QkFBdUIsNEJBQTRCLHVFQUF1RSw0Q0FBNEMsa0dBQWtHLHFGQUFxRixvREFBb0QsMEJBQTBCLDJCQUEyQiw2QkFBNkIsT0FBTyxNQUFNLHNGQUFzRixpQ0FBaUMsZUFBZSxtQ0FBbUMsV0FBVyxnQ0FBZ0MsNkJBQTZCLG1CQUFtQixNQUFNLHNGQUFzRixpQ0FBaUMsZUFBZSxtQ0FBbUMsV0FBVyxnQkFBZ0IsNkJBQTZCLHVCQUF1QixNQUFNLHNGQUFzRixpQ0FBaUMsZUFBZSxtQ0FBbUMsV0FBVyx5QkFBeUIsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0MsWUFBWSx1QkFBdUIseURBQXlELDhDQUE4Qyw2REFBNkQsaUZBQWlGLDJJQUEySSxxSEFBcUgsdUhBQXVILG1LQUFtSyxnRUFBZ0UsNkNBQTZDLHlCQUF5QixPQUFPLFFBQVEsa0JBQWtCLDJLQUEySyx1REFBdUQsdUJBQXVCLG9EQUFvRCw4Q0FBOEMsNkRBQTZELDhDQUE4QywyQkFBMkIsbUZBQW1GLFdBQVcsZ0NBQWdDLHFOQUFxTixXQUFXLGdDQUFnQyxzUUFBc1EsV0FBVyxnQ0FBZ0MseUxBQXlMLFdBQVcsZ0NBQWdDLE9BQU8sUUFBUSxrQkFBa0IsaUNBQWlDLDZCQUE2QixvQkFBb0IsdUJBQXVCLDBDQUEwQyw0Q0FBNEMsb0JBQW9CLHlCQUF5QixPQUFPLE9BQU8sdUdBQXVHLDZCQUE2QixXQUFXLGdDQUFnQyxPQUFPLFFBQVEsa0JBQWtCLHlDQUF5QyxvQkFBb0IsdUJBQXVCLDBDQUEwQyw0Q0FBNEMsMEJBQTBCLHNDQUFzQywrRkFBK0YsMEJBQTBCLHdCQUF3QixXQUFXLG9CQUFvQix3QkFBd0IsV0FBVyxvQkFBb0Isd0JBQXdCLFdBQVcsb0JBQW9CLHdCQUF3QixXQUFXLHlCQUF5QixPQUFPLFFBQVEsa0JBQWtCLHlDQUF5QyxhQUFhLHVCQUF1QixrSEFBa0gsV0FBVyxtQ0FBbUMsd0JBQXdCLG9CQUFvQixvQkFBb0IsZ0RBQWdELFVBQVUsR0FBRyxtQ0FBbUMsbUNBQW1DLElBQUksMkJBQTJCLG1CQUFtQixRQUFRLElBQUksMENBQTBDLElBQUksa0JBQWtCLFNBQVMsK0JBQStCLDRDQUE0Qyx3QkFBd0IsNERBQTRELDhCQUE4QixPQUFPLFFBQVEsa0JBQWtCLGtDQUFrQywyQkFBMkIsdUJBQXVCLHVCQUF1QiwwQkFBMEIsNENBQTRDLDhPQUE4TywrTUFBK00saUdBQWlHLDhCQUE4QixPQUFPLFFBQVEsa0JBQWtCLGlDQUFpQywyQ0FBMkMsMkJBQTJCLHVCQUF1Qiw4Q0FBOEMsNENBQTRDLHdHQUF3RyxrRkFBa0Ysb0NBQW9DLE9BQU8sUUFBUSxrQkFBa0Isb0VBQW9FLGFBQWEsdUJBQXVCLDhDQUE4Qyw0Q0FBNEMsZ0RBQWdELHlCQUF5QixzQkFBc0IsT0FBTyxrQ0FBa0MsaUZBQWlGLFdBQVcsOEJBQThCLE9BQU8sUUFBUSxrQkFBa0IsaUNBQWlDLDRCQUE0QixRQUFRLHVCQUF1Qiw4Q0FBOEMsNENBQTRDLHdHQUF3RyxrRkFBa0YsNEZBQTRGLHdCQUF3QixrQ0FBa0Msb0JBQW9CLFdBQVcsZ0JBQWdCLG9CQUFvQixXQUFXLHVCQUF1QixPQUFPLFFBQVEsa0JBQWtCLHdHQUF3RyxVQUFVLHVCQUF1QixxSUFBcUksZ0JBQWdCLG9CQUFvQix3QkFBd0IsMEJBQTBCLDRDQUE0QyxXQUFXLEtBQUssUUFBUSxnQ0FBZ0MsNkNBQTZDLGlFQUFpRSwyRUFBMkUsZUFBZSwyQ0FBMkMsb0ZBQW9GLGlGQUFpRixlQUFlLGdCQUFnQiwyQ0FBMkMsNENBQTRDLHdCQUF3QixtQkFBbUIsa0RBQWtELDZDQUE2QyxPQUFPLFFBQVEsa0JBQWtCLCtEQUErRCxjQUFjLHVCQUF1QixtQkFBbUIsOENBQThDLDRDQUE0QyxnREFBZ0QseUJBQXlCLFdBQVcsT0FBTyxrQ0FBa0MsZ0ZBQWdGLFdBQVcsK0JBQStCLHVCQUF1QixPQUFPLFFBQVEsa0JBQWtCLGlDQUFpQyw0QkFBNEIsYUFBYSx1QkFBdUIseUVBQXlFLDhCQUE4Qiw2REFBNkQsaUZBQWlGLHNHQUFzRyx5QkFBeUIsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0MsOENBQThDLHVCQUF1QixTQUFTLG9CQUFvQiw2Q0FBNkMsNkJBQTZCLGlDQUFpQyxlQUFlLGtDQUFrQyxFQUFFLE1BQU0sMkRBQTJELHdDQUF3QyxFQUFFLE1BQU0sb0RBQW9ELG1DQUFtQyxFQUFFLDBCQUEwQiw0REFBNEQsaUZBQWlGLHNCQUFzQixRQUFRLGtCQUFrQixrQ0FBa0MsZ0NBQWdDLHVCQUF1Qiw4Q0FBOEMseUNBQXlDLHlCQUF5QixPQUFPLEtBQUssYUFBYSx1QkFBdUIsaUdBQWlHLDBCQUEwQiwyQkFBMkIsdUVBQXVFLHNDQUFzQyw0RkFBNEYsNkJBQTZCLHFCQUFxQixXQUFXLCtDQUErQyxxQ0FBcUMsOEJBQThCLHdDQUF3QywwQkFBMEIsMkJBQTJCLGlDQUFpQyx3RkFBd0YseUJBQXlCLHVCQUF1QixPQUFPLDBHQUEwRywwRkFBMEYscUNBQXFDLFdBQVcsbUJBQW1CLDJCQUEyQixPQUFPLFFBQVEsa0JBQWtCLDRHQUE0RyxhQUFhLHVCQUF1QixtQ0FBbUMsOENBQThDLDRDQUE0QyxzRkFBc0YsNEZBQTRGLGtHQUFrRyxnR0FBZ0csd0ZBQXdGLCtDQUErQyw2Q0FBNkMsK0NBQStDLDBEQUEwRCxxQ0FBcUMsaUNBQWlDLE9BQU8sUUFBUSxrQkFBa0Isb0VBQW9FLFdBQVcsdUJBQXVCLG1DQUFtQyw4Q0FBOEMsNENBQTRDLHNGQUFzRiw0RkFBNEYsa0dBQWtHLGdHQUFnRyx3RkFBd0YsK0NBQStDLDZDQUE2QywwREFBMEQsaUNBQWlDLE9BQU8sUUFBUSxrQkFBa0Isb0VBQW9FLGFBQWEsdUJBQXVCLHFEQUFxRCwwQkFBMEIsMEJBQTBCLHVFQUF1RSxxQ0FBcUMscUNBQXFDLG9DQUFvQyx3Q0FBd0MsaUZBQWlGLCtFQUErRSxtQ0FBbUMsdUJBQXVCLE9BQU8seUZBQXlGLG1GQUFtRiw4QkFBOEIsV0FBVyxzQkFBc0IsMkJBQTJCLHVCQUF1QixPQUFPLDhFQUE4RSwyRkFBMkYseUNBQXlDLFdBQVcsc0JBQXNCLDRCQUE0QixPQUFPLFFBQVEsa0JBQWtCLGlPQUFpTyxhQUFhLHVCQUF1QixvTUFBb00sOENBQThDLDBCQUEwQix1RUFBdUUsMEVBQTBFLG1EQUFtRCwwQkFBMEIsWUFBWSxRQUFRLG9DQUFvQyw2Q0FBNkMsd0JBQXdCLGVBQWUsMkJBQTJCLDJCQUEyQixlQUFlLDhCQUE4QixZQUFZLFFBQVEsd0NBQXdDLGdEQUFnRCw0QkFBNEIsbUJBQW1CLCtCQUErQiwrQkFBK0IsbUJBQW1CLHlIQUF5SCw4QkFBOEIsa0VBQWtFLFdBQVcsMkNBQTJDLHlCQUF5QixPQUFPLFFBQVEsa0JBQWtCLGlDQUFpQyx5REFBeUQsc09BQXNPLHVCQUF1Qiw2REFBNkQsaUVBQWlFLHNCQUFzQixPQUFPLDZCQUE2QixvQkFBb0IsMENBQTBDLHdDQUF3QyxlQUFlLHVEQUF1RCx3RUFBd0UsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUsMENBQTBDLHdDQUF3QyxlQUFlLHVEQUF1RCx3RUFBd0UsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUscUVBQXFFLDJDQUEyQyxvQkFBb0IsMENBQTBDLHdCQUF3QixlQUFlLHVEQUF1RCxtQ0FBbUMsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUsMENBQTBDLHdCQUF3QixlQUFlLHVEQUF1RCxtQ0FBbUMsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUscUVBQXFFLDBDQUEwQyxvQkFBb0IsMENBQTBDLDhFQUE4RSxlQUFlLHVEQUF1RCxxRkFBcUYsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUsMENBQTBDLDhFQUE4RSxlQUFlLHVEQUF1RCxxRkFBcUYsZUFBZSxvQkFBb0Isd0NBQXdDLGVBQWUscUVBQXFFLHNDQUFzQyw4Q0FBOEMsNENBQTRDLG1DQUFtQyxrTEFBa0wscUdBQXFHLFdBQVcsZ0JBQWdCLGlDQUFpQyw4QkFBOEIsT0FBTyxRQUFRLGtCQUFrQixrQ0FBa0Msd0NBQXdDLHVCQUF1QixnSEFBZ0gsOENBQThDLDZEQUE2RCx3QkFBd0Isa0pBQWtKLDZLQUE2Syw0S0FBNEssbU1BQW1NLHNLQUFzSyw4S0FBOEssZ0NBQWdDLE9BQU8sUUFBUSxrQkFBa0IsaUNBQWlDLDJDQUEyQyxXQUFXLHVCQUF1Qiw0Q0FBNEMsNENBQTRDLDREQUE0RCx1RkFBdUYsa0NBQWtDLGtDQUFrQyxvQ0FBb0MscUNBQXFDLGtFQUFrRSw4REFBOEQsZ0VBQWdFLGlFQUFpRSxtRkFBbUYsaUZBQWlGLGlGQUFpRixpRkFBaUYsOENBQThDLE9BQU8sUUFBUSxrQkFBa0IsK0RBQStELGNBQWMsdUJBQXVCLHVCQUF1QiwwQkFBMEIsNENBQTRDLHFPQUFxTywrTUFBK00saUdBQWlHLDhCQUE4QixPQUFPLFFBQVEsa0JBQWtCLGlDQUFpQywyQ0FBMkMsV0FBVyx1QkFBdUIsd0lBQXdJLDhDQUE4QywrQ0FBK0MsNEpBQTRKLGdLQUFnSywwQkFBMEIsaURBQWlELDBCQUEwQix5RkFBeUYsMEJBQTBCLHdCQUF3QixXQUFXLG9CQUFvQix3QkFBd0IsV0FBVyxvQkFBb0Isd0JBQXdCLFdBQVcsb0JBQW9CLHdCQUF3QixXQUFXLHlCQUF5Qiw4REFBOEQsV0FBVyxtQkFBbUIsOERBQThELFdBQVcsbUJBQW1CLDhEQUE4RCxXQUFXLGdDQUFnQyxPQUFPLFFBQVEsa0JBQWtCLHdDQUF3QywyQ0FBMkMsVUFBVSxvQkFBb0Isa0NBQWtDLCtCQUErQix5QkFBeUIsb0NBQW9DLHlEQUF5RCxnRUFBZ0Usc0NBQXNDLHFCQUFxQixXQUFXLGlEQUFpRCwwQ0FBMEMsaURBQWlELDBDQUEwQywyR0FBMkcsd0VBQXdFLDhEQUE4RCxzQ0FBc0MsV0FBVyxnQkFBZ0IseUNBQXlDLFdBQVcsT0FBTyxRQUFRLGtCQUFrQixXQUFXLFlBQVksdUJBQXVCLHlDQUF5QyxzRkFBc0YsbUVBQW1FLGlFQUFpRSxrQ0FBa0MsOENBQThDLE9BQU8sNkRBQTZELHlKQUF5SixPQUFPLGdFQUFnRSxxTEFBcUwscUZBQXFGLHNFQUFzRSxzQ0FBc0Msa0RBQWtELHFCQUFxQix5QkFBeUIsNENBQTRDLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixnREFBZ0Qsc0JBQXNCLG9CQUFvQiwyQ0FBMkMsb0JBQW9CLG9CQUFvQixXQUFXLGdCQUFnQixvQkFBb0Isb0JBQW9CLFdBQVcseURBQXlELHFEQUFxRCwyREFBMkQsZ0NBQWdDLGdDQUFnQyxpQ0FBaUMsaUNBQWlDLDhCQUE4Qiw4QkFBOEIsNkRBQTZELDJDQUEyQyxxQ0FBcUMscUNBQXFDLGVBQWUsb0JBQW9CLG9DQUFvQyxlQUFlLGtEQUFrRCwwQ0FBMEMsZUFBZSxvQkFBb0IsNkNBQTZDLGVBQWUsNENBQTRDLE9BQU8sUUFBUSxrQkFBa0IsNkdBQTZHLGNBQWMscURBQXFELFVBQVUsaUJBQWlCLGlGQUFpRixlQUFlLHVJQUF1SSwyQ0FBMkMsd0ZBQXdGLEVBQUUsU0FBUyxHQUFHLGlCQUFpQixNQUFNLGNBQWMsNEJBQTRCLFlBQVksWUFBWSxxQ0FBcUMsbUJBQW1CLCtEQUErRCx1QkFBdUIsRUFBRSxnQkFBZ0IsaURBQWlELElBQUksMkNBQTJDLFNBQVMsMENBQTBDLGdFQUFnRSw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLFFBQVEsSUFBSSxHOzs7Ozs7Ozs7OztBQ0FsKzJILGVBQWUsS0FBaUQsb0JBQW9CLFNBQWdKLENBQUMsa0JBQWtCLFlBQVksT0FBTyxZQUFZLGFBQWEsaUJBQWlCLHdDQUF3Qyw0Q0FBNEMsdUJBQXVCLGtEQUFrRCxHQUFHLHVIQUF1SCxlQUFlLGFBQWEsY0FBYyx5SUFBeUksRUFBRSxTQUFTLGNBQWMsc0lBQXNJLEVBQUUsU0FBUyxhQUFhLE1BQU0sdUNBQXVDLDJCQUEyQixLQUFLLDhFQUE4RSxPQUFPLFNBQVMsZ0JBQWdCLFVBQVUsMkJBQTJCLGdCQUFnQiw0Q0FBNEMsa0JBQWtCLFFBQVEsZ0JBQWdCLGdEQUFnRCx5QkFBeUIsbUJBQW1CLFdBQVcsMkJBQTJCLElBQUksTUFBTSwwQkFBMEIsMEJBQTBCLFlBQVksR0FBRyxnQkFBZ0Isd0NBQXdDLEtBQUssdUNBQXVDLFFBQVEsR0FBRyxjQUFjLGtEQUFrRCxnQkFBZ0IsMENBQTBDLCtEQUErRCxjQUFjLHdFQUF3RSxFQUFFLCtCQUErQixhQUFhLFlBQVkscUNBQXFDLGNBQWMsNkJBQTZCLG1CQUFtQixHQUFHLEtBQUssd0JBQXdCLDBDQUEwQyxjQUFjLElBQUksYUFBYSxTQUFTLE1BQU0sY0FBYyxJQUFJLGNBQWMsU0FBUyxNQUFNLGNBQWMsTUFBTSxpRUFBaUUsS0FBSyxjQUFjLCtCQUErQixHQUFHLGlCQUFpQixlQUFlLHdCQUF3QixxQkFBcUIsWUFBWSxpQkFBaUIsVUFBVSxpQ0FBaUMsMkRBQTJELFlBQVksSUFBSSxjQUFjLG1CQUFtQixtQkFBbUIsNERBQTRELEtBQUssRUFBRSxLQUFLLGtIQUFrSCx5Q0FBeUMsa0JBQWtCLE1BQU0seUJBQXlCLG9CQUFvQiw4QkFBOEIsU0FBUyxrQ0FBa0MsU0FBUywwRUFBMEUsSUFBSSxTQUFTLHlDQUF5QyxhQUFhLE1BQU0sMkJBQTJCLGlCQUFpQixNQUFNLG9CQUFvQiwyQkFBMkIsTUFBTSwrQkFBK0IsU0FBUyxjQUFjLFNBQVMsWUFBWSxRQUFRLE1BQU0scUJBQXFCLE9BQU8sZ0NBQWdDLFdBQVcsbUJBQW1CLGNBQWMsY0FBYyxlQUFlLDJFQUEyRSxhQUFhLDhEQUE4RCxnREFBZ0QsdUJBQXVCLHdCQUF3QiwyQkFBMkIsOEJBQThCLDBDQUEwQyxxREFBcUQsMkRBQTJELHdDQUF3QyxtQ0FBbUMsd0NBQXdDLE1BQU0sMkJBQTJCLGdCQUFnQixtQ0FBbUMsK01BQStNLHFDQUFxQyxVQUFVLDBCQUEwQixvQkFBb0IsR0FBRyxHQUFHLHVDQUF1Qyx3Q0FBd0MsMkJBQTJCLGdCQUFnQixrREFBa0QsbUJBQW1CLFNBQVMsMEJBQTBCLGdEQUFnRCx1QkFBdUIsS0FBSyxHQUFHLEdBQUcsbUNBQW1DLHVDQUF1QyxnQkFBZ0IsR0FBRyxxQ0FBcUMsd0JBQXdCLG9DQUFvQyx3Q0FBd0MsVUFBVSwyQkFBMkIsNkJBQTZCLEtBQUsscUVBQXFFLDBDQUEwQyxlQUFlLHVCQUF1Qiw0Q0FBNEMsR0FBRyw4QkFBOEIsOEJBQThCLHVCQUF1QixZQUFZLEdBQUcsS0FBSyxJQUFJLEdBQUcsR0FBRyxtQ0FBbUMsZ0RBQWdELGlCQUFpQixnQ0FBZ0MsV0FBVywrQ0FBK0MsR0FBRyxpQ0FBaUMsK0NBQStDLEVBQUUsK0VBQStFLDBIQUEwSCxtQkFBbUIsRUFBRSx3Q0FBd0MsYUFBYSxrQ0FBa0MsSUFBSSw0QkFBNEIsU0FBUyxNQUFNLEdBQUcsbUNBQW1DLHFFQUFxRSxzREFBc0QsK0JBQStCLHVFQUF1RSxxQkFBcUIsWUFBWSxxQkFBcUIsWUFBWSxHQUFHLE1BQU0sR0FBRyxHQUFHLFlBQVksYUFBYSx3REFBd0QsU0FBUyxlQUFlLGtLQUFrSyxTQUFTLGVBQWUsZ1NBQWdTLFNBQVMsZUFBZSxvRkFBb0YsU0FBUyxHQUFHLE9BQU8sWUFBWSxPQUFPLGtDQUFrQyxnQkFBZ0IsdUlBQXVJLDJDQUEyQyx3RkFBd0YsRUFBRSxrQkFBa0IsaUZBQWlGLFVBQVUsR0FBRyxpQkFBaUIsVUFBVSwwQ0FBMEMsRUFBRSxtQkFBbUIsZ0JBQWdCLHNDQUFzQyxnQkFBZ0IsY0FBYyxpSEFBaUgsb0RBQW9ELHFIQUFxSCxxTUFBcU0sdURBQXVELGVBQWUsZ0JBQWdCLHFEQUFxRCx1QkFBdUIsS0FBSywrQkFBK0IsbURBQW1ELGVBQWUsNkRBQTZELCtCQUErQixrQ0FBa0MsNENBQTRDLEdBQUcsaUJBQWlCLGFBQWEseUJBQXlCLGlDQUFpQyxhQUFhLGdDQUFnQyxjQUFjLGdCQUFnQixzRUFBc0UsT0FBTyxlQUFlLGFBQWEsbUJBQW1CLDZFQUE2RSxLQUFLLHFCQUFxQiwrREFBK0Qsd0JBQXdCLGtDQUFrQywyQkFBMkIsV0FBVywrREFBK0QsY0FBYyxPQUFPLGlDQUFpQyxTQUFTLG9CQUFvQixVQUFVLHdCQUF3QixjQUFjLE9BQU8saUNBQWlDLFNBQVMsb0JBQW9CLFVBQVUsd0JBQXdCLGdCQUFnQiwyQ0FBMkMsb0NBQW9DLCtDQUErQyxzQ0FBc0Msa0ZBQWtGLG9CQUFvQixhQUFhLDJDQUEyQywrQ0FBK0MsaUJBQWlCLG1CQUFtQixzQkFBc0IscURBQXFELDhFQUE4RSxjQUFjLDZFQUE2RSxtQ0FBbUMsYUFBYSwwQkFBMEIsU0FBUyxtQ0FBbUMsZUFBZSxxQkFBcUIsR0FBRyxJQUFJLGlCQUFpQixvQkFBb0IsaUNBQWlDLGFBQWEsZ0NBQWdDLGNBQWMsZ0JBQWdCLHNFQUFzRSxRQUFRLHFCQUFxQixhQUFhLG1CQUFtQiw4RUFBOEUsR0FBRyxvQkFBb0IsYUFBYSwwQ0FBMEMsK0NBQStDLGlCQUFpQixtQkFBbUIsc0JBQXNCLHlFQUF5RSx1QkFBdUIsZUFBZSw2R0FBNkcsdUJBQXVCLEdBQUcsS0FBSyxtQkFBbUIsbUVBQW1FLCtCQUErQiw4QkFBOEIsS0FBSyxrRkFBa0YsZUFBZSxnQ0FBZ0Msa0VBQWtFLEdBQUcsSUFBSSxpQkFBaUIsb0JBQW9CLGlDQUFpQyxhQUFhLGdDQUFnQyxjQUFjLGdCQUFnQixzRUFBc0UsUUFBUSxxQkFBcUIsYUFBYSxtQkFBbUIsOEVBQThFLGdCQUFnQixtQ0FBbUMsSUFBSSwyQkFBMkIsbUJBQW1CLFFBQVEsSUFBSSwwQ0FBMEMsSUFBSSxrQkFBa0IsVUFBVSxnQkFBZ0IsYUFBYSxvQkFBb0Isb0JBQW9CLDJCQUEyQixXQUFXLG9CQUFvQixlQUFlLG1DQUFtQyxvQkFBb0IsYUFBYSxvQ0FBb0MsK0NBQStDLG1CQUFtQixtQkFBbUIsc0JBQXNCLHFDQUFxQyxJQUFJLEtBQUssV0FBVyw2RkFBNkYsNkdBQTZHLG9CQUFvQiw4Q0FBOEMsSUFBSSxLQUFLLG9EQUFvRCx1REFBdUQsT0FBTyxjQUFjLFFBQVEsZ0JBQWdCLElBQUkseUJBQXlCLGdCQUFnQiw2REFBNkQsR0FBRyxJQUFJLGlCQUFpQixtQ0FBbUMsSUFBSSwyQkFBMkIsbUJBQW1CLFFBQVEsSUFBSSwwQ0FBMEMsSUFBSSxrQkFBa0IsVUFBVSxjQUFjLGVBQWUsaUJBQWlCLGFBQWEsY0FBYyxtQkFBbUIsWUFBWSxjQUFjLCtCQUErQixXQUFXLEdBQUcsZ0JBQWdCLGVBQWUsd0JBQXdCLGdCQUFnQiwyREFBMkQsSUFBSSxnQkFBZ0IsSUFBSSxnQkFBZ0IsSUFBSSxnQkFBZ0IsSUFBSSw2QkFBNkIsMkJBQTJCLGNBQWMsK0RBQStELElBQUksbUJBQW1CLFNBQVMsZ0JBQWdCLDRCQUE0QixJQUFJLDRCQUE0QixTQUFTLGlCQUFpQixvQkFBb0IsaUNBQWlDLGFBQWEsZ0NBQWdDLGNBQWMsZ0JBQWdCLHNFQUFzRSxRQUFRLHFCQUFxQixhQUFhLG1CQUFtQiw4RUFBOEUsa0JBQWtCLG9CQUFvQixhQUFhLG9DQUFvQywrQ0FBK0MsaUJBQWlCLG1CQUFtQixzQkFBc0IsMERBQTBELHdDQUF3Qyx1QkFBdUIsd0VBQXdFLFFBQVEsU0FBUyxNQUFNLFVBQVUsTUFBTSxpQkFBaUIsNkJBQTZCLHVDQUF1QyxrRUFBa0UsR0FBRyxJQUFJLGlCQUFpQixvQkFBb0IsaUNBQWlDLGFBQWEsZ0NBQWdDLGNBQWMsZ0JBQWdCLHNFQUFzRSxRQUFRLHFCQUFxQixhQUFhLG1CQUFtQiw4RUFBOEUsd0NBQXdDLG9CQUFvQixhQUFhLHdDQUF3QywrQ0FBK0MsaUJBQWlCLG1CQUFtQixzQkFBc0IseUJBQXlCLG9EQUFvRCxvTEFBb0wsa0JBQWtCLHNCQUFzQixJQUFJLGdFQUFnRSxzQkFBc0IsSUFBSSwyRUFBMkUsMEJBQTBCLGVBQWUsd0NBQXdDLHdCQUF3QixHQUFHLGNBQWMsb0NBQW9DLCtCQUErQixHQUFHLE9BQU8sT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLE1BQU0saUJBQWlCLElBQUksT0FBTywyQkFBMkIsU0FBUyxZQUFZLFVBQVUsTUFBTSx5QkFBeUIsU0FBUyw4QkFBOEIsUUFBUSw4QkFBOEIsZUFBZSwwQkFBMEIsY0FBYyxpQ0FBaUMsR0FBRyxPQUFPLDhFQUE4RSxxQkFBcUIsbUNBQW1DLElBQUksMkJBQTJCLG1CQUFtQixRQUFRLElBQUksMENBQTBDLElBQUksa0JBQWtCLFVBQVUsaUJBQWlCLG1CQUFtQixhQUFhLDRGQUE0RixXQUFXLEdBQUcsb0JBQW9CLGdCQUFnQix5REFBeUQsOExBQThMLDBDQUEwQyx1R0FBdUcsc0NBQXNDLFdBQVcsMkVBQTJFLG1DQUFtQyxHQUFHLHNDQUFzQyxXQUFXLHFFQUFxRSx3QkFBd0IsR0FBRyx1Q0FBdUMsV0FBVyw2RUFBNkUsdUNBQXVDLEdBQUcscUNBQXFDLGlCQUFpQixrQkFBa0IsS0FBSywwQ0FBMEMsK0JBQStCLGlCQUFpQixtQ0FBbUMsWUFBWSxVQUFVLGVBQWUsNkJBQTZCLHVCQUF1QixLQUFLLHVCQUF1QixRQUFRLHlFQUF5RSxrQkFBa0IsNEJBQTRCLFlBQVksd0JBQXdCLFNBQVMsa0NBQWtDLHNDQUFzQyxTQUFTLGFBQWEsbUNBQW1DLFdBQVcsRUFBRSxrREFBa0QsWUFBWSx1QkFBdUIsZ0JBQWdCLFdBQVcsZ0JBQWdCLHlCQUF5QixtRkFBbUYsd0NBQXdDLFFBQVEsd0NBQXdDLHdDQUF3QyxzQkFBc0IsR0FBRyx5Q0FBeUMsd0NBQXdDLHVCQUF1QixHQUFHLHlDQUF5Qyx3Q0FBd0MsZ0JBQWdCLEdBQUcsR0FBRyxpQkFBaUIsY0FBYyxZQUFZLCtQQUErUCx1TkFBdU4sOE9BQThPLFdBQVcseURBQXlELGVBQWUsaURBQWlELDJCQUEyQiwyQkFBMkIsMERBQTBELDBEQUEwRCxlQUFlLGdDQUFnQyxrQ0FBa0MsK0JBQStCLHNEQUFzRCxlQUFlLGdDQUFnQyxrQ0FBa0MsK0JBQStCLG1EQUFtRCxlQUFlLHdCQUF3Qix1QkFBdUIsK0JBQStCLG9EQUFvRCxlQUFlLHdCQUF3Qix1QkFBdUIsK0JBQStCLCtDQUErQyxlQUFlLHdCQUF3Qix1QkFBdUIsK0JBQStCLG9EQUFvRCxlQUFlLDRCQUE0QiwrQkFBK0IsZ0VBQWdFLGVBQWUsc0NBQXNDLCtCQUErQixtREFBbUQsZUFBZSxrQkFBa0IsK0JBQStCLHFEQUFxRCxlQUFlLHFDQUFxQyxNQUFNLEtBQUssa0RBQWtELFdBQVcsR0FBRyxVQUFVLG1CQUFtQiwrQkFBK0IsSUFBSSxPQUFPLHlCQUF5QixpSEFBaUgsMkNBQTJDLDBEQUEwRCx3QkFBd0IsZ05BQWdOLDRCQUE0Qix1R0FBdUcsaUdBQWlHLHNCQUFzQixtQ0FBbUMscUZBQXFGLHVCQUF1Qix3REFBd0QsMEJBQTBCLElBQUksRUFBRSxpQ0FBaUMscUJBQXFCLDZEQUE2RCwyREFBMkQsNEJBQTRCLDBDQUEwQywrQkFBK0IseUNBQXlDLHdHQUF3Ryx3QkFBd0IsOEJBQThCLHVCQUF1QixZQUFZLHNDQUFzQyxXQUFXLDBCQUEwQix3REFBd0QsMkNBQTJDLGtCQUFrQixtREFBbUQsOERBQThELHlCQUF5QixrRkFBa0YseUJBQXlCLDBHQUEwRywrQkFBK0IsOEtBQThLLDZCQUE2QiwySEFBMkgsdUJBQXVCLDZIQUE2SCwyQkFBMkIsOENBQThDLHdCQUF3QiwyQ0FBMkMsd0JBQXdCLGdEQUFnRCx1QkFBdUIsMENBQTBDLHlCQUF5QixnQ0FBZ0MsMEdBQTBHLDJDQUEyQywyRUFBMkUsMEJBQTBCLHNEQUFzRCxtQ0FBbUMsd0VBQXdFLG9KQUFvSiwwQkFBMEIsbUZBQW1GLG1DQUFtQyxXQUFXLHVCQUF1QixZQUFZLDBGQUEwRixtQ0FBbUMsSUFBSSxjQUFjLFNBQVMsUUFBUSxJQUFJLGlCQUFpQiwrREFBK0QseUJBQXlCLDBGQUEwRixPQUFPLFdBQVcsMlBBQTJQLDJCQUEyQix5Q0FBeUMsa0NBQWtDLGlDQUFpQyxNQUFNLGlCQUFpQixxQ0FBcUMsa0NBQWtDLE1BQU0saUJBQWlCLG9DQUFvQyxnQ0FBZ0MsTUFBTSxrQ0FBa0MsaUJBQWlCLHNDQUFzQyxtQ0FBbUMseUlBQXlJLGtMQUFrTCxxQ0FBcUMsZ0ZBQWdGLElBQUkseUJBQXlCLDJDQUEyQyx5QkFBeUIsMERBQTBELHdCQUF3QixHQUFHLE1BQU0saUJBQWlCLCtCQUErQixvQkFBb0Isc0ZBQXNGLGtDQUFrQyxRQUFRLFFBQVEseUNBQXlDLG9CQUFvQixzQ0FBc0MsOEJBQThCLFdBQVcsR0FBRyx3Q0FBd0Msa0JBQWtCLFdBQVcseUJBQXlCLHNEQUFzRCxnTUFBZ00sa0JBQWtCLHFDQUFxQyxpQ0FBaUMsSUFBSSx1RkFBdUYsU0FBUyx5QkFBeUIsb0JBQW9CLHNCQUFzQixzREFBc0QscU1BQXFNLG9CQUFvQix1SUFBdUksMlBBQTJQLCtCQUErQixxQkFBcUIsaURBQWlELDZEQUE2RCxXQUFXLDBCQUEwQixpREFBaUQsV0FBVyxvQ0FBb0MsNEJBQTRCLDRCQUE0QixHQUFHLHVDQUF1QyxpQ0FBaUMsR0FBRyxrQkFBa0IsaURBQWlELGVBQWUscUNBQXFDLDRCQUE0QixnREFBZ0QsS0FBSyx1QkFBdUIsRUFBRSxHQUFHLFNBQVMsa0JBQWtCLFFBQVEsb0JBQW9CLDZEQUE2RCw0QkFBNEIsdUNBQXVDLE1BQU0sV0FBVyw2Q0FBNkMsS0FBSyxhQUFhLElBQUksOENBQThDLG1CQUFtQixpREFBaUQsb0NBQW9DLGdJQUFnSSxrQkFBa0Isd0NBQXdDLG9DQUFvQyw4Q0FBOEMsOEZBQThGLElBQUksZ0NBQWdDLFVBQVUsOEJBQThCLFNBQVMsUUFBUSxzQ0FBc0MsK0RBQStELElBQUkseUVBQXlFLHdCQUF3QixtREFBbUQsd0NBQXdDLGtGQUFrRixFQUFFLEdBQUcsU0FBUyxrQkFBa0Isa0RBQWtELFdBQVcsSUFBSSwwSkFBMEosOEJBQThCLDhFQUE4RSxJQUFJLGNBQWMsU0FBUyxrQkFBa0IsR0FBRyxTQUFTLGtCQUFrQixvQ0FBb0MsV0FBVyxpQ0FBaUMsd0NBQXdDLHlCQUF5QiwrQkFBK0IsbVNBQW1TLEVBQUUseUZBQXlGLDZDQUE2QywwQ0FBMEMsZ0JBQWdCLDhDQUE4QyxtREFBbUQsVUFBVSxLQUFLLEdBQUcsR0FBRyxrQkFBa0IscUNBQXFDLGlDQUFpQyxJQUFJLHVGQUF1RixTQUFTLHlCQUF5QixvQkFBb0IsYUFBYSxxQkFBcUIsMlBBQTJQLDJDQUEyQyw0SUFBNEksa0hBQWtILGlCQUFpQix3QkFBd0IsZ0NBQWdDLHNDQUFzQyxZQUFZLDBGQUEwRixpQ0FBaUMseUlBQXlJLGdFQUFnRSxFQUFFLG1GQUFtRixzREFBc0QsaURBQWlELEtBQUssUUFBUSw4QkFBOEIsNEZBQTRGLElBQUksMEZBQTBGLEVBQUUsMkNBQTJDLHVKQUF1SixJQUFJLHNCQUFzQixJQUFJLHNCQUFzQixJQUFJLEtBQUssd0JBQXdCLDZEQUE2RCxzQkFBc0IsNkNBQTZDLFdBQVcsNk1BQTZNLE1BQU0sdUVBQXVFLGtPQUFrTyx3V0FBd1cscUtBQXFLLHNDQUFzQyx5Q0FBeUMsZ0RBQWdELHFDQUFxQyxZQUFZLG9FQUFvRSxHQUFHLEdBQUcsa0JBQWtCLHFDQUFxQyxpQ0FBaUMsSUFBSSx1RkFBdUYsU0FBUyx5QkFBeUIsbUJBQW1CLDRCQUE0QixJQUFJLEtBQUssV0FBVyxhQUFhLFVBQVUsRUFBRSw2QkFBNkIsdUJBQXVCLGNBQWMsZUFBZSxnQ0FBZ0MsOEJBQThCLGlCQUFpQix1REFBdUQsb0NBQW9DLDRGQUE0RiwwQ0FBMEMsTUFBTSxpQkFBaUIsVUFBVSw2QkFBNkIsb0VBQW9FLG1CQUFtQixzREFBc0QsMk9BQTJPLElBQUksS0FBSyxTQUFTLFVBQVUsbUJBQW1CLGdCQUFnQix5QkFBeUIsbUJBQW1CLEtBQUssY0FBYyxHQUFHLFNBQVMsRUFBRSxnQkFBZ0IsU0FBUyxxQkFBcUIsV0FBVyx5QkFBeUIsS0FBSyxNQUFNLGtCQUFrQixLQUFLLGNBQWMsd0JBQXdCLGdCQUFnQiw0QkFBNEIsdUJBQXVCLGtDQUFrQyx1QkFBdUIsb0JBQW9CLGtCQUFrQixtQ0FBbUMsSUFBSSwyQkFBMkIsbUJBQW1CLFFBQVEsSUFBSSwwQ0FBMEMsSUFBSSxrQkFBa0IsU0FBUywwQkFBMEIsR0FBRywwQkFBMEIseUJBQXlCLDBDQUEwQyxjQUFjLElBQUksYUFBYSxTQUFTLE1BQU0sY0FBYyxJQUFJLGNBQWMsU0FBUyxNQUFNLGNBQWMsTUFBTSxpRUFBaUUsS0FBSyxjQUFjLCtCQUErQixHQUFHLGtCQUFrQixlQUFlLHdCQUF3QixxQkFBcUIsWUFBWSxpQkFBaUIsVUFBVSxpQ0FBaUMsMkRBQTJELFlBQVksSUFBSSxjQUFjLG1CQUFtQixtQkFBbUIsNERBQTRELEtBQUssRUFBRSxLQUFLLGtIQUFrSCx5Q0FBeUMsa0JBQWtCLE1BQU0seUJBQXlCLG9CQUFvQiw4QkFBOEIsU0FBUyxrQ0FBa0MsU0FBUywwRUFBMEUsSUFBSSxTQUFTLHlDQUF5QyxhQUFhLE1BQU0sMkJBQTJCLGlCQUFpQixNQUFNLG9CQUFvQiwyQkFBMkIsTUFBTSwrQkFBK0IsU0FBUyxjQUFjLFNBQVMsWUFBWSxRQUFRLE1BQU0scUJBQXFCLE9BQU8sZ0NBQWdDLFdBQVcsb0JBQW9CLGNBQWMsb0JBQW9CLCtCQUErQix5RUFBeUUsK0RBQStELG1DQUFtQyx3TUFBd00sbUNBQW1DLHlDQUF5QyxNQUFNLDRCQUE0QixnQkFBZ0Isb01BQW9NLDZCQUE2QiwwQ0FBMEMsdUNBQXVDLDBCQUEwQixrT0FBa08sc0NBQXNDLHdEQUF3RCwwQkFBMEIsa0JBQWtCLEdBQUcsR0FBRyw2QkFBNkIseUNBQXlDLG9CQUFvQiw0QkFBNEIsZ0JBQWdCLDBIQUEwSCxxQ0FBcUMsd0lBQXdJLGtCQUFrQixHQUFHLEdBQUcsaUNBQWlDLDBHQUEwRyxrQ0FBa0MsZUFBZSxzQ0FBc0MsYUFBYSw0QkFBNEIsSUFBSSxtRUFBbUUsWUFBWSxpQkFBaUIsZ0NBQWdDLHlDQUF5QyxNQUFNLDRCQUE0QixnQkFBZ0IseUNBQXlDLDBDQUEwQyxtREFBbUQsR0FBRyxHQUFHLHlDQUF5Qyx5Q0FBeUMsNEJBQTRCLGdCQUFnQixpSUFBaUksaUdBQWlHLGtCQUFrQixHQUFHLEdBQUcsbUNBQW1DLHlDQUF5QyxVQUFVLDRCQUE0QixnQkFBZ0IscVFBQXFRLHVDQUF1QyxxREFBcUQsd0RBQXdELDRCQUE0QiwrQ0FBK0MsR0FBRyxHQUFHLDZDQUE2QyxNQUFNLHlDQUF5Qyw0QkFBNEIsNEJBQTRCLGdCQUFnQixrTkFBa04sd0VBQXdFLHlDQUF5Qyw4RUFBOEUsa0dBQWtHLHVDQUF1QyxxREFBcUQsd0RBQXdELDRCQUE0QiwrQ0FBK0MsR0FBRyxHQUFHLG9DQUFvQyxzRUFBc0UsdUNBQXVDLCtFQUErRSx3QkFBd0Isc0dBQXNHLGtDQUFrQyw4RUFBOEUsMENBQTBDLElBQUksS0FBSyx1Q0FBdUMsZUFBZSxPQUFPLDhCQUE4QixxQkFBcUIsb0RBQW9ELEVBQUUsT0FBTyx3Q0FBd0MsOENBQThDLHdEQUF3RCxxQ0FBcUMsUUFBUSw2Q0FBNkMscUNBQXFDLEdBQUcsY0FBYywyRkFBMkYsbUNBQW1DLG1FQUFtRSwrQkFBK0IsOEJBQThCLHdDQUF3QyxhQUFhLFVBQVUsMkJBQTJCLDRCQUE0Qix3SEFBd0gsMkRBQTJELGdDQUFnQyx5Q0FBeUMsUUFBUSw0QkFBNEIsZ0JBQWdCLHdGQUF3RixrREFBa0QsR0FBRyxHQUFHLHFDQUFxQyxnQ0FBZ0MsMkJBQTJCLGtEQUFrRCxpQ0FBaUMsTUFBTSxXQUFXLGlCQUFpQixHQUFHLEtBQUssUUFBUSxxQkFBcUIsc0NBQXNDLFdBQVcsb0JBQW9CLGlCQUFpQixjQUFjLEdBQUcsMENBQTBDLGlEQUFpRCxhQUFhLGNBQWMsaUJBQWlCLG1DQUFtQyxJQUFJLDJCQUEyQixtQkFBbUIsUUFBUSxJQUFJLDBDQUEwQyxJQUFJLGtCQUFrQixTQUFTLHNDQUFzQyxzREFBc0QsWUFBWSxHQUFHLHlCQUF5Qix1Q0FBdUMsc0NBQXNDLEdBQUcsU0FBUyxnQkFBZ0IsSUFBSSxLQUFLLFdBQVcscUNBQXFDLFNBQVMsbUNBQW1DLE1BQU0sb1lBQW9ZLGdCQUFnQixzREFBc0QsbUJBQW1CLDZCQUE2Qix5Q0FBeUMsVUFBVSw0QkFBNEIsZ0JBQWdCLDZGQUE2Rix1RUFBdUUsK0JBQStCLDJCQUEyQixHQUFHLEdBQUcsb0NBQW9DLGlCQUFpQixHQUFHLG1CQUFtQixZQUFZLE1BQU0sY0FBYyw0QkFBNEIsWUFBWSxZQUFZLHFDQUFxQyxtQkFBbUIsK0RBQStELHVCQUF1QixFQUFFLGdCQUFnQixpREFBaUQsSUFBSSwyQ0FBMkMsU0FBUywwQ0FBMEMsZ0VBQWdFLDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEVBQUUsUUFBUSxJQUFJLEciLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LnRzXCIpO1xuIiwiaW1wb3J0IENhbWVyYSBmcm9tICdAcGFkZGxlanMtbWVkaWFwaXBlL2NhbWVyYSc7XG5pbXBvcnQgKiBhcyBpbmZlcmVuY2VFbmdpbmUgZnJvbSAnLi9pbmZlcmVuY2VfZW5naW5lL2luZGV4X2dwdSc7XG5cblxuLy8gQ29uc3RhbnRzXG5jb25zdCBHUkFDRV9QRVJJT0RfTVMgPSA3MDAwOyAvLyBHcmFjZSBwZXJpb2QgaW4gbWlsbGlzZWNvbmRzIHRvIG5vdCBzd2l0Y2ggbW9kZWxzIHRvbyBmcmVxdWVudGx5XG5jb25zdCBTV0lUQ0hfTU9ERUxfRlBTX1RIUkVTSE9MRCA9IDQwOyAvLyBGUFMgdGhyZXNob2xkIHRvIHN3aXRjaCB0byBhIHNtYWxsZXIgbW9kZWxcblxuLy8gRXh0cmFjdCBVUkwgcGFyYW1ldGVyc1xuY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuY29uc3QgYXV0b3N0YXJ0ID0gcXVlcnlQYXJhbXMuZ2V0KCdhdXRvc3RhcnQnKTtcbmxldCBtb2RlbFR5cGUgPSBxdWVyeVBhcmFtcy5nZXQoJ21vZGVsJykgfHwgJ2xhcmdlJztcblxuLy8gRWxlbWVudHNcbmNvbnN0IGxvYWRpbmdEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXNMb2FkaW5nJyk7XG5jb25zdCB2aWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aWRlbycpIGFzIEhUTUxWaWRlb0VsZW1lbnQ7XG5jb25zdCB2aWRlb1Rvb2xEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlkZW8tdG9vbCcpO1xuY29uc3QgZGVtb0NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZW1vJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5jb25zdCBiYWNrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5jb25zdCBjb25maWRlbmNlRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpZGVuY2UnKTtcblxuLy8gQmFja2dyb3VuZCBzZXR1cFxuY29uc3QgYmFja2dyb3VuZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuYmFja2dyb3VuZENhbnZhcy53aWR0aCA9IGJhY2tDYW52YXMud2lkdGg7XG5iYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCA9IGJhY2tDYW52YXMuaGVpZ2h0O1xuXG5jb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuaW1hZ2Uuc3JjID0gJy4vYmdJbWdzL2d0LmpwZWcnO1xuaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IGJhY2tncm91bmRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBiYWNrZ3JvdW5kQ2FudmFzLndpZHRoLCBiYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCk7XG59O1xuXG4vLyBNb2RlbCB0eXBlXG5jb25zdCBtb2RlbFR5cGVEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZWwtdHlwZScpO1xubW9kZWxUeXBlRG9tLmlubmVySFRNTCA9IFwiTW9kZWwgVHlwZTogXCIgKyBtb2RlbFR5cGUudG9VcHBlckNhc2UoKTtcblxuLy8gRlBTIE1vbml0b3JpbmdcbmxldCBsYXN0RnJhbWVUaW1lID0gRGF0ZS5ub3coKTtcbmxldCBmcmFtZUNvdW50ID0gMDtcblxuLy8gQ2FtZXJhIFNldHVwXG5sZXQgY2FtZXJhU3RhcnRUaW1lID0gLTE7XG5sZXQgY2FtZXJhID0gbnVsbDtcblxuLy8gY29uZmlkZW5jZSBmb3IgbW9kZWwgc3dpdGNoaW5nXG5sZXQgY29uZmlkZW5jZSA9IHBhcnNlRmxvYXQocXVlcnlQYXJhbXMuZ2V0KCdjb25maWRlbmNlJykpIHx8IDAuNTtcbmxldCBzdGVwX3NpemUgPSBwYXJzZUZsb2F0KHF1ZXJ5UGFyYW1zLmdldCgnc3RlcC1zaXplJykpIHx8IDAuMDU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbWVyYSBhbmQgYXR0YWNoZXMgdGhlIG9uRnJhbWUgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gc2V0dXBDYW1lcmEoKSB7XG4gICAgY2FtZXJhID0gbmV3IENhbWVyYSh2aWRlbywge1xuICAgICAgICBtaXJyb3I6IHRydWUsXG4gICAgICAgIGVuYWJsZU9uSW5hY3RpdmVTdGF0ZTogdHJ1ZSxcbiAgICAgICAgb25GcmFtZTogb25DYW1lcmFGcmFtZVxuICAgIH0pO1xuXG4gICAgaWYgKGF1dG9zdGFydCA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGNhbWVyYS5zdGFydCgpO1xuICAgICAgICBjYW1lcmFTdGFydFRpbWUgPSBEYXRlLm5vdygpOyAvLyBTZXQgdGhlIGNhbWVyYSBzdGFydCB0aW1lLlxuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgZnJhbWUgYnkgdGhlIGNhbWVyYVxuICovXG5hc3luYyBmdW5jdGlvbiBvbkNhbWVyYUZyYW1lKCkge1xuICAgIGNvbnN0IHZpZGVvQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgdmlkZW9DYW52YXNDdHggPSB2aWRlb0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgdmlkZW9DYW52YXMud2lkdGggPSB2aWRlby53aWR0aDtcbiAgICB2aWRlb0NhbnZhcy5oZWlnaHQgPSB2aWRlby5oZWlnaHQ7XG5cbiAgICBpZiAodmlkZW8ucGF1c2VkKSB7XG4gICAgICAgIGRlbW9DYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9DYW52YXMsIDAsIDAsIHZpZGVvQ2FudmFzLndpZHRoLCB2aWRlb0NhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zb2xlLmxvZygnVmlkZW8gaXMgcGF1c2VkLicpO1xuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICAgIHZpZGVvQ2FudmFzQ3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgdmlkZW8ud2lkdGgsIHZpZGVvLmhlaWdodCk7XG4gICAgICAgIGluZmVyZW5jZUVuZ2luZS5kcmF3SHVtYW5TZWcodmlkZW9DYW52YXMsIGRlbW9DYW52YXMsIGJhY2tncm91bmRDYW52YXMpO1xuICAgIH1cbiAgICBhd2FpdCB1cGRhdGVGUFMoKTtcbn1cblxuLy8gSGFuZGxlIGxvdyBGUFMgYW5kIG1vZGVsIHN3aXRjaGluZyBvbmx5IGFmdGVyIGdyYWNlIHBlcmlvZFxuYXN5bmMgZnVuY3Rpb24gYWRhcHRpdmVNb2RlbFN3aXRjaGluZyhmcHMpIHtcbiAgICAvLyBoYW5kbGUgbG93IEZQUyBhbmQgbW9kZWwgc3dpdGNoaW5nIG9ubHkgYWZ0ZXIgZ3JhY2UgcGVyaW9kXG4gICAgaWYgKGNhbWVyYVN0YXJ0VGltZSA+IDAgJiZcbiAgICAgICAgKERhdGUubm93KCkgLSBjYW1lcmFTdGFydFRpbWUpID4gR1JBQ0VfUEVSSU9EX01TICYmIFxuICAgICAgICBmcHMgPCBTV0lUQ0hfTU9ERUxfRlBTX1RIUkVTSE9MRCkgXG4gICAge1xuICAgICAgICBjb25maWRlbmNlIC89IDI7XG4gICAgICAgIHN0ZXBfc2l6ZSAvPSAyO1xuICAgICAgICBjb25zb2xlLmxvZyhzdGVwX3NpemUpO1xuICAgIH0gZWxzZSBpZihmcHMgPj0gU1dJVENIX01PREVMX0ZQU19USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gY29uZmlkZW5zZSBpcyBjYXBwZWQgYXQgMVxuICAgICAgICBjb25maWRlbmNlICs9IHN0ZXBfc2l6ZTtcbiAgICAgICAgY29uZmlkZW5jZSA9IE1hdGgubWluKGNvbmZpZGVuY2UsIDEpO1xuICAgIH1cbiAgICBpZiAobW9kZWxUeXBlICE9PSAnc21hbGwnICYmIGNvbmZpZGVuY2UgPCAwLjUpIHtcbiAgICAgICAgYXdhaXQgc3dpdGNoVG9Nb2RlbCgnc21hbGwnKTtcbiAgICB9XG4gICAgLy8gaWYgY29uZmlkZW5jZSBpcyBoaWdoLCBzd2l0Y2ggdG8gbGFyZ2UgbW9kZWxcbiAgICBpZiAobW9kZWxUeXBlICE9PSAnbGFyZ2UnICYmIGNvbmZpZGVuY2UgPiAwLjgpIHtcbiAgICAgICAgYXdhaXQgc3dpdGNoVG9Nb2RlbCgnbGFyZ2UnKTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGNvbmZpZGVuY2UgRE9NXG4gICAgY29uZmlkZW5jZURvbS5pbm5lckhUTUwgPSBcIkNvbmZpZGVuY2U6IFwiICsgY29uZmlkZW5jZS50b0ZpeGVkKDIpO1xufVxuXG4vKipcbiAqIE1vbml0b3JzIGFuZCB1cGRhdGVzIEZQUyBpbiB0aGUgRE9NXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZQUygpIHtcbiAgICBjb25zdCBmcHNEaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZwcycpO1xuICAgIGlmICh2aWRlby5wYXVzZWQpIHtcbiAgICAgICAgZnBzRGlzcGxheS5pbm5lckhUTUwgPSBcIkZQUzogMFwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnJhbWVDb3VudCsrO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBub3cgLSBsYXN0RnJhbWVUaW1lO1xuICAgIGlmIChkdXJhdGlvbiA+IDEwMDApIHtcbiAgICAgICAgbGV0IGZwcyA9IE1hdGgucm91bmQoKGZyYW1lQ291bnQgKiAxMDAwKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgZnBzRGlzcGxheS5pbm5lckhUTUwgPSBcIkZQUzogXCIgKyBmcHMudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gY2hhbmdlIGNvbG9yIGJhc2VkIG9uIGZwc1xuICAgICAgICBpZiAoZnBzIDwgU1dJVENIX01PREVMX0ZQU19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGZwc0Rpc3BsYXkuc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChmcHMgPCA1MCkge1xuICAgICAgICAgICAgZnBzRGlzcGxheS5zdHlsZS5jb2xvciA9ICdvcmFuZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnBzRGlzcGxheS5zdHlsZS5jb2xvciA9ICdncmVlbic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciBGUFMgYW5kIG1vZGVsIHN3aXRjaGluZyBhZnRlciBncmFjZSBwZXJpb2RcbiAgICAgICAgYXdhaXQgYWRhcHRpdmVNb2RlbFN3aXRjaGluZyhmcHMpO1xuXG4gICAgICAgIGZyYW1lQ291bnQgPSAwO1xuICAgICAgICBsYXN0RnJhbWVUaW1lID0gbm93O1xuICAgIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IG1vZGVsIHNpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaXplIC0gVGhlIG1vZGVsIHNpemUgdG8gc3dpdGNoIHRvLlxuICovXG5hc3luYyBmdW5jdGlvbiBzd2l0Y2hUb01vZGVsKHNpemUpIHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBzd2l0Y2hpbmcgbG9naWNcbiAgICBjYW1lcmEucGF1c2UoKTsgLy8gcGF1c2UgdGhlIGNhbWVyYSB3aGVuIHN3aXRjaGluZyBtb2RlbHNcbiAgICBhd2FpdCBpbmZlcmVuY2VFbmdpbmUuc3dhcE1vZGVsKHtcbiAgICAgICAgbmVlZFByZWhlYXQ6IHRydWUsXG4gICAgICAgIG1vZGVsVHlwZTogc2l6ZSxcbiAgICB9KTtcbiAgICAvLyBtb2RlbCBzd2l0Y2hpbmcgaXMgZG9uZSFcbiAgICBjYW1lcmFTdGFydFRpbWUgPSBEYXRlLm5vdygpOyAvLyByZXN0YXJ0IGdyYWNlIHBlcmlvZCBjb3VudGVyXG4gICAgbW9kZWxUeXBlRG9tLmlubmVySFRNTCA9IFwiTW9kZWwgVHlwZTogXCIgKyBzaXplLnRvVXBwZXJDYXNlKCk7IC8vIHVwZGF0ZSBtb2RlbCB0eXBlIERPTVxuICAgIG1vZGVsVHlwZSA9IHNpemU7IC8vIHVwZGF0ZSBpbnRlcm5hbCBtb2RlbCB0eXBlIHN0YXRlXG4gICAgY2FtZXJhLnN0YXJ0KCk7IC8vIHJlc3RhcnQgdGhlIGNhbWVyYVxufVxuXG4vKipcbiAqIExvYWRzIGFuZCBpbml0aWFsaXplcyB0aGUgc3BlY2lmaWVkIG1vZGVsIHNpemUgYmFzZWQgb24gVVJMIHBhcmFtZXRlcnMgb3IgZGVmYXVsdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZE1vZGVsKCkge1xuICAgIC8vIERlZmluZSBtb2RlbCBsb2FkaW5nIGxvZ2ljIGJhc2VkIG9uIHRoZSBtb2RlbCB0eXBlXG4gICAgc3dpdGNoIChtb2RlbFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGFyZ2UnOlxuICAgICAgICAgICAgYXdhaXQgaW5mZXJlbmNlRW5naW5lLmxvYWQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZWVkUHJlaGVhdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUeXBlOiAnbGFyZ2UnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICAgIGF3YWl0IGluZmVyZW5jZUVuZ2luZS5sb2FkKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZFByZWhlYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVHlwZTogJ21lZGl1bScsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzbWFsbCc6XG4gICAgICAgICAgICBhd2FpdCBpbmZlcmVuY2VFbmdpbmUubG9hZChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRQcmVoZWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbFR5cGU6ICdzbWFsbCcsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXdhaXQgaW5mZXJlbmNlRW5naW5lLmxvYWQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgbW9kZWw6ICR7bW9kZWxUeXBlfWApO1xuICAgIHNldHVwQ2FtZXJhKCk7XG59XG5cbi8vIEV2ZW50IExpc3RlbmVyc1xudmlkZW8gJiYgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICBsb2FkaW5nRG9tICYmIGxvYWRpbmdEb20ucmVtb3ZlKCk7XG59KTtcblxudmlkZW9Ub29sRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGU6IEV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgaWYgKHRhcmdldC5pZCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjYW1lcmEuc3RhcnQoKTtcbiAgICAgICAgY2FtZXJhU3RhcnRUaW1lID0gRGF0ZS5ub3coKTsgLy8gUmVzZXQgdGhlIGNhbWVyYSBzdGFydCB0aW1lLlxuICAgIH1cbiAgICBpZiAodGFyZ2V0LmlkID09PSAncGF1c2UnKSB7XG4gICAgICAgIGNhbWVyYS5wYXVzZSgpO1xuICAgIH1cbn0pO1xuXG5sb2FkTW9kZWwoKTsgLy8gbG9hZCB0aGUgbW9kZWwgYW5kIHN0YXJ0IHRoZSBjYW1lcmEiLCIvKipcbiAqIEBmaWxlIHNlZyBvciBibHVyIG9yaWdpbiBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIG1haW5GdW5jKHtcbiAgICBvdXRcbn0pIHtcbiAgICBjb25zdCBUSFJFU0hIT0xEID0gMC4yO1xuICAgIHJldHVybiBgXG5cbiAgICAjZGVmaW5lIFNJR01BIFNJR01BIDMuMFxuICAgICNkZWZpbmUgQkxVUl9NU0laRSA4XG4gICAgI2RlZmluZSBNU0laRSAzXG4gICAgI2RlZmluZSBrZXJuZWxTaXplIDUuMFxuICAgICNkZWZpbmUgd2VpZ2h0IDEuMFxuXG4gICAgdW5pZm9ybSBpbnQgdHlwZTsgLy8gMDogYmx1ckJhY2tncm91bmQgMTogZHJhd0h1bWFuc2VnIDI6IGRyYXdNYXNrXG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgb3V0Q29vcmQgPSB2Q29vcmQueHk7XG4gICAgICAgXG4gICAgICAgIG91dENvb3JkLnkgPSAxLjAgLSB2Q29vcmQueTtcblxuICAgICAgICB2ZWMyIHNvdXJjZVRleHR1cmVTaXplID0gdmVjMigke291dC53aWR0aF9zaGFwZX0sICR7b3V0LmhlaWdodF9zaGFwZX0pO1xuICAgICAgICB2ZWMyIHNvdXJjZVRleGVsU2l6ZSA9IDEuMCAvIHNvdXJjZVRleHR1cmVTaXplO1xuXG4gICAgICAgIGZsb2F0IGtlcm5lbFtNU0laRV07IC8vIDNcbiAgICAgICAga2VybmVsWzBdID0gMC4xMjU3OTM2OTAxNzUyMjE2NjtcbiAgICAgICAga2VybmVsWzFdID0gMC4xMzI5ODtcbiAgICAgICAga2VybmVsWzJdID0gMC4xMjU3OTM2OTAxNzUyMjE2NjtcblxuICAgICAgICBmbG9hdCBvcmlnaW5fYWxwaGEgPSAxLjAgLSBURVhUVVJFMkQodGV4dHVyZV9vcmlnaW4sIHZlYzIob3V0Q29vcmQueCwgb3V0Q29vcmQueSkgLyAyLjApLnI7XG4gICAgICAgIHZlYzQgY291bnRlciA9IFRFWFRVUkUyRCh0ZXh0dXJlX2NvdW50ZXIsIG91dENvb3JkLnh5KTtcbiAgICAgICAgdmVjNCByZXMgPSB2ZWM0KDAuMCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gMCkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIENoZWFwIEJveCBCbHVyIFxuICAgICAgICAgICAgZmxvYXQgcGl4ZWxTaXplWCA9IDEuMCAvIGZsb2F0KCR7b3V0LndpZHRoX3NoYXBlfSk7XG4gICAgICAgICAgICBmbG9hdCBwaXhlbFNpemVZID0gMS4wIC8gZmxvYXQoJHtvdXQuaGVpZ2h0X3NoYXBlfSk7IFxuICAgIFxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBCbHVyXG4gICAgICAgICAgICB2ZWM0IGFjY3VtdWxhdGlvbiA9IHZlYzQoMCk7XG4gICAgICAgICAgICBmbG9hdCB3ZWlnaHRzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGZsb2F0IGkgPSAta2VybmVsU2l6ZTsgaSA8PSBrZXJuZWxTaXplOyBpKyspe1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGlvbiArPSBURVhUVVJFMkQodGV4dHVyZV9jb3VudGVyLCBvdXRDb29yZC54eSArIHZlYzIoaSAqIHBpeGVsU2l6ZVgsIDAuMCkpICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgIHdlaWdodHN1bSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBCbHVyXG4gICAgICAgICAgICBmb3IgKGZsb2F0IGkgPSAta2VybmVsU2l6ZTsgaSA8PSBrZXJuZWxTaXplOyBpKyspe1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGlvbiArPSBURVhUVVJFMkQodGV4dHVyZV9jb3VudGVyLCBvdXRDb29yZC54eSArIHZlYzIoMC4wLCBpICogcGl4ZWxTaXplWSkpICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgIHdlaWdodHN1bSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlcyA9IGFjY3VtdWxhdGlvbiAvIHdlaWdodHN1bTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5fYWxwaGEgPiAke1RIUkVTSEhPTER9KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IGNvdW50ZXI7XG4gICAgICAgICAgICByZXMuYSA9IG9yaWdpbl9hbHBoYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5fYWxwaGEgPiAke1RIUkVTSEhPTER9KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gdmVjNCgxLjApO1xuICAgICAgICAgICAgICAgIHJlcy5hID0gb3JpZ2luX2FscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHNldFBhY2tlZE91dHB1dChyZXMpO1xuICAgIH1cbiAgICBgO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbWFpbkZ1bmMsXG4gICAgdGV4dHVyZUZ1bmNDb25mOiB7XG4gICAgICAgIG9yaWdpbjogW10sXG4gICAgICAgIGNvdW50ZXI6IFtdXG4gICAgfVxufTtcbiIsIi8qKlxuICogQGZpbGUgYWRkIGRlYWwgb3JpZ2luIG9wXG4gKi9cblxuaW1wb3J0IHsgVHJhbnNmb3JtZXIsIGVudiwgaW50ZXJmYWNlcyB9IGZyb20gJ0BwYWRkbGVqcy9wYWRkbGVqcy1jb3JlJztcblxuY29uc3QgSU1HX09SSUdJTiA9ICdpbWFnZSc7XG5jb25zdCBGSU5BTF9QQUNLX09QX05BTUUgPSAnZmV0Y2hfcGFjayc7XG5jb25zdCBERUZBVUxUX1dJRFRIID0gNTAwO1xuY29uc3QgREVGQVVMVF9IRUlHSFQgPSAyODA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYWxPcmlnaW4gZXh0ZW5kcyBUcmFuc2Zvcm1lciB7XG4gICAgcHJpdmF0ZSB3aWR0aDtcbiAgICBwcml2YXRlIGhlaWdodDtcblxuICAgIGNvbnN0cnVjdG9yKHdpZHRoPzogbnVtYmVyLCBoZWlnaHQ/OiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoJ0RlYWxPcmlnaW4nKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IERFRkFVTFRfV0lEVEg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IERFRkFVTFRfSEVJR0hUO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybSguLi5hcmdzOiBhbnkpIHtcbiAgICAgICAgaWYgKCFlbnYuZ2V0KCd3ZWJnbF9ncHVfcGlwZWxpbmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvcHMsIHZhcnNdID0gYXJncztcbiAgICAgICAgY29uc3QgZmV0Y2hPcCA9IG9wcy5maW5kKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnZmV0Y2gnKTtcbiAgICAgICAgY29uc3QgW2lucHV0TmFtZV0gPSBmZXRjaE9wLmlucHV0cy5YO1xuXG4gICAgICAgIGNvbnN0IHNlZ0ltZ09wID0ge1xuICAgICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgWDogW2lucHV0TmFtZV0sXG4gICAgICAgICAgICAgICAgWTogW0lNR19PUklHSU5dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0cHV0czoge1xuICAgICAgICAgICAgICAgIE91dDogW0ZJTkFMX1BBQ0tfT1BfTkFNRV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnc2VnSW1nJyxcbiAgICAgICAgICAgIGlzUGFja2VkOiB0cnVlLFxuICAgICAgICAgICAgYnVmZmVyVHlwZTogaW50ZXJmYWNlcy5CdWZmZXJUeXBlLkNvbG9yQnVmZmVyLFxuICAgICAgICAgICAgdW5pZm9ybToge1xuICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJzFpJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcGFja091dFZhciA9IHtcbiAgICAgICAgICAgIG5hbWU6IEZJTkFMX1BBQ0tfT1BfTkFNRSxcbiAgICAgICAgICAgIHNoYXBlOiBbMSwgMSwgdGhpcy5oZWlnaHQsIHRoaXMud2lkdGhdLFxuICAgICAgICAgICAgcGVyc2lzdGFibGU6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgZmV0Y2hPcC5pbnB1dHMuWCA9IFtGSU5BTF9QQUNLX09QX05BTUVdO1xuICAgICAgICBvcHMucHVzaChzZWdJbWdPcCk7XG4gICAgICAgIGlmICh2YXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHZhcnMucHVzaCguLi5bcGFja091dFZhcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyc1tGSU5BTF9QQUNLX09QX05BTUVdID0gcGFja091dFZhcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICogQGZpbGUgQ29yZSBpbmZlcmVuY2UgZW5naW5lIGZvciBidXp6U3RyZWFtLCBlbmNhcHN1bGF0ZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uYWxpdGllczpcbiAqIC8vIDEpIExvYWQgbW9kZWxzIGZyb20gUGFkZGxlJ3MgbW9kZWwgem9vXG4gKiAvLyAyKSBQcmVoZWF0IG1vZGVsc1xuICogLy8gMykgUnVuIGluZmVyZW5jZSBvbiBpbnB1dCBpbWFnZVxuICogLy8gNCkgRHJhdyBpbmZlcmVuY2UgcmVzdWx0cyBvbiBjYW52YXNcbiAqIC8vIDUpIEhvdC1zd2FwIG1vZGVsc1xuICovXG5cbmltcG9ydCB7IFJ1bm5lciwgZW52LCByZWdpc3Rlck9wIH0gZnJvbSAnQHBhZGRsZWpzL3BhZGRsZWpzLWNvcmUnO1xuaW1wb3J0IHsgR0xIZWxwZXIgfSBmcm9tICdAcGFkZGxlanMvcGFkZGxlanMtYmFja2VuZC13ZWJnbCc7XG5pbXBvcnQgc2VnSW1nIGZyb20gJy4vY3VzdG9tT3Avc2VnSW1nJztcbmltcG9ydCBBcHBlbmREZWFsT3JpZ2luT3BUb05OIGZyb20gJy4vY3VzdG9tVHJhbnNmb3JtZXIvYXBwZW5kQ3VzdG9tT3BUb05OJztcblxuaW50ZXJmYWNlIExvYWRPcHRpb25zIHtcbiAgICBuZWVkUHJlaGVhdD86IGJvb2xlYW4sXG4gICAgbW9kZWxUeXBlPzogc3RyaW5nLFxuICAgIGNhbnZhc1dpZHRoPzogbnVtYmVyLFxuICAgIGNhbnZhc0hlaWdodD86IG51bWJlclxufVxuXG5sZXQgcnVubmVyID0gbnVsbCBhcyBSdW5uZXI7XG5cbmNvbnN0IFdJRFRIID0gMzk4O1xuY29uc3QgSEVJR0hUID0gMjI0O1xuXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbU9wKCkge1xuICAgIHJlZ2lzdGVyT3Aoc2VnSW1nLCAnc2VnSW1nJyk7XG59XG5cbnJlZ2lzdGVyQ3VzdG9tT3AoKTtcblxuXG5jb25zdCBXRUJHTF9BVFRSSUJVVEVTID0gT2JqZWN0LmFzc2lnbih7fSwgR0xIZWxwZXIuV0VCR0xfQVRUUklCVVRFUywge1xuICAgIGFscGhhOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gY3JlYXRlV2ViZ2xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgV0VCR0xfQVRUUklCVVRFUykgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgbnVsbDtcbiAgICBpZiAoZ2wpIHtcbiAgICAgICAgZW52LnNldCgnd2ViZ2xWZXJzaW9uJywgMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYuc2V0KCd3ZWJnbFZlcnNpb24nLCAxKTtcbiAgICAgICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgV0VCR0xfQVRUUklCVVRFUylcbiAgICAgICAgICAgIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBXRUJHTF9BVFRSSUJVVEVTKSkgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBnbCBhcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG59XG5cbmxldCByZW5kZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbnJlbmRlckNhbnZhcy53aWR0aCA9IDUwMDtcbnJlbmRlckNhbnZhcy5oZWlnaHQgPSAyODA7XG5sZXQgZ2wgPSBjcmVhdGVXZWJnbENvbnRleHQocmVuZGVyQ2FudmFzKTtcblxubGV0IHNlZ0ltZ09wID0gbnVsbDtcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3dhcE1vZGVsKG9wdGlvbnM6IExvYWRPcHRpb25zID0ge1xuICAgIG5lZWRQcmVoZWF0OiB0cnVlLFxuICAgIG1vZGVsVHlwZTogJ2xhcmdlJyxcbiAgICBjYW52YXNXaWR0aDogNTAwLFxuICAgIGNhbnZhc0hlaWdodDogMjgwXG59KSB7XG4gICAgLy8gdGVhciBkb3duIHRoZSBwcmV2aW91cyBydW5uZXJcbiAgICBydW5uZXIuc3RvcFByZWRpY3QoKTtcbiAgICBydW5uZXIgPSBudWxsO1xuICAgIHNlZ0ltZ09wID0gbnVsbDtcbiAgICAvLyByZW1vdmUgdGhlIHByZXZpb3VzIGNhbnZhc1xuICAgIHJlbmRlckNhbnZhcy5yZW1vdmUoKTtcbiAgICAvLyBjcmVhdGUgYSBuZXcgY2FudmFzXG4gICAgcmVuZGVyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgcmVuZGVyQ2FudmFzLndpZHRoID0gNTAwO1xuICAgIHJlbmRlckNhbnZhcy5oZWlnaHQgPSAyODA7XG4gICAgZ2wgPSBjcmVhdGVXZWJnbENvbnRleHQocmVuZGVyQ2FudmFzKTtcbiAgICAvLyBsb2FkIHRoZSBuZXcgbW9kZWxcbiAgICBhd2FpdCBsb2FkKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZChvcHRpb25zOiBMb2FkT3B0aW9ucyA9IHtcbiAgICBuZWVkUHJlaGVhdDogdHJ1ZSxcbiAgICBtb2RlbFR5cGU6ICdsYXJnZScsXG4gICAgY2FudmFzV2lkdGg6IDUwMCxcbiAgICBjYW52YXNIZWlnaHQ6IDI4MFxufSkge1xuICAgIC8vIFB1bGwgbW9kZWwgZnJvbSBQYWRkbGUncyBtb2RlbCB6b28gcmF0aGVyIHRoYW4gbG9jYWwgZmlsZSBmb3IgcmVwcm9kdWNpYmlsaXR5XG4gICAgY29uc3QgbGFyZ2VNb2RlbHBhdGggPSAnaHR0cHM6Ly9wYWRkbGVqcy5iai5iY2Vib3MuY29tL21vZGVscy9mdXNlL2h1bWFuc2VnL2h1bWFuc2VnXzM5OHgyMjRfZnVzZV9hY3RpdmF0aW9uL21vZGVsLmpzb24nO1xuICAgIGNvbnN0IG1kZWRpdW1Nb2RlbFBhdGggPSAnaHR0cHM6Ly9wYWRkbGVqcy5jZG4uYmNlYm9zLmNvbS9tb2RlbHMvaHVtYW5zZWd2Mi9tb2RlbC5qc29uJztcbiAgICBjb25zdCBzbWFsbE1vZGVsUGF0aCA9ICdodHRwczovL3BhZGRsZWpzLmJqLmJjZWJvcy5jb20vbW9kZWxzL2Z1c2UvaHVtYW5zZWcvaHVtYW5zZWdfMjg4eDE2MF9mdXNlX2FjdGl2YXRpb24vbW9kZWwuanNvbic7XG4gICAgY29uc3QgbW9kZWxQYXRoID0gb3B0aW9ucy5tb2RlbFR5cGUgPT09ICdsYXJnZScgPyBsYXJnZU1vZGVscGF0aCA6IG9wdGlvbnMubW9kZWxUeXBlID09PSAnbWVkaXVtJyA/IG1kZWRpdW1Nb2RlbFBhdGggOiBzbWFsbE1vZGVsUGF0aDtcblxuXG4gICAgcnVubmVyID0gbmV3IFJ1bm5lcih7XG4gICAgICAgIG1vZGVsUGF0aDogbW9kZWxQYXRoLFxuICAgICAgICBuZWVkUHJlaGVhdDogb3B0aW9ucy5uZWVkUHJlaGVhdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uZWVkUHJlaGVhdCA6IHRydWUsXG4gICAgICAgIGZlZWRTaGFwZToge1xuICAgICAgICAgICAgZnc6IFdJRFRILFxuICAgICAgICAgICAgZmg6IEhFSUdIVFxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICAgIG1lYW46IFswLjUsIDAuNSwgMC41XSxcbiAgICAgICAgc3RkOiBbMC41LCAwLjUsIDAuNV0sXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICAgIHByZVRyYW5zZm9ybXM6IFtuZXcgQXBwZW5kRGVhbE9yaWdpbk9wVG9OTihvcHRpb25zLmNhbnZhc1dpZHRoLCBvcHRpb25zLmNhbnZhc0hlaWdodCldXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEdMSGVscGVyLnNldFdlYkdMUmVuZGVyaW5nQ29udGV4dChnbCk7XG5cbiAgICBlbnYuc2V0KCd3ZWJnbF9wYWNrX2NoYW5uZWwnLCB0cnVlKTtcbiAgICBlbnYuc2V0KCd3ZWJnbF9ncHVfcGlwZWxpbmUnLCB0cnVlKTtcbiAgICBlbnYuc2V0KCd3ZWJnbF9mb3JjZV9oYWxmX2Zsb2F0X3RleHR1cmUnLCB0cnVlKTtcblxuICAgIGF3YWl0IHJ1bm5lci5pbml0KCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVoZWF0KCkge1xuICAgIHJldHVybiBhd2FpdCBydW5uZXIucHJlaGVhdCgpO1xufVxuXG5cbi8qKlxuICogZHJhdyBodW1hbiBzZWdcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH0gaW5wdXQgdGhlIGlucHV0IGltYWdlXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgdGhlIGRlc3QgY2FudmFzIGRyYXdzIHRoZSBwaXhlbHNcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGJhY2sgYmFja2dyb3VuZCBjYW52YXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRyYXdIdW1hblNlZyhcbiAgICBpbnB1dDogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIGJhY2s/OiBIVE1MQ2FudmFzRWxlbWVudFxuKSB7XG4gICAgaWYgKCFzZWdJbWdPcCkge1xuICAgICAgICBzZWdJbWdPcCA9IHJ1bm5lci53ZWlnaHRNYXBbcnVubmVyLndlaWdodE1hcC5sZW5ndGggLSAxXS5vcERhdGE7XG4gICAgfVxuICAgIHNlZ0ltZ09wLnVuaWZvcm0udHlwZS52YWx1ZSA9IDE7XG4gICAgYXdhaXQgcnVubmVyLnByZWRpY3QoaW5wdXQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRTaXplID0gZ2VuQmFja2dyb3VuZFNpemUoaW5wdXQpO1xuICAgIGNhbnZhcy53aWR0aCA9IGlucHV0LndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbnB1dC5oZWlnaHQ7XG4gICAgY29uc3QgZGVzdEN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChiYWNrKSB7XG4gICAgICAgIGRlc3RDdHguZHJhd0ltYWdlKGJhY2ssIC1iYWNrZ3JvdW5kU2l6ZS5ieCwgLWJhY2tncm91bmRTaXplLmJ5LCBiYWNrZ3JvdW5kU2l6ZS5idywgYmFja2dyb3VuZFNpemUuYmgpO1xuICAgIH1cbiAgICBkZXN0Q3R4LmRyYXdJbWFnZShnbC5jYW52YXMsIC1iYWNrZ3JvdW5kU2l6ZS5ieCwgLWJhY2tncm91bmRTaXplLmJ5LCBiYWNrZ3JvdW5kU2l6ZS5idywgYmFja2dyb3VuZFNpemUuYmgpO1xufVxuXG4vKipcbiAqIGRyYXcgaHVtYW4gc2VnXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnR9IGlucHV0IHRoZSBpbnB1dCBpbWFnZVxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIHRoZSBkZXN0IGNhbnZhcyBkcmF3cyB0aGUgcGl4ZWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBibHVyQmFja2dyb3VuZChcbiAgICBpbnB1dDogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCxcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pIHtcbiAgICBpZiAoIXNlZ0ltZ09wKSB7XG4gICAgICAgIHNlZ0ltZ09wID0gcnVubmVyLndlaWdodE1hcFtydW5uZXIud2VpZ2h0TWFwLmxlbmd0aCAtIDFdLm9wRGF0YTtcbiAgICB9XG4gICAgc2VnSW1nT3AudW5pZm9ybS50eXBlLnZhbHVlID0gMDtcbiAgICBhd2FpdCBydW5uZXIucHJlZGljdChpbnB1dCk7XG4gICAgY2FudmFzLndpZHRoID0gaW5wdXQud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGlucHV0LmhlaWdodDtcbiAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IGdlbkJhY2tncm91bmRTaXplKGlucHV0KTtcbiAgICBjb25zdCBkZXN0Q3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZGVzdEN0eC5kcmF3SW1hZ2UoZ2wuY2FudmFzLCAtYmFja2dyb3VuZFNpemUuYngsIC1iYWNrZ3JvdW5kU2l6ZS5ieSwgYmFja2dyb3VuZFNpemUuYncsIGJhY2tncm91bmRTaXplLmJoKTtcbn1cblxuLyoqXG4gKiBkcmF3IGh1bWFuIG1hc2tcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudH0gaW5wdXQgdGhlIGlucHV0IGltYWdlXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgdGhlIGRlc3QgY2FudmFzIGRyYXdzIHRoZSBwaXhlbHNcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGJhY2sgYmFja2dyb3VuZCBjYW52YXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRyYXdNYXNrKFxuICAgIGlucHV0OiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gICAgYmFjazogSFRNTENhbnZhc0VsZW1lbnRcbikge1xuICAgIGlmICghc2VnSW1nT3ApIHtcbiAgICAgICAgc2VnSW1nT3AgPSBydW5uZXIud2VpZ2h0TWFwW3J1bm5lci53ZWlnaHRNYXAubGVuZ3RoIC0gMV0ub3BEYXRhO1xuICAgIH1cbiAgICBzZWdJbWdPcC51bmlmb3JtLnR5cGUudmFsdWUgPSAyO1xuICAgIGF3YWl0IHJ1bm5lci5wcmVkaWN0KGlucHV0KTtcbiAgICBjYW52YXMud2lkdGggPSBpbnB1dC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW5wdXQuaGVpZ2h0O1xuICAgIGNvbnN0IGJhY2tncm91bmRTaXplID0gZ2VuQmFja2dyb3VuZFNpemUoaW5wdXQpO1xuICAgIGNvbnN0IGRlc3RDdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkZXN0Q3R4LmRyYXdJbWFnZShiYWNrLCAtYmFja2dyb3VuZFNpemUuYngsIC1iYWNrZ3JvdW5kU2l6ZS5ieSwgYmFja2dyb3VuZFNpemUuYncsIGJhY2tncm91bmRTaXplLmJoKTtcbiAgICBkZXN0Q3R4LmRyYXdJbWFnZShnbC5jYW52YXMsIC1iYWNrZ3JvdW5kU2l6ZS5ieCwgLWJhY2tncm91bmRTaXplLmJ5LCBiYWNrZ3JvdW5kU2l6ZS5idywgYmFja2dyb3VuZFNpemUuYmgpO1xufVxuXG5mdW5jdGlvbiBnZW5CYWNrZ3JvdW5kU2l6ZShpbnB1dEVsZW1lbnQpIHtcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgY2FudmFzXG4gICAgbGV0IHN3ID0gV0lEVEg7XG4gICAgbGV0IHNoID0gSEVJR0hUO1xuICAgIGNvbnN0IHJhdGlvID0gc3cgLyBzaDtcbiAgICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXRFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBpbnB1dEVsZW1lbnQud2lkdGg7XG4gICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dEVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBpbnB1dEVsZW1lbnQuaGVpZ2h0O1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGJ4ID0gMDtcbiAgICBsZXQgYnkgPSAwO1xuICAgIGxldCBiaCA9IGlucHV0SGVpZ2h0O1xuICAgIGxldCBidyA9IGlucHV0V2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luX3JhdGlvID0gaW5wdXRXaWR0aCAvIGlucHV0SGVpZ2h0O1xuICAgIC8vIGlmIHRhcmdldCdzIHJhdGlvIGlzIGxhcmdlciB0aGFuIG9yaWdpbiBpbWFnZSdzIHJhdGlvLCB0aGVuIHNldCB0aGUgaGVpZ2h0IG9mIG9yaWdpbiBpbWFnZSB0byB0YXJnZXQncyBoZWlnaHRcbiAgICBpZiAocmF0aW8gLyBvcmlnaW5fcmF0aW8gPj0gMSkge1xuICAgICAgICBzdyA9IHNoICogb3JpZ2luX3JhdGlvO1xuICAgICAgICB4ID0gTWF0aC5mbG9vcigoV0lEVEggLSBzdykgLyAyKTtcbiAgICAgICAgYncgPSBiaCAqIHJhdGlvO1xuICAgICAgICBieCA9IE1hdGguZmxvb3IoKGJ3IC0gaW5wdXRXaWR0aCkgLyAyKTtcbiAgICB9XG4gICAgLy8gaWYgdGFyZ2V0J3MgcmF0aW8gaXMgc21hbGxlciB0aGFuIG9yaWdpbiBpbWFnZSdzIHJhdGlvLCB0aGVuIHNldCB0aGUgd2lkdGggb2Ygb3JpZ2luIGltYWdlIHRvIHRhcmdldCdzIHdpZHRoXG4gICAgZWxzZSB7XG4gICAgICAgIHNoID0gc3cgLyBvcmlnaW5fcmF0aW87XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKChIRUlHSFQgLSBzaCkgLyAyKTtcbiAgICAgICAgYmggPSBidyAvIHJhdGlvO1xuICAgICAgICBieSA9IE1hdGguZmxvb3IoKGJoIC0gaW5wdXRIZWlnaHQpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHN3LFxuICAgICAgICBzaCxcbiAgICAgICAgYngsXG4gICAgICAgIGJ5LFxuICAgICAgICBidyxcbiAgICAgICAgYmhcbiAgICB9O1xufVxuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5wYWRkbGVqc0NhbWVyYT1lKCk6dC5wYWRkbGVqc0NhbWVyYT1lKCl9KHNlbGYsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezYwNzoodCxlLGkpPT57aS5yKGUpLGkuZChlLHtkZWZhdWx0OigpPT5vfSk7Y29uc3Qgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2b2lkIDA9PT1lJiYoZT17fSksdGhpcy5ub29wPWZ1bmN0aW9uKCl7fSx0aGlzLmRlZmF1bHRPcHRpb249e21pcnJvcjohMSx0YXJnZXRDYW52YXM6bnVsbCxvblN1Y2Nlc3M6dGhpcy5ub29wLG9uRXJyb3I6dGhpcy5ub29wLG9uTm90U3VwcG9ydGVkOnRoaXMubm9vcCxvbkZyYW1lOnRoaXMubm9vcCxzd2l0Y2hFcnJvcjp0aGlzLm5vb3AsdmlkZW9Mb2FkZWQ6dGhpcy5ub29wfSx0aGlzLnZpZGVvPXQsdGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe30sdGhpcy5kZWZhdWx0T3B0aW9uLGUpLHRoaXMuY3VycmVudE1vZGU9XCJ1c2VyXCIsdGhpcy5pbml0VmlkZW9TdHJlYW0oKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5pdFZpZGVvU3RyZWFtPWZ1bmN0aW9uKCl7dmFyIHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDt0aGlzLmlzSU9TPSEhdC5tYXRjaCgvXFwoaVteO10rOyggVTspPyBDUFUuK01hYyBPUyBYLyksdGhpcy52aWRlby53aWR0aD10aGlzLm9wdGlvbnMud2lkdGh8fHRoaXMudmlkZW8uY2xpZW50V2lkdGgsdGhpcy52aWRlby5oZWlnaHQ9dGhpcy5vcHRpb25zLmhlaWdodHx8dGhpcy52aWRlby5jbGllbnRIZWlnaHQsdGhpcy5lbnVtZXJhdGVEZXZpY2VzKCl9LHQucHJvdG90eXBlLmhhbmRsZVN0cmVhbT1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT17ZGV2aWNlSWQ6e2V4YWN0OnRoaXMudmlkZW9EZXZpY2VJZH0sZmFjaW5nTW9kZTp0aGlzLmN1cnJlbnRNb2RlLHdpZHRoOnRoaXMudmlkZW8ud2lkdGgsaGVpZ2h0OnRoaXMudmlkZW8uaGVpZ2h0fTtuYXZpZ2F0b3IubWVkaWFEZXZpY2VzJiZuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYT9uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7dmlkZW86ZX0pLnRoZW4oKGZ1bmN0aW9uKGUpe3Quc3RyZWFtPWUsdC5zdHJlYW1DYWxsYmFjaygpfSkpLmNhdGNoKHRoaXMub3B0aW9ucy5vbkVycm9yKToobmF2aWdhdG9yLmdldFVzZXJNZWRpYT1uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhfHxuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhfHxuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhfHxuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWEsbmF2aWdhdG9yLmdldFVzZXJNZWRpYT9uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKHt2aWRlbzplfSwoZnVuY3Rpb24oZSl7dC5zdHJlYW09ZSx0LnN0cmVhbUNhbGxiYWNrKCl9KSx0aGlzLm9wdGlvbnMub25FcnJvcik6dGhpcy5vcHRpb25zLm9uTm90U3VwcG9ydGVkKCkpfSx0LnByb3RvdHlwZS5lbnVtZXJhdGVEZXZpY2VzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztuYXZpZ2F0b3IubWVkaWFEZXZpY2VzJiZuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXM/bmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbigoZnVuY3Rpb24oZSl7dmFyIGk9W107ZS5mb3JFYWNoKChmdW5jdGlvbih0KXtcInZpZGVvaW5wdXRcIj09PXQua2luZCYmaS5wdXNoKHQuZGV2aWNlSWQpfSkpLHQudmlkZW9EZXZpY2VzPWksdC52aWRlb0RldmljZXMubGVuZ3RoPDImJiF0LmlzSU9TJiZ0Lm9wdGlvbnMuc3dpdGNoRXJyb3ImJnQub3B0aW9ucy5zd2l0Y2hFcnJvcigpLHQudmlkZW9EZXZpY2VJZD10LnZpZGVvRGV2aWNlc1swXSx0LmhhbmRsZVN0cmVhbSgpfSkpLmNhdGNoKChmdW5jdGlvbihlKXt0Lm9wdGlvbnMub25Ob3RTdXBwb3J0ZWQmJnQub3B0aW9ucy5vbk5vdFN1cHBvcnRlZCgpLGNvbnNvbGUuZXJyb3IoZS5uYW1lK1wiOiBcIitlLm1lc3NhZ2UpfSkpOnRoaXMub3B0aW9ucy5vbk5vdFN1cHBvcnRlZCYmdGhpcy5vcHRpb25zLm9uTm90U3VwcG9ydGVkKCl9LHQucHJvdG90eXBlLnN0cmVhbUNhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLm9wdGlvbnMub25TdWNjZXNzKCk7dmFyIGU9d2luZG93LlVSTHx8d2luZG93LndlYmtpdFVSTHx8d2luZG93Lm1velVSTHx8d2luZG93Lm1zVVJMO2lmKFwic3JjT2JqZWN0XCJpbiB0aGlzLnZpZGVvKXRyeXt0aGlzLnZpZGVvLnNyY09iamVjdD10aGlzLnN0cmVhbX1jYXRjaCh0KXt0aGlzLnZpZGVvLnNyYz1lLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnN0cmVhbSl8fHRoaXMuc3RyZWFtfXRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwoZnVuY3Rpb24oKXt0Lm9wdGlvbnMuaGVpZ2h0P3QudmlkZW8ud2lkdGg9dC52aWRlby5jbGllbnRXaWR0aDp0LnZpZGVvLmhlaWdodD10LnZpZGVvLmNsaWVudEhlaWdodCx0Lm9wdGlvbnMudmlkZW9Mb2FkZWQmJnQub3B0aW9ucy52aWRlb0xvYWRlZCgpLHQuaW5pdENhbnZhcygpfSkpfSx0LnByb3RvdHlwZS5zdG9wTWVkaWFUcmFja3M9ZnVuY3Rpb24oKXt2YXIgdCxlO251bGw9PT0oZT1udWxsPT09KHQ9dGhpcy5zdHJlYW0pfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmdldFRyYWNrcygpKXx8dm9pZCAwPT09ZXx8ZS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnN0b3AoKX0pKX0sdC5wcm90b3R5cGUuaW5pdENhbnZhcz1mdW5jdGlvbigpe3RoaXMub3B0aW9ucy50YXJnZXRDYW52YXMmJih0aGlzLmNhbnZhcz10aGlzLm9wdGlvbnMudGFyZ2V0Q2FudmFzLHRoaXMuY2FudmFzLndpZHRoPXRoaXMudmlkZW8ud2lkdGgsdGhpcy5jYW52YXMuaGVpZ2h0PXRoaXMudmlkZW8uaGVpZ2h0LHRoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksdGhpcy5vcHRpb25zLm1pcnJvciYmKHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy5jYW52YXMud2lkdGgsMCksdGhpcy5jb250ZXh0LnNjYWxlKC0xLDEpKSl9LHQucHJvdG90eXBlLnZpZGVvUmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKCl7dC5jb250ZXh0JiZ0LmNvbnRleHQuZHJhd0ltYWdlKHQudmlkZW8sMCwwLHQudmlkZW8ud2lkdGgsdC52aWRlby5oZWlnaHQpLHQub3B0aW9ucy5vbkZyYW1lKHQudmlkZW8pLHQucmVxdWVzdEFuaW1hdGlvbklkPXJlcXVlc3RBbmltYXRpb25GcmFtZShlKX07ZSgpfSx0LnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3RoaXMudmlkZW8mJnRoaXMudmlkZW8ucGxheSgpLHRoaXMucmVxdWVzdEFuaW1hdGlvbklkfHx0aGlzLnZpZGVvUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCl9LHQucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy52aWRlbyYmdGhpcy52aWRlby5wYXVzZSgpLHRoaXMuY2FudmFzJiZ0aGlzLnJlcXVlc3RBbmltYXRpb25JZCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbklkKSx0aGlzLnJlcXVlc3RBbmltYXRpb25JZD1udWxsKX0sdC5wcm90b3R5cGUuc3dpdGNoQ2FtZXJhcz1mdW5jdGlvbigpe2lmKHRoaXMuaXNJT1N8fHRoaXMudmlkZW9EZXZpY2VzJiYhKHRoaXMudmlkZW9EZXZpY2VzLmxlbmd0aDwyKSl7dGhpcy5zdG9wTWVkaWFUcmFja3MoKTt2YXIgdD10aGlzLmN1cnJlbnRNb2RlO3RoaXMuY3VycmVudE1vZGU9XCJ1c2VyXCI9PT10P1wiZW52aXJvbm1lbnRcIjpcInVzZXJcIjt2YXIgZT10aGlzLnZpZGVvRGV2aWNlSWQ7dGhpcy52aWRlb0RldmljZUlkPWU9PT10aGlzLnZpZGVvRGV2aWNlc1swXT90aGlzLnZpZGVvRGV2aWNlc1sxXTp0aGlzLnZpZGVvRGV2aWNlc1swXSx0aGlzLmhhbmRsZVN0cmVhbSgpfX0sdH0oKX19LGU9e307ZnVuY3Rpb24gaShvKXtpZihlW29dKXJldHVybiBlW29dLmV4cG9ydHM7dmFyIHM9ZVtvXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbb10ocyxzLmV4cG9ydHMsaSkscy5leHBvcnRzfXJldHVybiBpLmQ9KHQsZSk9Pntmb3IodmFyIG8gaW4gZSlpLm8oZSxvKSYmIWkubyh0LG8pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxvLHtlbnVtZXJhYmxlOiEwLGdldDplW29dfSl9LGkubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksaS5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxpKDYwNyl9KSgpfSkpOyIsIiFmdW5jdGlvbihuLGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMucGFkZGxlanM9ZSgpOihuLnBhZGRsZWpzPW4ucGFkZGxlanN8fHt9LG4ucGFkZGxlanMud2ViZ2xCYWNrZW5kPWUoKSl9KHRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ezQwMDoobixlLG8pPT57by5yKGUpLG8uZChlLHtHTEhlbHBlcjooKT0+RixnbEluc3RhbmNlOigpPT5FbixvcHM6KCk9PnluLHdlYmdsX3R5cGVzOigpPT50fSk7dmFyIHQ9e307by5yKHQpLG8uZCh0LHtVbmlmb3JtVHlwZTooKT0+Y30pO3ZhciByPXt9O28ucihyKSxvLmQocix7ZXhwX2Z1bmM6KCk9PmosaGFyZFNpZ21vaWQ6KCk9PkIsbGVha3lSZWx1OigpPT5TLHBvd19mdW5jOigpPT5ELHByZWx1OigpPT5DLHJlbHU2OigpPT5SLHNjYWxlOigpPT5JLHNjYWxlV2lkdGhCaWFzOigpPT5MLHNpZ21vaWQ6KCk9Pmssc3FydDooKT0+TSx0YW5oX2Z1bmM6KCk9PlUsdHJhbnNmZXJGcm9tTkhXQ3RvTkNIVzooKT0+T30pO3ZhciBpPXt9O2Z1bmN0aW9uIHMoKXt2YXIgbjtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KW49d2luZG93O2Vsc2UgaWYodm9pZCAwIT09by5nKW49by5nO2Vsc2V7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGYpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0XCIpO249c2VsZn1yZXR1cm4gbn1mdW5jdGlvbiBhKG4sZSl7dmFyIG89cygpO3JldHVybiBvW25dfHwob1tuXT1lKSxvW25dfW8ucihpKSxvLmQoaSx7Z2V0UGl4ZWxzRnJvbVRleHR1cmVQb3M6KCk9PkgsZ2V0U2FtcGxlckNvZGU6KCk9PnosZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXg6KCk9PkcsZ2V0VmFsdWVGcm9tVGVuc29yUG9zOigpPT5OLGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmc6KCk9PlgsbW92ZVRleHR1cmUyUG9zVG9SZWFsOigpPT5XfSk7dmFyIHU9e29wUmVnaXN0cnk6e29wczp7fX0sYmFja2VuZDpcIlwiLGJhY2tlbmRJbnN0YW5jZTpudWxsfTt1PWEoXCJHTE9CQUxTXCIsdSk7dmFyIGw9cygpO2wuSW1hZ2VCaXRtYXB8fChsLkltYWdlQml0bWFwPWZ1bmN0aW9uKCl7fSk7Y29uc3QgZj1hKFwiZW52XCIsbmV3KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3RoaXMuRU5WPXt9fXJldHVybiBuLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obixlKXt0aGlzLkVOVltuXT1lfSxuLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuRU5WW25dfSxufSgpKSk7dmFyIGM7IWZ1bmN0aW9uKG4pe24udW5pZm9ybTFmPVwiMWZcIixuLnVuaWZvcm0xZnY9XCIxZnZcIixuLnVuaWZvcm0xaT1cIjFpXCIsbi51bmlmb3JtMWl2PVwiMWl2XCIsbi51bmlmb3JtMmY9XCIyZlwiLG4udW5pZm9ybTJmdj1cIjJmdlwiLG4udW5pZm9ybTJpPVwiMmlcIixuLnVuaWZvcm0yaXY9XCIyaXZcIixuLnVuaWZvcm0zZj1cIjNmXCIsbi51bmlmb3JtM2Z2PVwiM2Z2XCIsbi51bmlmb3JtM2k9XCIzaVwiLG4udW5pZm9ybTNpdj1cIjNpdlwiLG4udW5pZm9ybTRmPVwiNGZcIixuLnVuaWZvcm00ZnY9XCI0ZnZcIixuLnVuaWZvcm00aT1cIjRpXCIsbi51bmlmb3JtNGl2PVwiNGl2XCJ9KGN8fChjPXt9KSk7dmFyIF87ZnVuY3Rpb24gZyhuKXtmb3IodmFyIGU9bi5sZW5ndGgsbz1mdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCxvPWFyZ3VtZW50cy5sZW5ndGg7ZTxvO2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciB0PUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8bztlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKyl0W3JdPWlbc107cmV0dXJuIHR9KG4pLHQ9W107ZT4xOylvLnNwbGljZSgwLDEpLHQucHVzaChvLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSkpKSxlLS07cmV0dXJuIHR9ZnVuY3Rpb24gaChuLGUpe2lmKDE9PT1uLmxlbmd0aClyZXR1cm5cImZsb2F0IFwiK2UrXCIgPSBmbG9hdChcIituWzBdK1wiKTtcIjtmb3IodmFyIG89bi5sZW5ndGgsdD1cIlxcbiAgICAgICAgdmVjXCIrbytcIiBcIitlK1wiID0gdmVjXCIrbytcIihcXG4gICAgXCIscj0wO3I8bztyKyspdCs9XCJmbG9hdChcIituW3JdK1wiKSxcIjtyZXR1cm4gdC5zbGljZSgwLC0xKStcIik7XCJ9ZnVuY3Rpb24gZChuLGUsbyl7aWYoMD09PW4ubGVuZ3RoKXJldHVyblwiXCI7aWYoMj09PWYuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpKXJldHVybiBuLnJlZHVjZSgoZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlKyhyPG4ubGVuZ3RoLTE/bytcIihcIit0K1wiKSwgXCI6bytcIihcIit0K1wiKSk7XCIpfSksbytcIiBcIitlK1wiW10gPSBcIitvK1wiW10oXCIpO3ZhciB0PW4ucmVkdWNlKChmdW5jdGlvbihuLHQscil7cmV0dXJuIG4rXCJcXG4gICAgICAgICAgICBcIitlK1wiW1wiK3IrXCJdID0gXCIrbytcIihcIit0K1wiKTtcIn0pLFwiXCIpO3JldHVyblwiXFxuICAgICAgICBcIitvK1wiIFwiK2UrXCJbXCIrbi5sZW5ndGgrXCJdO1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICBcIn1mdW5jdGlvbiBwKG4sZSxvKXtpZigwPT09bi5sZW5ndGgpcmV0dXJuXCJcIjt2YXIgdD1uLnJlZHVjZSgoZnVuY3Rpb24obixlLHQpe3JldHVybiBuKygwPT09dD9cIlxcbiAgICAgICAgICAgIFwiK28rXCIgcmVzID0gXCIrbytcIigwKTtcXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gXCIrdCtcIikge1xcbiAgICAgICAgICAgICAgICByZXMgPSBhcnJbXCIrdCtcIl07XFxuICAgICAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gXCIrdCtcIikge1xcbiAgICAgICAgICAgICAgICByZXMgPSBhcnJbXCIrdCtcIl07XFxuICAgICAgICAgICAgfVwiKX0pLFwiXCIpO3JldHVyblwiXFxuICAgIFwiK28rXCIgZ2V0VmFsdWVGcm9tQXJyQnlJbmRleF9cIitlK1wiKFwiK28rXCJbXCIrbi5sZW5ndGgrXCJdIGFyciwgaW50IGluZGV4KSB7XFxuICAgICAgICBcIisoMj09PWYuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpP28rXCIgcmVzID0gYXJyW2luZGV4XTtcIjp0KStcIlxcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcbiAgICBcIn0hZnVuY3Rpb24obil7bi5JTlRfVFlQRT1cImludFwiLG4uRkxPQVRfVFlQRT1cImZsb2F0XCJ9KF98fChfPXt9KSk7dmFyIG0sUDshZnVuY3Rpb24obil7bltuLlZTX1NIQURFUj0wXT1cIlZTX1NIQURFUlwiLG5bbi5GU19TSEFERVI9MV09XCJGU19TSEFERVJcIn0obXx8KG09e30pKSxmdW5jdGlvbihuKXtuW24uRkxPQVRfVkVDMj0zNTY2NF09XCJGTE9BVF9WRUMyXCIsbltuLkZMT0FUX1ZFQzM9MzU2NjVdPVwiRkxPQVRfVkVDM1wiLG5bbi5GTE9BVF9WRUM0PTM1NjY2XT1cIkZMT0FUX1ZFQzRcIixuW24uSU5UX1ZFQzI9MzU2NjddPVwiSU5UX1ZFQzJcIixuW24uSU5UX1ZFQzM9MzU2NjhdPVwiSU5UX1ZFQzNcIixuW24uSU5UX1ZFQzQ9MzU2NjldPVwiSU5UX1ZFQzRcIixuW24uQk9PTD0zNTY3MF09XCJCT09MXCIsbltuLkJPT0xfVkVDMj0zNTY3MV09XCJCT09MX1ZFQzJcIixuW24uQk9PTF9WRUMzPTM1NjcyXT1cIkJPT0xfVkVDM1wiLG5bbi5CT09MX1ZFQzQ9MzU2NzNdPVwiQk9PTF9WRUM0XCIsbltuLkZMT0FUX01BVDI9MzU2NzRdPVwiRkxPQVRfTUFUMlwiLG5bbi5GTE9BVF9NQVQzPTM1Njc1XT1cIkZMT0FUX01BVDNcIixuW24uRkxPQVRfTUFUND0zNTY3Nl09XCJGTE9BVF9NQVQ0XCIsbltuLlNBTVBMRVJfMkQ9MzU2NzddPVwiU0FNUExFUl8yRFwiLG5bbi5TQU1QTEVSX0NVQkU9MzU2NzhdPVwiU0FNUExFUl9DVUJFXCIsbltuLkZMT0FUPTUxMjZdPVwiRkxPQVRcIixuW24uSU5UPTUxMjRdPVwiSU5UXCJ9KFB8fChQPXt9KSk7dmFyIHYseD1mdW5jdGlvbihuLGUsbyl7dGhpcy5zaXplPW4sdGhpcy50eXBlPWUsdGhpcy5sb2NhdGlvbj1vfSxUPWZ1bmN0aW9uKG4sZSxvKXt0aGlzLnNpemU9bix0aGlzLnR5cGU9ZSx0aGlzLmxvY2F0aW9uPW99LEY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKCl7fXJldHVybiBuLmdldFdlYmdsVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiBmLmdldChcIndlYmdsVmVyc2lvblwiKX0sbi5jcmVhdGVDYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gZi5nZXQoXCJjYW52YXNcIil8fGRvY3VtZW50JiZkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpfSxuLnNldFdlYmdsVmVyc2lvbj1mdW5jdGlvbihuKXtmLnNldChcIndlYmdsVmVyc2lvblwiLG4pfSxuLnNldFdlYkdMUmVuZGVyaW5nQ29udGV4dD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5nbD1uLG59LG4uZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2w/dGhpcy5nbDp0aGlzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCgpfSxuLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dD1mdW5jdGlvbigpe2lmKHRoaXMuZ2wpcmV0dXJuIHRoaXMuZ2w7dmFyIG49dGhpcy5jcmVhdGVDYW52YXMoKTtpZighbilyZXR1cm4gbnVsbDtuLmFkZEV2ZW50TGlzdGVuZXImJm4uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwoZnVuY3Rpb24obil7dGhyb3cgbi5wcmV2ZW50RGVmYXVsdCgpLEVycm9yKFwid2ViZ2wgY29udGV4dCBpcyBsb3N0flwiKX0pLCExKTt2YXIgZT1uLmdldENvbnRleHQoXCJ3ZWJnbDJcIix0aGlzLldFQkdMX0FUVFJJQlVURVMpO3JldHVybiBlP2Yuc2V0KFwid2ViZ2xWZXJzaW9uXCIsMik6KGYuc2V0KFwid2ViZ2xWZXJzaW9uXCIsMSksZT1uLmdldENvbnRleHQoXCJ3ZWJnbFwiLHRoaXMuV0VCR0xfQVRUUklCVVRFUyl8fG4uZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLHRoaXMuV0VCR0xfQVRUUklCVVRFUykpLGV9LG4ucHJpbnRTdGF0ZXM9ZnVuY3Rpb24obil7Y29uc29sZS5sb2coXCIxLiBpc0JsZW5kRW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5CTEVORCkpLGNvbnNvbGUubG9nKFwiMi4gaXNDdWxsRmFjZUVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uQ1VMTF9GQUNFKSksY29uc29sZS5sb2coXCIzLiBpc0RlcHRoVGVzdEVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uREVQVEhfVEVTVCkpLGNvbnNvbGUubG9nKFwiNC4gaXNEaXRoZXJFbmFibGUgPSBcIituLmlzRW5hYmxlZChuLkRJVEhFUikpLGNvbnNvbGUubG9nKFwiNS4gaXNQb2x5Z29uT2Zmc2V0RmlsbEVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uUE9MWUdPTl9PRkZTRVRfRklMTCkpLGNvbnNvbGUubG9nKFwiNi4gaXNTYW1wbGVBbHBodFRvQ292ZXJhZ2VFbmFibGUgPSBcIituLmlzRW5hYmxlZChuLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSkpLGNvbnNvbGUubG9nKFwiNy4gaXNTYW1wbGVDb3ZlcmFnZUVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uU0FNUExFX0NPVkVSQUdFKSksY29uc29sZS5sb2coXCI4LiBpc1NjaXNzb3JUZXN0RW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5TQ0lTU09SX1RFU1QpKSxjb25zb2xlLmxvZyhcIjkuIGlzU3RlbmNpbFRlc3RFbmFibGUgPSBcIituLmlzRW5hYmxlZChuLlNURU5DSUxfVEVTVCkpfSxuLnByaW50V2ViR0xJbmZvPWZ1bmN0aW9uKG4pe2NvbnNvbGUubG9nKFwicmVuZGVyZXIgPSBcIituLmdldFBhcmFtZXRlcihuLlJFTkRFUkVSKSksY29uc29sZS5sb2coXCJ2ZXJzaW9uID0gXCIrbi5nZXRQYXJhbWV0ZXIobi5WRVJTSU9OKSksY29uc29sZS5sb2coXCJ2ZW5kb3IgPSBcIituLmdldFBhcmFtZXRlcihuLlZFTkRPUikpLGNvbnNvbGUubG9nKFwiZ2xzbCB2ZXJzaW9uID0gXCIrbi5nZXRQYXJhbWV0ZXIobi5TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04pKX0sbi5wcmludFdlYkdMVGV4dHVyZUluZm89ZnVuY3Rpb24obil7Y29uc29sZS5sb2coXCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyA9IFwiLG4uZ2V0UGFyYW1ldGVyKG4uTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpKSxjb25zb2xlLmxvZyhcIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTID0gXCIsbi5nZXRQYXJhbWV0ZXIobi5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUykpLGNvbnNvbGUubG9nKFwiTUFYX1RFWFRVUkVfU0laRSA9IFwiLG4uZ2V0UGFyYW1ldGVyKG4uTUFYX1RFWFRVUkVfU0laRSkpLGNvbnNvbGUubG9nKFwiTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSA9IFwiLG4uZ2V0UGFyYW1ldGVyKG4uTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSkpfSxuLnRyaWdnZXJDb250ZXh0TG9zdEV2ZW50PWZ1bmN0aW9uKG4pe3ZhciBlPW4uZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO251bGwhPT1lJiZlLmxvc2VDb250ZXh0KCl9LG4uY2hlY2tHTEVycm9yPWZ1bmN0aW9uKG4pe3ZhciBlPW4uZ2V0RXJyb3IoKTtyZXR1cm4gMCE9PWUmJihjb25zb2xlLmxvZyhcIldlYkdMIEVycm9yIE5POiBcIixlKSwhMCl9LG4uc2V0RGVmYXVsdFN0YXRlPWZ1bmN0aW9uKG4pe24uY2xlYXJDb2xvcigwLDAsMCwwKSxuLmNsZWFyRGVwdGgoMSksbi5lbmFibGUobi5ERVBUSF9URVNUKSxuLmVuYWJsZShuLkNVTExfRkFDRSksbi5lbmFibGUobi5TQ0lTU09SX1RFU1QpfSxuLnNldFZpZXdwb3J0PWZ1bmN0aW9uKG4sZSl7bi52aWV3cG9ydChlWzBdLGVbMV0sZVsyXSxlWzNdKX0sbi5pbml0U2hhZGVyPWZ1bmN0aW9uKG4sZSxvKXt2YXIgdD10aGlzLmNyZWF0ZVNoYWRlcihuLGUpO3JldHVybiB0aGlzLmNvbXBpbGVTaGFkZXIobixvLHQpLHR9LG4uY3JlYXRlU2hhZGVyPWZ1bmN0aW9uKG4sZSl7dmFyIG87aWYobnVsbD09PShvPWU9PT1tLlZTX1NIQURFUj9uLmNyZWF0ZVNoYWRlcihuLlZFUlRFWF9TSEFERVIpOm4uY3JlYXRlU2hhZGVyKG4uRlJBR01FTlRfU0hBREVSKSkpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0xTaGFkZXLliJvlu7rlpLHotKXvvIFcIik7cmV0dXJuIG99LG4uY29tcGlsZVNoYWRlcj1mdW5jdGlvbihuLGUsbyl7cmV0dXJuIG4uc2hhZGVyU291cmNlKG8sZSksbi5jb21waWxlU2hhZGVyKG8pLCExIT09bi5nZXRTaGFkZXJQYXJhbWV0ZXIobyxuLkNPTVBJTEVfU1RBVFVTKXx8KGNvbnNvbGUuZXJyb3Iobi5nZXRTaGFkZXJJbmZvTG9nKG8pKSxuLmRlbGV0ZVNoYWRlcihvKSwhMSl9LG4uY3JlYXRlUHJvZ3JhbT1mdW5jdGlvbihuKXt2YXIgZT1uLmNyZWF0ZVByb2dyYW0oKTtpZihudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTFByb2dyYW3liJvlu7rlpLHotKXvvIFcIik7cmV0dXJuIGV9LG4ubGlua1Byb2dyYW09ZnVuY3Rpb24obixlLG8sdCxyLGkpe3JldHVybiB2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1pJiYoaT1udWxsKSxuLmF0dGFjaFNoYWRlcihlLG8pLG4uYXR0YWNoU2hhZGVyKGUsdCksbnVsbCE9PXImJnIobixlKSxuLmxpbmtQcm9ncmFtKGUpLCExPT09bi5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsbi5MSU5LX1NUQVRVUyk/KGNvbnNvbGUuZXJyb3Iobi5nZXRQcm9ncmFtSW5mb0xvZyhlKSksbi5kZWxldGVTaGFkZXIobyksbi5kZWxldGVTaGFkZXIodCksbi5kZWxldGVQcm9ncmFtKGUpLCExKToobi52YWxpZGF0ZVByb2dyYW0oZSksITE9PT1uLmdldFByb2dyYW1QYXJhbWV0ZXIoZSxuLlZBTElEQVRFX1NUQVRVUyk/KGNvbnNvbGUuZXJyb3Iobi5nZXRQcm9ncmFtSW5mb0xvZyhlKSksbi5kZWxldGVTaGFkZXIobyksbi5kZWxldGVTaGFkZXIodCksbi5kZWxldGVQcm9ncmFtKGUpLCExKToobnVsbCE9PWkmJmkobixlKSwhMCkpfSxuLmdldFByb2dyYW1BY3RpdmVBdHRyaWJzPWZ1bmN0aW9uKG4sZSxvKXtmb3IodmFyIHQ9bi5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsbi5BQ1RJVkVfQVRUUklCVVRFUykscj0wO3I8dDtyKyspe3ZhciBpPW4uZ2V0QWN0aXZlQXR0cmliKGUscik7aSYmKG9baS5uYW1lXT1uZXcgVChpLnNpemUsaS50eXBlLG4uZ2V0QXR0cmliTG9jYXRpb24oZSxpLm5hbWUpKSl9fSxuLmdldFByb2dyYW1BdGNpdmVVbmlmb3Jtcz1mdW5jdGlvbihuLGUsbyl7Zm9yKHZhciB0PW4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihlLG4uQUNUSVZFX1VOSUZPUk1TKSxyPTA7cjx0O3IrKyl7dmFyIGk9bi5nZXRBY3RpdmVVbmlmb3JtKGUscik7aWYoaSl7dmFyIHM9bi5nZXRVbmlmb3JtTG9jYXRpb24oZSxpLm5hbWUpO251bGwhPT1zJiYob1tpLm5hbWVdPW5ldyB4KGkuc2l6ZSxpLnR5cGUscykpfX19LG4uY3JlYXRlQnVmZmVyPWZ1bmN0aW9uKG4pe3ZhciBlPW4uY3JlYXRlQnVmZmVyKCk7aWYobnVsbD09PWUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0xCdWZmZXLliJvlu7rlpLHotKXvvIFcIik7cmV0dXJuIGV9LG4uZ2V0Q29sb3JCdWZmZXJEYXRhPWZ1bmN0aW9uKG4pe3ZhciBlPW5ldyBVaW50OEFycmF5KG4uZHJhd2luZ0J1ZmZlcldpZHRoKm4uZHJhd2luZ0J1ZmZlckhlaWdodCo0KTtyZXR1cm4gbi5yZWFkUGl4ZWxzKDAsMCxuLmRyYXdpbmdCdWZmZXJXaWR0aCxuLmRyYXdpbmdCdWZmZXJIZWlnaHQsbi5SR0JBLG4uVU5TSUdORURfQllURSxlKSxlfSxuLnNldFVuaWZvcm1QYXJhbT1mdW5jdGlvbihuLGUsbyx0KXtzd2l0Y2gobyl7Y2FzZSBjLnVuaWZvcm0xZjpuLnVuaWZvcm0xZihlLHQpO2JyZWFrO2Nhc2UgYy51bmlmb3JtMWZ2Om4udW5pZm9ybTFmdihlLHQpO2JyZWFrO2Nhc2UgYy51bmlmb3JtMWk6bi51bmlmb3JtMWkoZSx0KTticmVhaztjYXNlIGMudW5pZm9ybTFpdjpuLnVuaWZvcm0xaXYoZSx0KTticmVhaztjYXNlIGMudW5pZm9ybTJmOm4udW5pZm9ybTJmKGUsdFswXSx0WzFdKTticmVhaztjYXNlIGMudW5pZm9ybTJmdjpuLnVuaWZvcm0yZnYoZSx0KTticmVhaztjYXNlIGMudW5pZm9ybTJpOm4udW5pZm9ybTJpKGUsdFswXSx0WzFdKTticmVhaztjYXNlIGMudW5pZm9ybTJpdjpuLnVuaWZvcm0yaXYoZSx0KTticmVhaztjYXNlIGMudW5pZm9ybTNmOm4udW5pZm9ybTNmKGUsdFswXSx0WzFdLHRbMl0pO2JyZWFrO2Nhc2UgYy51bmlmb3JtM2Z2Om4udW5pZm9ybTNmdihlLHQpO2JyZWFrO2Nhc2UgYy51bmlmb3JtM2k6bi51bmlmb3JtM2koZSx0WzBdLHRbMV0sdFsyXSk7YnJlYWs7Y2FzZSBjLnVuaWZvcm0zaXY6bi51bmlmb3JtM2l2KGUsdCk7YnJlYWs7Y2FzZSBjLnVuaWZvcm00ZjpuLnVuaWZvcm00ZihlLHRbMF0sdFsxXSx0WzJdLHRbM10pO2JyZWFrO2Nhc2UgYy51bmlmb3JtNGZ2Om4udW5pZm9ybTRmdihlLHQpO2JyZWFrO2Nhc2UgYy51bmlmb3JtNGk6bi51bmlmb3JtNGkoZSx0WzBdLHRbMV0sdFsyXSx0WzNdKTticmVhaztjYXNlIGMudW5pZm9ybTRpdjpuLnVuaWZvcm00aXYoZSx0KTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJbXCIrbytcIl06IHVua25vd24gdW5pZm9ybSB0eXBlXCIpfX0sbi5nZW5UZXh0dXJlSW5mb0Zyb21UZW5zb3JTaGFwZT1mdW5jdGlvbihuLGUpe3ZhciBvPW58fDQwOTYsdD1lLnNoYXBlLHI9dm9pZCAwPT09dD9bXTp0LGk9clswXSxzPXJbMV0sYT1yWzJdLHU9clszXTtpZihpKmE8PW8mJnMqdTw9byllLnNoYXBlX3RleHR1cmU9W2kqYSxzKnVdO2Vsc2V7dmFyIGw9ZnVuY3Rpb24oKXtmb3IodmFyIG49MCxlPTAsbz1hcmd1bWVudHMubGVuZ3RoO2U8bztlKyspbis9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgdD1BcnJheShuKSxyPTA7Zm9yKGU9MDtlPG87ZSsrKWZvcih2YXIgaT1hcmd1bWVudHNbZV0scz0wLGE9aS5sZW5ndGg7czxhO3MrKyxyKyspdFtyXT1pW3NdO3JldHVybiB0fShyKS5zb3J0KChmdW5jdGlvbihuLGUpe3JldHVybiBuLWV9KSksYz1sWzBdLF89bFsxXSxnPWxbMl0saD1jKmxbM10sZD1fKmc7aWYoaD5vfHxkPm8pe3ZhciBwPVtoLGRdLnNvcnQoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4tZX0pKSxtPXBbMF0sUD1wWzFdLHY9ZnVuY3Rpb24obixlKXt2YXIgbz1lO2lmKG4lbz09MClyZXR1cm4gbztmb3IoO288biYmbiVvIT0wOylvKys7cmV0dXJuIG99KFAsTWF0aC5jZWlsKFAvbykpO2lmKGg9bSp2LGQ9TWF0aC5jZWlsKFAvdiksZi5nZXQoXCJkZWJ1Z1wiKSYmY29uc29sZS5lcnJvcihcIuWkp+Wwj+i2hemZkFwiLHIsW2QsaF0pLGg+b3x8ZD5vKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgW1wiK2grXCJ4XCIrZCtcIl0gZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVIFtcIitvK1wieFwiK28rXCJdLlwiKX1lLnNoYXBlX3RleHR1cmU9W2QsaF19fSxuLldFQkdMX0FUVFJJQlVURVM9e2FscGhhOiExLGFudGlhbGlhczohMSxwcmVtdWx0aXBsaWVkQWxwaGE6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGRlcHRoOiExLHN0ZW5jaWw6ITEsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDohMCxwb3dlclByZWZlcmVuY2U6XCJoaWdoLXBlcmZvcm1hbmNlXCJ9LG4uZ2w9bnVsbCxufSgpOyFmdW5jdGlvbihuKXtuW24uR0xfUkVQRUFUPTBdPVwiR0xfUkVQRUFUXCIsbltuLkdMX01JUlJPUkVEX1JFUEVBVD0xXT1cIkdMX01JUlJPUkVEX1JFUEVBVFwiLG5bbi5HTF9DTEFNUF9UT19FREdFPTJdPVwiR0xfQ0xBTVBfVE9fRURHRVwifSh2fHwodj17fSkpO3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe31yZXR1cm4gbi5nZXRUZXh0dXJlQ29uZmlnPWZ1bmN0aW9uKG4pe3ZhciBlLG8sdCxyLGkscyxhLHUsbD1uLGM9ITAsXz0hMDtyZXR1cm4gMj09PWYuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpPyhlPWwuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSx0PWwuSEFMRl9GTE9BVCxyPWwuUjMyRixpPWwuUkdCQTMyRixzPWwuUjE2RixhPWwuUkdCQTE2RixvPWwuUkVELHU9bC5SR0JBMzJGKToocj1sLlJHQkEscz1sLlJHQkEsYT1sLlJHQkEsaT1sLlJHQkEsbz1sLlJHQkEsdT1sLlJHQkEsZT1sLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpLHQ9bC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLkhBTEZfRkxPQVRfT0VTLGM9dGhpcy5pc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZChsLHUpLF89dGhpcy5pc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkTWV0aG9kKGwsMSxjKSkse3RleHR1cmVGbG9hdDplLHRleHR1cmVIYWxmRmxvYXQ6dCxpbnRlcm5hbEZvcm1hdDpyLGludGVybmFsRm9ybWF0UGFja2VkOmksaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ6cyxpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdDphLHRleHR1cmVGb3JtYXQ6byxkb3dubG9hZEludGVybmFsRm9ybWF0OnUsZnJhbWVCdWZmZXJTdXBwb3J0RmxvYXQ6Yyxpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkOl99fSxuLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWRNZXRob2Q9ZnVuY3Rpb24obixlLG8pe3ZhciB0PW47aWYoMD09PWUpcmV0dXJuITE7aWYoMT09PWUpe2lmKG51bGw9PXQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZihudWxsPT10LmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIil8fG51bGw9PXQuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKXJldHVybiExO3ZhciByPXQuY3JlYXRlRnJhbWVidWZmZXIoKSxpPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGkpO3ZhciBzPTI9PT1lP3QuUkdCQTMyRjp0LlJHQkE7dC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLHMsMSwxLDAsdC5SR0JBLG8/dC5GTE9BVDp0LmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIikuSEFMRl9GTE9BVF9PRVMsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixyKSx0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsaSwwKTt2YXIgYT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3QucmVhZFBpeGVscygwLDAsMSwxLHQuUkdCQSx0LkZMT0FULG5ldyBGbG9hdDMyQXJyYXkoNCkpO3ZhciB1PXQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1I7cmV0dXJuIGEmJnV9LG4uaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQ9ZnVuY3Rpb24obixlKXt2YXIgbz1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxvKSxuLnRleEltYWdlMkQobi5URVhUVVJFXzJELDAsZSwxLDEsMCxuLlJHQkEsbi5GTE9BVCxudWxsKTt2YXIgdD1uLmNyZWF0ZUZyYW1lYnVmZmVyKCk7bi5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUix0KSxuLmZyYW1lYnVmZmVyVGV4dHVyZTJEKG4uRlJBTUVCVUZGRVIsbi5DT0xPUl9BVFRBQ0hNRU5UMCxuLlRFWFRVUkVfMkQsbywwKTt2YXIgcj1uLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMobi5GUkFNRUJVRkZFUik9PT1uLkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiBuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxudWxsKSxuLmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLG51bGwpLG4uZGVsZXRlVGV4dHVyZShvKSxuLmRlbGV0ZUZyYW1lYnVmZmVyKHQpLHJ9LG4udXBsb2FkRGF0YVRvVGV4dHVyZT1mdW5jdGlvbihuLGUsbyx0KXtuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NQUdfRklMVEVSLG4uTkVBUkVTVCksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpO3ZhciByPW8ud2lkdGhfdGV4dHVyZSxpPW8uaGVpZ2h0X3RleHR1cmUscz1vLmRhdGEsYT1uLlJHQkEsdT1uLlJHQkEsbD1uLkZMT0FULGM9cztpZihzIGluc3RhbmNlb2YgVWludDhBcnJheXx8cyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KWw9bi5VTlNJR05FRF9CWVRFO2Vsc2V7aWYoIShzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHxzIGluc3RhbmNlb2YgQXJyYXkpKXJldHVybiB2b2lkIG4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxuLlJHQkEsbi5SR0JBLG4uVU5TSUdORURfQllURSxzKTtpZigyPT09Zi5nZXQoXCJ3ZWJnbFZlcnNpb25cIikpe3ZhciBfPWYuZ2V0KFwid2ViZ2xfZm9yY2VfaGFsZl9mbG9hdF90ZXh0dXJlXCIpO2E9dD9fP2UuaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ6ZS5pbnRlcm5hbEZvcm1hdFBhY2tlZDpfP2UuaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ6ZS5pbnRlcm5hbEZvcm1hdCx1PXQ/bi5SR0JBOmUudGV4dHVyZUZvcm1hdH1lbHNle2Zvcih2YXIgZz1uZXcgRmxvYXQzMkFycmF5KHIqaSo0KSxoPTA7aDxzLmxlbmd0aDtoKyspdD9nW2hdPXNbaF06KGdbNCpoXT1zW2hdLGdbNCpoKzFdPTAsZ1s0KmgrMl09MCxnWzQqaCszXT0wKTtjPWd9fW4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxhLHIsaSwwLHUsbCxjKX0sbi5nZW5PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKG4sZSxvLHQpe3ZhciByPW8uaW50ZXJwVHlwZSxpPW8ud2lkdGhfdGV4dHVyZSxzPW8uaGVpZ2h0X3RleHR1cmUsYT1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxhKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NQUdfRklMVEVSLFwiTElORUFSXCI9PT1yP24uTElORUFSOm4uTkVBUkVTVCksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixcIkxJTkVBUlwiPT09cj9uLkxJTkVBUjpuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpO3ZhciB1PWYuZ2V0KFwid2ViZ2xfZm9yY2VfaGFsZl9mbG9hdF90ZXh0dXJlXCIpLGw9dT9lLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0OmUuaW50ZXJuYWxGb3JtYXRQYWNrZWQsYz0yPT09Zi5nZXQoXCJ3ZWJnbFZlcnNpb25cIik/dT9uLkhBTEZfRkxPQVQ6bi5GTE9BVDplLmZyYW1lQnVmZmVyU3VwcG9ydEZsb2F0P24uRkxPQVQ6ZS50ZXh0dXJlSGFsZkZsb2F0LF89dD9lLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQ/YzpuLlVOU0lHTkVEX0JZVEU6bnVsbDtyZXR1cm4gbi50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLGwsaSxzLDAsbi5SR0JBLHQ/XzpjLG51bGwpLG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELG51bGwpLGF9LG59KCkseT1bXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbiAgICBhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG4gICAgdmFyeWluZyB2ZWMyIHZDb29yZDtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdkNvb3JkLnggPSAocG9zaXRpb24ueCArIDEuMCkgLyAyLjA7XFxuICAgICAgICB2Q29vcmQueSA9IChwb3NpdGlvbi55ICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuICAgIH1cXG4gICAgXCIsXCIjdmVyc2lvbiAzMDAgZXNcXG4gICAgaW4gdmVjNCBwb3NpdGlvbjtcXG4gICAgb3V0IHZlYzIgdkNvb3JkO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2Q29vcmQueCA9IChwb3NpdGlvbi54ICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIHZDb29yZC55ID0gKHBvc2l0aW9uLnkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgfVxcbiAgICBcIl0sRT1uZXcgRmxvYXQzMkFycmF5KFstMSwxLC0xLC0xLDEsMSwxLC0xXSksdz1bXCJsZW5ndGhfc2hhcGVcIixcImxlbmd0aF91bmZvcm1hdHRlZF9zaGFwZVwiLFwid2lkdGhfc2hhcGVcIixcImhlaWdodF9zaGFwZVwiLFwid2lkdGhfdGV4dHVyZVwiLFwiaGVpZ2h0X3RleHR1cmVcIixcIm9mZnNldF94XCIsXCJvZmZzZXRfeVwiLFwiY2hhbm5lbFwiLFwidG90YWxfc2hhcGVcIixcIm51bWJlcnNfc2hhcGVcIl0sVj17ZmxvYXQ6W1wibXVsdGlfdmFsdWVcIixcImJpYXNfdmFsdWVcIl0sYm9vbDpbXCJmdXNlX3JlbHVcIl19O2Z1bmN0aW9uIEEoKXtyZXR1cm5cIlxcbiAgICBcIisoZi5nZXQoXCJ1c2VNb2RBZGFwdG9yXCIpP1wiXFxuICAgICAgICAgICAgaW50IGNhbE1vZChpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgbW9kViA9IG1vZChmbG9hdChhKSwgZmxvYXQoYikpO1xcbiAgICAgICAgICAgICAgICBpZiAobW9kViA9PSBmbG9hdChiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbW9kViA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50KG1vZFYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgaW50IGNhbE1vZChpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBhIC8gYiAqIGI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIpK1wiXFxuICAgIFwiKyhmLmdldChcInVzZURpdmlzaW9uQWRhcHRvclwiKT9cIlxcbiAgICAgICAgICAgIGludCBjYWxEaXZpc2lvbihpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludChmbG9hdChhKSAvIChmbG9hdChiKSAtIDAuMDAwMSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgaW50IGNhbERpdmlzaW9uKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAvIGI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIpK1wiXFxuICAgIFxcbiAgICBmbG9hdCB0YW5oX2NhbGMoZmxvYXQgbnVtKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAoZXhwKDIuMCAqIG51bSkgLSAxLjApIC8gKGV4cCgyLjAgKiBudW0pICsgMS4wKTtcXG4gICAgICAgIHJldHVybiByZXM7XFxuICAgIH1cXG4gICAgXFxuICAgIFwifWNvbnN0IE89XCJcXG5pdmVjNCB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICBpbnQgc3VtVmFsLFxcbiAgICBjb25zdCBpbnQgY2hhbm5lbCxcXG4gICAgY29uc3QgaW50IHdpZHRoX3NoYXBlLFxcbiAgICBjb25zdCBpbnQgaGVpZ2h0X3NoYXBlLFxcbiAgICBjb25zdCBpbnQgdG90YWxfc2hhcGUpIHtcXG5cXG4gICAgaW50IG5fb3JpZ2luID0gaW50KHRvdGFsX3NoYXBlLyhjaGFubmVsICogd2lkdGhfc2hhcGUgKiBoZWlnaHRfc2hhcGUpKTtcXG4gICAgaW50IG5ld19hID0gY2FsTW9kKHN1bVZhbCwgd2lkdGhfc2hhcGUpO1xcbiAgICBzdW1WYWwgPSBpbnQoKHN1bVZhbCAtIG5ld19hKSAvIHdpZHRoX3NoYXBlKTtcXG4gICAgaW50IG5ld19iID0gY2FsTW9kKHN1bVZhbCwgaGVpZ2h0X3NoYXBlKTtcXG4gICAgc3VtVmFsID0gaW50KChzdW1WYWwgLSBuZXdfYikgLyBoZWlnaHRfc2hhcGUpO1xcbiAgICBpbnQgbmV3X2cgPSBjYWxNb2Qoc3VtVmFsLCBjaGFubmVsKTtcXG4gICAgc3VtVmFsID0gaW50KChzdW1WYWwgLSBuZXdfZykgLyBjaGFubmVsKTtcXG4gICAgaW50IG5ld19yID0gY2FsTW9kKHN1bVZhbCwgbl9vcmlnaW4pO1xcbiAgICByZXR1cm4gaXZlYzQobmV3X3IsbmV3X2csbmV3X2IsbmV3X2EpO1xcbn1cXG5cIjt2YXIgQz1cIlxcbmZsb2F0IHByZWx1KGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0geDtcXG4gICAgaWYgKHggPCAwLjApIHtcXG4gICAgICAgIHJlc3VsdCA9IHggKiBwO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxufVwiLFI9XCJcXG5mbG9hdCByZWx1NihmbG9hdCB4LCBmbG9hdCB0aHJlc2hvbGQsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gbWluKG1heCgwLjAsIHgpLCB0aHJlc2hvbGQpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cIixTPVwiXFxuZmxvYXQgbGVha3lSZWx1KGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gbWF4KHgsIHggKiBwKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XCIsST1cIlxcbmZsb2F0IHNjYWxlKGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gcCAqIHggKyBiO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cIixMPVwiXFxuZmxvYXQgc2NhbGVXaWR0aEJpYXMoZmxvYXQgeCwgZmxvYXQgcCwgZmxvYXQgYikge1xcbiAgICBmbG9hdCByZXN1bHQgPSBwICogKHggKyBiKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XCIsaz1cIlxcbmZsb2F0IHNpZ21vaWQoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgeikge1xcbiAgICBmbG9hdCByZXN1bHQgPSAxLjAgLyAoMS4wICsgZXhwKC14KSk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVwiLEI9XCJcXG4gICAgZmxvYXQgaGFyZFNpZ21vaWQoZmxvYXQgeCwgZmxvYXQgc2xvcGUsIGZsb2F0IG9mZnNldCkge1xcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gbWF4KDAuMCwgbWluKDEuMCwgc2xvcGUgKiB4ICsgb2Zmc2V0KSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXCIsTT1cIlxcbiAgICBmbG9hdCBzcXJ0KGZsb2F0IHgsIGZsb2F0IHNsb3BlLCBmbG9hdCBvZmZzZXQpIHtcXG4gICAgICAgIHJldHVybiBzcXJ0KHgpO1xcbiAgICB9XFxuXCIsRD1cIlxcbiAgICBmbG9hdCBwb3dfZnVuYyhmbG9hdCB4LCBmbG9hdCBmYWN0b3IsIGZsb2F0IG9mZnNldCkge1xcbiAgICAgICAgcmV0dXJuIHBvdyh4LCBmYWN0b3IpO1xcbiAgICB9XFxuXCIsVT1cIlxcbmZsb2F0IHRhbmhfZnVuYyhmbG9hdCB4LCBmbG9hdCB5LCBmbG9hdCB6KSB7XFxuICAgIHJldHVybiB0YW5oX2NhbGMoeCk7XFxufVwiLGo9XCJcXG5mbG9hdCBleHBfZnVuYyhmbG9hdCB4LCBmbG9hdCB5LCBmbG9hdCB6KSB7XFxuICAgIGZsb2F0IHJlc3VsdCA9IGV4cCh4KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XCI7ZnVuY3Rpb24gTihuLGUpe3ZhciBvPWUud2lkdGhfc2hhcGUsdD1lLmhlaWdodF9zaGFwZSxyPWUuY2hhbm5lbCxpPWUud2lkdGhfdGV4dHVyZTtyZXR1cm5cIlxcbiAgICBmbG9hdCBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfXCIrbitcIihpbnQgbiwgaW50IGMsIGludCBoLCBpbnQgdykge1xcbiAgICAgICAgaW50IGluZGV4ID0gbiAqIFwiK28qdCpyK1wiICsgYyAqIFwiK28qdCtcIiArIGggKiBcIitvK1wiICsgdztcXG4gICAgICAgIC8vIDAuMDEgaGFjazog5ZyoIFBDL1dJU0Ug5py65Zmo5LiK77yM5Ye6546w5p+Q5Liq5YC877yI5q+U5aaCIGluZGV4IOS4uiAzNTIw77yJIGZsb2F0KGluZGV4KSDlkowgZmxvYXQoMzUyMCkg6L+U5Zue5YC85LiN5ZCM55qE5oOF5Ya177yM55uu5YmNICswLjAxIGhhY2tcXG4gICAgICAgIGludCBwb3NfdyA9IGludChtb2QoZmxvYXQoaW5kZXgpICsgMC4wMSwgZmxvYXQoXCIraStcIikpKTtcXG4gICAgICAgIGludCBwb3NfaCA9IGluZGV4IC8gaW50KFwiK2krXCIpO1xcbiAgICAgICAgdmVjNCBwaXhlbHMgPSBURVhUVVJFMkQodGV4dHVyZV9cIituK1wiLFxcbiAgICAgICAgICAgIHZlYzIoXFxuICAgICAgICAgICAgICAgIChmbG9hdChwb3NfdykgICsgMC41KSAvIGZsb2F0KFwiK2krXCIpLFxcbiAgICAgICAgICAgICAgICAoZmxvYXQocG9zX2gpICsgMC41KSAvIGZsb2F0KFwiK2UuaGVpZ2h0X3RleHR1cmUrXCIpXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJldHVybiBwaXhlbHMucjtcXG4gICAgfVwifWZ1bmN0aW9uIFgobixlKXt2YXIgbz1lLmNoYW5uZWwsdD1lLmhlaWdodF9zaGFwZSxyPWUud2lkdGhfdGV4dHVyZSxpPWUuaGVpZ2h0X3RleHR1cmUscz1lLndpZHRoX3NoYXBlO3JldHVyblwiXFxuICAgIHZlYzQgZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19cIituK1wiKGludCBuLCBpbnQgYywgaW50IGgsIGludCB3KSB7XFxuICAgICAgICBpbnQgaW5kZXggPSBuICogXCIrcyp0Km8rXCIgKyBjICogXCIrcyp0K1wiICsgaCAqIFwiK3MrXCIgKyB3O1xcbiAgICAgICAgLy8gMC4wMSBoYWNrOiDlnKggUEMvV0lTRSDorr7lpIfkuIrvvIzlh7rnjrDmn5DkuKrlgLzvvIjmr5TlpoIgaW5kZXgg5Li6IDM1MjDvvIkgZmxvYXQoaW5kZXgpIOWSjCBmbG9hdCgzNTIwKSDov5Tlm57lgLzkuI3lkIznmoTmg4XlhrXvvIznm67liY0gKzAuMDEgaGFja1xcbiAgICAgICAgaW50IHBvc193ID0gaW50KG1vZChmbG9hdChpbmRleCkgKyAwLjAxLCBmbG9hdChcIityK1wiKSkpO1xcbiAgICAgICAgaW50IHBvc19oID0gaW5kZXggLyBpbnQoXCIrcitcIik7XFxuICAgICAgICB2ZWM0IHBpeGVscyA9IFRFWFRVUkUyRCh0ZXh0dXJlX1wiK24rXCIsXFxuICAgICAgICAgICAgdmVjMihcXG4gICAgICAgICAgICAgICAgKGZsb2F0KHBvc193KSAgKyAwLjUpIC8gZmxvYXQoXCIrcitcIiksXFxuICAgICAgICAgICAgICAgIChmbG9hdChwb3NfaCkgKyAwLjUpIC8gZmxvYXQoXCIraStcIilcXG4gICAgICAgICAgICApXFxuICAgICAgICApO1xcbiAgICAgICAgcmV0dXJuIHBpeGVscztcXG4gICAgfVwifWZ1bmN0aW9uIEcobixlKXt2YXIgbz1lLm51bWJlcnNfc2hhcGUsdD1lLmxlbmd0aF9zaGFwZTtpZigxPT09dClyZXR1cm5cIlxcbiAgICAgICAgICAgIGludCBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9cIituK1wiKGludCBuKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxNb2QobiwgXCIrb1swXStcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCI7Zm9yKHZhciByPVwiaXZlY1wiK3QrXCIoXCIrby5qb2luKFwiLCBcIikrXCIpXCIsaT1cInBvc1swXSA9IG4gLyBcIitvWzBdK1wiO1wiLHM9MTtzPHQ7cysrKWkrPVwiXFxuICAgICAgICAgICAgbiA9IGNhbE1vZChuLCBcIitvW3MtMV0rXCIpO1xcbiAgICAgICAgICAgIHBvc1tcIitzK1wiXSA9IGNhbERpdmlzaW9uKG4sIFwiK29bc10rXCIpO1xcbiAgICAgICAgXCI7cmV0dXJuXCJcXG4gICAgaXZlY1wiK3QrXCIgc2hhcGVWZWNfXCIrbitcIiA9IFwiK3IrXCI7XFxuICAgIGl2ZWNcIit0K1wiIGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X1wiK24rXCIoaW50IG4pIHtcXG4gICAgICAgIGl2ZWNcIit0K1wiIHBvcztcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIHJldHVybiBwb3M7XFxuICAgIH1cXG4gICAgXCJ9ZnVuY3Rpb24gSChuKXtyZXR1cm5cIlxcbiAgICAjZGVmaW5lIGdldFBpeGVsc0Zyb21UZXh0dXJlUG9zX1wiK24rXCIocG9zKSBURVhUVVJFMkQodGV4dHVyZV9cIituK1wiLCBwb3MpXFxuICAgIFwifWZ1bmN0aW9uIFcobixlKXtyZXR1cm5cIlxcbiAgICB2ZWMyIG1vdmVUZXh0dXJlMlBvc1RvUmVhbF9cIituK1wiKHZlYzIgdikge1xcbiAgICAgICAgdmVjMiB2MjtcXG4gICAgICAgIHYyLnggPSB2LnggKiBmbG9hdChcIitlLndpZHRoX3RleHR1cmUrXCIpO1xcbiAgICAgICAgdjIueSA9IHYueSAqIGZsb2F0KFwiK2UuaGVpZ2h0X3RleHR1cmUrXCIpO1xcbiAgICAgICAgcmV0dXJuIHYyO1xcbiAgICB9XFxuICAgIFwifWZ1bmN0aW9uIHoobil7cmV0dXJuXCJ1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlX1wiK24rXCI7XCJ9ZnVuY3Rpb24gWShuLGUsbyx0LHMpe3ZhciBhLHUsbD1cIlwiLGM9ZS5uYW1lLF89ZS5tYWluRnVuYyxnPWUudGV4dHVyZUZ1bmNDb25mLGg9dm9pZCAwPT09Zz97fTpnLGQ9ZS5jb21tb25GdW5jQ29uZjt0cnl7dmFyIHA9ZnVuY3Rpb24obixlLG8pe2Zvcih2YXIgdD17fSxyPU9iamVjdC5hc3NpZ24oe30sZSksaT1bXSxzPTAsYT1uO3M8YS5sZW5ndGg7cysrKXtmb3IodmFyIHU9YVtzXSxsPXUubmFtZSxmPXt9LGM9MCxfPXc7YzxfLmxlbmd0aDtjKyspdm9pZCAwIT09dVtQPV9bY11dJiYoZltQXT11W1BdKTt0W2xdPWYsaS5wdXNoKGwpfWZvcih2YXIgZz0wLGg9T2JqZWN0LmtleXMoVik7ZzxoLmxlbmd0aDtnKyspZm9yKHZhciBkPWhbZ10scD0wLG09VltkXTtwPG0ubGVuZ3RoO3ArKyl7dmFyIFA7dm9pZCAwIT09ZVtQPW1bcF1dJiYocltQXT1kK1wiKFwiK2VbUF0rXCIpXCIpfXJldHVybiBlLmFjdGl2ZV9mdW5jdGlvbiYmKHIuYWN0aXZlX2Z1bmN0aW9uPWUuYWN0aXZlX2Z1bmN0aW9uKSxyLnJ1bnRpbWU9byx7dGV4dHVyZVBhcmFtczp0LG9wUGFyYW1zOnIsYWN0aXZlX2Z1bmN0aW9uOmUuYWN0aXZlX2Z1bmN0aW9ufX0obyx0LHMpLG09cC50ZXh0dXJlUGFyYW1zLFA9cC5vcFBhcmFtcyx2PXAuYWN0aXZlX2Z1bmN0aW9uLHg9Mj09PWYuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpP1wiICN2ZXJzaW9uIDMwMCBlc1xcbiAgICAgICAgICAgICNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbiAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgICAgICAgI2Vsc2VcXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XFxuICAgICAgICAjZW5kaWYgICAgICBcXG4gICAgICAgIFwiOlwiICNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbiAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgICAgICAgI2Vsc2VcXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICAgXCIsVD1mdW5jdGlvbihuKXt2YXIgZT1uLmZyYW1lQnVmZmVyU3VwcG9ydEZsb2F0LG89bi5pc0ZpbmFsT3AsdD1uLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQ7cmV0dXJuIDI9PT1mLmdldChcIndlYmdsVmVyc2lvblwiKT9cIlxcbiAgICAgICAgLy8g6aG254K5c2hhZGVy6YCP5Lyg55qE5p2Q6LSo5Z2Q5qCHXFxuICAgICAgICBpbiB2ZWMyIHZDb29yZDtcXG4gICAgICAgIG91dCB2ZWM0IG91dENvbG9yO1xcbiAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgcmVzdWx0KSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVzZV9vcChyZXN1bHQpO1xcbiAgICAgICAgICAgIG91dENvbG9yLnIgPSByZXN1bHQ7XFxuICAgICAgICB9XFxuICAgICAgICB2b2lkIHNldFBhY2tlZE91dHB1dCh2ZWM0IHJlc3VsdCkge1xcbiAgICAgICAgICAgIG91dENvbG9yID0gcmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgICAgaW50IGNhbENlaWwoaW50IGEsIGludCBiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGludChjZWlsKGZsb2F0KGEpIC8gZmxvYXQoYikpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwiK0EoKStcIlxcbiAgICBcIjplP1wiXFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZDb29yZDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgb3V0Q29sb3I7XFxuICAgICAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1c2Vfb3AocmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLnIgPSByZXN1bHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZvaWQgc2V0UGFja2VkT3V0cHV0KHZlYzQgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGNhbENlaWwoaW50IGEsIGludCBiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnQoY2VpbChmbG9hdChhKSAvIGZsb2F0KGIpKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwiK0EoKStcIlxcbiAgICBcIjpvJiYhdD9cIlxcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZDb29yZDtcXG4gICAgICAgIHZhcnlpbmcgdmVjNCBvdXRDb2xvcjtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XFxuICAgICAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcXG4gICAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMS4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK0EoKStcIlxcblxcbiAgICAgICAgaW50IGNhbENlaWwoaW50IGEsIGludCBiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGludChjZWlsKGZsb2F0KGEpIC8gZmxvYXQoYikpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxvd3AgdmVjNCBlbmNvZGVfZmxvYXQoaGlnaHAgZmxvYXQgdikge1xcbiAgICAgICAgICAgIGlmIChpc25hbih2KSkge1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgICAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XFxuICAgICAgICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICAgICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgICAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgICAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgICAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICAgICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICAgICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgICAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdXNlX29wKHJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGVuY29kZV9mbG9hdChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgICAgICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMS4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZDb29yZDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgb3V0Q29sb3I7XFxuICAgICAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1c2Vfb3AocmVzdWx0KTtcXG4gICAgICAgICAgICAgICAgaWYoaXNuYW4ocmVzdWx0KSkge1xcbiAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLnIgPSAwLjA7XFxuICAgICAgICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5yID0gcmVzdWx0O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZvaWQgc2V0UGFja2VkT3V0cHV0KHZlYzQgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIrQSgpK1wiXFxuXFxuICAgICAgICAgICAgaW50IGNhbENlaWwoaW50IGEsIGludCBiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnQoY2VpbChmbG9hdChhKSAvIGZsb2F0KGIpKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCJ9KG4pLEY9ZnVuY3Rpb24obil7dmFyIGU9XCJcIixvPVwiXCI7aWYobi5mdXNlX29wdClmb3IodmFyIHQgaW4gbi5mdXNlX29wdCl7dmFyIGk9dCxzPTAsYT0wO3N3aXRjaCh0KXtjYXNlXCJzY2FsZVwiOnZhciB1PW4uZnVzZV9vcHQuc2NhbGUuYmlhc19hZnRlcl9zY2FsZTtzPXZvaWQgMCE9PShmPW4uZnVzZV9vcHQuc2NhbGUuc2NhbGUpP2Y6MSxhPW4uZnVzZV9vcHQuc2NhbGUuYmlhc3x8MCwhMT09PXUmJnZvaWQgMCE9PXUmJihpPVwic2NhbGVXaWR0aEJpYXNcIik7YnJlYWs7Y2FzZVwicmVsdVwiOmk9XCJwcmVsdVwiO2JyZWFrO2Nhc2VcInJlbHU2XCI6cz1uLmZ1c2Vfb3B0W3RdLnRocmVzaG9sZDticmVhaztjYXNlXCJoYXJkX3NpZ21vaWRcIjppPVwiaGFyZFNpZ21vaWRcIixzPW4uZnVzZV9vcHRbdF0uc2xvcGV8fC4yLGE9bi5mdXNlX29wdFt0XS5vZmZzZXR8fC41O2JyZWFrO2Nhc2VcImxlYWt5UmVsdVwiOnM9bi5mdXNlX29wdFt0XS5hbHBoYTticmVhaztjYXNlXCJwb3dcIjppPVwicG93X2Z1bmNcIixzPW4uZnVzZV9vcHRbdF0uZmFjdG9yfHwyO2JyZWFrO2Nhc2VcInRhbmhcIjppPVwidGFuaF9mdW5jXCI7YnJlYWs7Y2FzZVwiZXhwXCI6aT1cImV4cF9mdW5jXCJ9aWYoXCJoYXJkX3N3aXNoXCI9PT10KXt2YXIgbD12b2lkIDAhPT1uLmZ1c2Vfb3B0LmhhcmRfc3dpc2gub2Zmc2V0P24uZnVzZV9vcHQuaGFyZF9zd2lzaC5vZmZzZXQ6MyxmPXZvaWQgMCE9PW4uZnVzZV9vcHQuaGFyZF9zd2lzaC5zY2FsZT9uLmZ1c2Vfb3B0LmhhcmRfc3dpc2guc2NhbGU6NjtvKz1cInJlcyA9IHJlcyAqIG1pbihtYXgoMC4wLCByZXMgKyBmbG9hdChcIitsK1wiKSksIGZsb2F0KFwiKyh2b2lkIDAhPT1uLmZ1c2Vfb3B0LmhhcmRfc3dpc2gudGhyZXNob2xkP24uZnVzZV9vcHQuaGFyZF9zd2lzaC50aHJlc2hvbGQ6NikrXCIpKSAvIGZsb2F0KFwiK2YrXCIpO1wifWVsc2VcImRyb3BvdXRcIj09PXQ/bys9XCJcXG4gICAgICAgICAgICAgICAgaWYgKFwiKyhcImRvd25ncmFkZV9pbl9pbmZlclwiPT09bi5mdXNlX29wdC5kcm9wb3V0LmRyb3BvdXRfaW1wbGVtZW50YXRpb24pK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMgKiAoMS4wIC0gZmxvYXQoXCIrbi5mdXNlX29wdC5kcm9wb3V0LmRyb3BvdXRfcHJvYitcIikpO1xcbiAgICAgICAgICAgICAgICB9XCI6KGUrPXJbaV0sbys9XCJyZXMgPSBcIitpK1wiKHJlcywgZmxvYXQoXCIrcytcIiksIGZsb2F0KFwiK2ErXCIpKTtcIil9cmV0dXJuXCJcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICAgIFxcbiAgICAgICAgZmxvYXQgZnVzZV9vcChmbG9hdCB4KSB7XFxuICAgICAgICAgICAgZmxvYXQgcmVzID0geDtcXG4gICAgICAgICAgICBcIitvK1wiXFxuICAgICAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgICAgIH1cXG4gICAgXCJ9KFApLGI9ZnVuY3Rpb24obixlLG8sdCl7aWYoIW4pcmV0dXJuXCJcIjt2YXIgcj1PYmplY3QuYXNzaWduKHt9LG4pO3JbXCJAYWxsXCJdJiZmdW5jdGlvbihuLGUpe3ZhciBvPWUuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm5cIm91dFwiIT09bi5uYW1lfSkpLHQ9bltcIkBhbGxcIl07by5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbz1lLm5hbWU7bltvXT9uW29dLmNvbmNhdCh0KTpuW29dPXR9KSksZGVsZXRlIG5bXCJAYWxsXCJdfShyLHQpO2Zvcih2YXIgcz1cIlwiLGE9XCJcIix1PTAsbD1PYmplY3Qua2V5cyhyKTt1PGwubGVuZ3RoO3UrKyl7dmFyIGY9bFt1XTtpZihlW2ZdKXthKz16KGYpO2Zvcih2YXIgYz0wLF89cltmXTtjPF8ubGVuZ3RoO2MrKyl7dmFyIGc9X1tjXTtpZihpW2ddKXRyeXtzKz1pW2ddKGYsZVtmXSxvKX1jYXRjaChuKXtjb25zb2xlLmVycm9yKG4pfX19fXJldHVyblwiXFxuICAgIFwiK2ErXCJcXG4gICAgXCIrcytcIlxcbiAgICBcIn0oaCxtLFAsbykseT1mdW5jdGlvbihuKXtyZXR1cm4gdm9pZCAwPT09bj9cIlwiOlwiXFxuICAgICAgICBpbnQgbGF5ZXJfcnVuX3RpbWUgPSBcIituK1wiO1xcbiAgICBcIn0ocyksRT1mdW5jdGlvbihuKXt2YXIgZSxvLHQscixpO3JldHVyblwiXFxuICAgICAgICBcXG4gICAgdmVjMiBfMmRfc2hhcGVfdGV4dHVyZV9vdXQgPSB2ZWMyKGZsb2F0KFwiK24ud2lkdGhfdGV4dHVyZStcIiksIGZsb2F0KFwiK24uaGVpZ2h0X3RleHR1cmUrXCIpKTtcXG4gICAgXFxuICAgICAgICBcIisobz0oZT1uKS5oZWlnaHRfc2hhcGUsdD1lLndpZHRoX3NoYXBlLFwiXFxuICAgIGl2ZWM0IGdldE91dHB1dFRlbnNvclBvcygpIHtcXG4gICAgICAgIHZlYzIgb3V0Q29vcmQgPSB2Q29vcmQueHkgKiAoXzJkX3NoYXBlX3RleHR1cmVfb3V0KTtcXG4gICAgICAgIGludCBpbmRleCA9IGludChvdXRDb29yZC54KSArIGludChvdXRDb29yZC55KSAqIGludChcIitlLndpZHRoX3RleHR1cmUrXCIpO1xcblxcbiAgICAgICAgaW50IG4xID0gaW50KGluZGV4IC8gXCIrKHI9dCpvKmUuY2hhbm5lbCkrXCIpO1xcbiAgICAgICAgaW50IGMxID0gaW50KGNhbE1vZChpbmRleCwgXCIrcitcIikgLyBcIisoaT10Km8pK1wiKTtcXG4gICAgICAgIGludCBoMSA9IGludChjYWxNb2QoaW5kZXgsIFwiK2krXCIpIC8gXCIrdCtcIik7XFxuICAgICAgICBpbnQgdzEgPSBjYWxNb2QoaW5kZXgsIFwiK3QrXCIpO1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KG4xLCBjMSwgaDEsIHcxKTtcXG4gICAgfVxcbiAgICBcXG4gICAgXCIpfShtLm91dCksTz1mdW5jdGlvbihuKXtpZighbilyZXR1cm5cIlwiO2Zvcih2YXIgZT1cIlwiLG89MCx0PW47bzx0Lmxlbmd0aDtvKyspe3ZhciBpPXRbb107cltpXSYmKGUrPXJbaV0pfXJldHVybiBlfShkKTthPWw9XCIgXCIreCtcIlxcbiAgICAgICAgICAgIFwiK0YrXCJcXG4gICAgICAgICAgICBcIitUK1wiXFxuICAgICAgICAgICAgXCIrTytcIlxcbiAgICAgICAgICAgIFwiKyh2P3Jbdl06XCJcIikrXCJcXG4gICAgICAgICAgICBcIitiK1wiXFxuICAgICAgICAgICAgXCIreStcIlxcbiAgICAgICAgICAgIFwiK0UrXCJcXG4gICAgICAgICAgICBcIitfKG0sUCkrXCJcXG4gICAgICAgIFwiLHU9MT09PWYuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpP1widGV4dHVyZTJEXCI6XCJ0ZXh0dXJlXCIsbD1hLnJlcGxhY2UoL1xcYlRFWFRVUkUyRFxcYi9nLHUpfWNhdGNoKG4pe2NvbnNvbGUuZXJyb3IoXCJbXCIrYytcIl06IFwiK24pfXJldHVybiBsfWNvbnN0IHE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4sZSxvLHQpe3ZhciByPW47dGhpcy52U2hhZGVyPWU7dHJ5e3RoaXMuZlNoYWRlcj10aGlzLmluaXRTaGFkZXIocixvLFwiZnJhZ21lbnRcIiksdGhpcy5zaGFwZT10JiZ0LnNoYXBlO3ZhciBpPXRoaXMucHJvZ3JhbT1yLmNyZWF0ZVByb2dyYW0oKTtyLmF0dGFjaFNoYWRlcihpLHRoaXMudlNoYWRlciksci5hdHRhY2hTaGFkZXIoaSx0aGlzLmZTaGFkZXIpLHIubGlua1Byb2dyYW0oaSl9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKG4pfX1yZXR1cm4gbi5wcm90b3R5cGUuaW5pdFNoYWRlcj1mdW5jdGlvbihuLGUsbyl7dm9pZCAwPT09byYmKG89XCJ2ZXJ0ZXhcIik7dmFyIHQscj1cInZlcnRleFwiPT09bz9uLlZFUlRFWF9TSEFERVI6bi5GUkFHTUVOVF9TSEFERVI7aWYoXCJ2ZXJ0ZXhcIj09PW8mJnRoaXMudlNoYWRlcil0PXRoaXMudlNoYWRlcjtlbHNlIGlmKHQ9bi5jcmVhdGVTaGFkZXIociksXCJ2ZXJ0ZXhcIj09PW8mJih0aGlzLnZTaGFkZXI9dCksbi5zaGFkZXJTb3VyY2UodCxlKSxuLmNvbXBpbGVTaGFkZXIodCksIW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHQsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKFwiY29tcGlsZTogXCIrbi5nZXRTaGFkZXJJbmZvTG9nKHQpKTtyZXR1cm4gdH0sbi5wcm90b3R5cGUuc2V0UHJvZ3JhbT1mdW5jdGlvbihuLGUsbyl7bi51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSksb3x8dGhpcy5ydW5WZXJ0ZXhTaGFkZXIobixlKX0sbi5wcm90b3R5cGUucnVuVmVydGV4U2hhZGVyPWZ1bmN0aW9uKG4sZSl7dmFyIG89bi5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sXCJwb3NpdGlvblwiKTtuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG8pLG4uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUixlKSxuLnZlcnRleEF0dHJpYlBvaW50ZXIobywyLG4uRkxPQVQsITEsMCwwKX0sbi5TYW1wbGVyPVwidVNhbXBsZXJcIixufSgpO3ZhciBaLEs9KFo9ZnVuY3Rpb24obixlKXtyZXR1cm4oWj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixlKXtuLl9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24obixlKXtmb3IodmFyIG8gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmKG5bb109ZVtvXSl9KShuLGUpfSxmdW5jdGlvbihuLGUpe2Z1bmN0aW9uIG8oKXt0aGlzLmNvbnN0cnVjdG9yPW59WihuLGUpLG4ucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG8ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBvKX0pLFE9ZnVuY3Rpb24obixlLG8sdCl7cmV0dXJuIG5ldyhvfHwobz1Qcm9taXNlKSkoKGZ1bmN0aW9uKHIsaSl7ZnVuY3Rpb24gcyhuKXt0cnl7dSh0Lm5leHQobikpfWNhdGNoKG4pe2kobil9fWZ1bmN0aW9uIGEobil7dHJ5e3UodC50aHJvdyhuKSl9Y2F0Y2gobil7aShuKX19ZnVuY3Rpb24gdShuKXt2YXIgZTtuLmRvbmU/cihuLnZhbHVlKTooZT1uLnZhbHVlLGUgaW5zdGFuY2VvZiBvP2U6bmV3IG8oKGZ1bmN0aW9uKG4pe24oZSl9KSkpLnRoZW4ocyxhKX11KCh0PXQuYXBwbHkobixlfHxbXSkpLm5leHQoKSl9KSl9LEo9ZnVuY3Rpb24obixlKXt2YXIgbyx0LHIsaSxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnJbMF0pdGhyb3cgclsxXTtyZXR1cm4gclsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBpPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoaVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxpO2Z1bmN0aW9uIGEoaSl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihpKXtpZihvKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKG89MSx0JiYocj0yJmlbMF0/dC5yZXR1cm46aVswXT90LnRocm93fHwoKHI9dC5yZXR1cm4pJiZyLmNhbGwodCksMCk6dC5uZXh0KSYmIShyPXIuY2FsbCh0LGlbMV0pKS5kb25lKXJldHVybiByO3N3aXRjaCh0PTAsciYmKGk9WzImaVswXSxyLnZhbHVlXSksaVswXSl7Y2FzZSAwOmNhc2UgMTpyPWk7YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOmlbMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyx0PWlbMV0saT1bMF07Y29udGludWU7Y2FzZSA3Omk9cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoISgocj0ocj1zLnRyeXMpLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdKXx8NiE9PWlbMF0mJjIhPT1pWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1pWzBdJiYoIXJ8fGlbMV0+clswXSYmaVsxXTxyWzNdKSl7cy5sYWJlbD1pWzFdO2JyZWFrfWlmKDY9PT1pWzBdJiZzLmxhYmVsPHJbMV0pe3MubGFiZWw9clsxXSxyPWk7YnJlYWt9aWYociYmcy5sYWJlbDxyWzJdKXtzLmxhYmVsPXJbMl0scy5vcHMucHVzaChpKTticmVha31yWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9aT1lLmNhbGwobixzKX1jYXRjaChuKXtpPVs2LG5dLHQ9MH1maW5hbGx5e289cj0wfWlmKDUmaVswXSl0aHJvdyBpWzFdO3JldHVybnt2YWx1ZTppWzBdP2lbMV06dm9pZCAwLGRvbmU6ITB9fShbaSxhXSl9fX07Y29uc3QgJD1mdW5jdGlvbihuKXtmdW5jdGlvbiBlKCl7dmFyIGU9bi5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBlLmNhY2hlVGV4dHVyZXM9e30sZS51bmlmb3JtTG9jYXRpb25zPXt9LGUudGV4dHVyZXNNYXA9e30sZS5xdWVyeUxpc3Q9W10sZS5jdXJyZW50VGV4dHVyZT1udWxsLGUud2lkdGhfc2hhcGVfb3V0PTEsZS5oZWlnaHRfc2hhcGVfb3V0PTEsZS53aWR0aF90ZXh0dXJlX291dD0xLGUuaGVpZ2h0X3RleHR1cmVfb3V0PTEsZS5jaGFubmVsPTAsZS50b3RhbF9zaGFwZT0wLGV9cmV0dXJuIEsoZSxuKSxlLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7cmV0dXJuIFEodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuO3JldHVybiBKKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVybiBuPXRoaXMuZ2w9Ri5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoKSx0aGlzLmdsPyh0aGlzLmdsVmVyc2lvbj1GLmdldFdlYmdsVmVyc2lvbigpLHRoaXMudGV4dHVyZUNvbmY9Yi5nZXRUZXh0dXJlQ29uZmlnKG4pLHRoaXMuTUFYX1RFWFRVUkVfU0laRT1mLmdldChcIk1BWF9URVhUVVJFX1NJWkVcIil8fG4uZ2V0UGFyYW1ldGVyKG4uTUFYX1RFWFRVUkVfU0laRSksbi5kaXNhYmxlKG4uREVQVEhfVEVTVCksbi5kaXNhYmxlKG4uU1RFTkNJTF9URVNUKSxuLmRpc2FibGUobi5CTEVORCksbi5kaXNhYmxlKG4uRElUSEVSKSxuLmRpc2FibGUobi5QT0xZR09OX09GRlNFVF9GSUxMKSxuLmRpc2FibGUobi5TQU1QTEVfQ09WRVJBR0UpLG4uZW5hYmxlKG4uU0NJU1NPUl9URVNUKSxuLmVuYWJsZShuLkNVTExfRkFDRSksbi5jdWxsRmFjZShuLkJBQ0spLHRoaXMudmVydGV4QnVmZmVyPW4uY3JlYXRlQnVmZmVyKCksbi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLHRoaXMudmVydGV4QnVmZmVyKSxuLmJ1ZmZlckRhdGEobi5BUlJBWV9CVUZGRVIsRSxuLlNUQVRJQ19EUkFXKSx0aGlzLnZTaGFkZXI9Ri5pbml0U2hhZGVyKG4sbS5WU19TSEFERVIseVt0aGlzLmdsVmVyc2lvbi0xXSksdGhpcy5mcmFtZUJ1ZmZlcj1uLmNyZWF0ZUZyYW1lYnVmZmVyKCksbi5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUix0aGlzLmZyYW1lQnVmZmVyKSx0aGlzLnBibz1uLmNyZWF0ZUJ1ZmZlcigpLFsyXSk6WzJdfSkpfSkpfSxlLnByb3RvdHlwZS5jcmVhdGVQcm9ncmFtPWZ1bmN0aW9uKG4pe3ZhciBlPXRoaXMsbz1uLm9wLHQ9bi5vdXRUZW5zb3Iscj1uLmlucHV0VGVuc29ycyxpPW4uc2hhZGVyUGFyYW1zLHM9bi5ydW50aW1lLGE9bi5pc0ZpbmFsT3AsdT1udWxsO3RyeXt2YXIgbD1mdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCxvPWFyZ3VtZW50cy5sZW5ndGg7ZTxvO2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciB0PUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8bztlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKyl0W3JdPWlbc107cmV0dXJuIHR9KFt0XSxyKTtsLmZvckVhY2goKGZ1bmN0aW9uKG4pe3JldHVybiBGLmdlblRleHR1cmVJbmZvRnJvbVRlbnNvclNoYXBlKGUuTUFYX1RFWFRVUkVfU0laRSxuKX0pKTt2YXIgZj1ZKHRoaXMudGV4dHVyZUNvbmYsbyxsLGkscyk7KHU9bmV3IHEodGhpcy5nbCx0aGlzLnZTaGFkZXIsZix0KSkuZnNDb2RlPWY7dmFyIGM9Yi5nZW5PdXRwdXRUZXh0dXJlKHRoaXMuZ2wsdGhpcy50ZXh0dXJlQ29uZix0LGEpO3RoaXMudGV4dHVyZXNNYXBbdC50ZW5zb3JJZF09Yyx0aGlzLnByb2dyYW09dX1jYXRjaChuKXtjb25zb2xlLmVycm9yKFwid2ViZ2wgY3JlYXRlUHJvZ3JhbTogXCIrby5uYW1lK1wiIC0tIFwiK24pfXJldHVybiB1fSxlLnByb3RvdHlwZS5ydW5Qcm9ncmFtPWZ1bmN0aW9uKG4sZSl7dmFyIG89dGhpcyx0PWZ1bmN0aW9uKG4sZSl7aWYoMj09PWUmJmYuZ2V0KFwicGVyZm9ybWFuY2VcIikpe3ZhciBvPW4uZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKTtpZighbylyZXR1cm47dmFyIHQ9bi5jcmVhdGVRdWVyeSgpO3JldHVybiBuLmJlZ2luUXVlcnkoby5USU1FX0VMQVBTRURfRVhULHQpLHR9cmV0dXJuIG51bGx9KHRoaXMuZ2wsdGhpcy5nbFZlcnNpb24pLHI9bi5pc1BhY2tlZE9wO24ucHJvZ3JhbS5mb3JFYWNoKChmdW5jdGlvbih0LGkpe3ZhciBzPW4ub3V0cHV0VGVuc29yc1tpXSxhPXMudGVuc29ySWQ7by5zZXRPdXRQcm9wcyhzKSxcImZyYW1lQnVmZmVyXCI9PT1uLmJ1ZmZlclR5cGU/by5hdHRhY2hGcmFtZUJ1ZmZlcihhKTpvLmF0dGFjaENvbG9yQnVmZmVyKCksdC5zZXRQcm9ncmFtKG8uZ2wsby52ZXJ0ZXhCdWZmZXIsZSksby5wcm9ncmFtPXQsby5yZW5kZXIobixlLGkscil9KSksbi50ZW5zb3JEYXRhPW51bGwsdCYmKHRoaXMucXVlcnlMaXN0LnB1c2goe25hbWU6bi5uYW1lLHF1ZXJ5OnQsY291bnQ6MX0pLHQ9ZnVuY3Rpb24obixlLG8pe2lmKDI9PT1lJiZmLmdldChcInBlcmZvcm1hbmNlXCIpKXt2YXIgdD1uLmdldEV4dGVuc2lvbihcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIik7aWYoIXQpcmV0dXJuO24uZW5kUXVlcnkodC5USU1FX0VMQVBTRURfRVhUKX1yZXR1cm4gb30odGhpcy5nbCx0aGlzLmdsVmVyc2lvbix0KSl9LGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24obil7cmV0dXJuIFEodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG8sdDtyZXR1cm4gSih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBmLmdldChcIndlYmdsX2dwdV9waXBlbGluZVwiKT8oZT10aGlzLmdsLHRoaXMuZnJhbWVCdWZmZXI9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsdGhpcy5mcmFtZUJ1ZmZlciksWzIsW11dKToobz10aGlzLmNyZWF0ZVBCTygpLFs0LHRoaXMuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldKTtjYXNlIDE6cmV0dXJuIHIuc2VudCgpLHQ9bj9uLnNoYXBlOltdLFsyLHRoaXMuZG93bmxvYWRGbG9hdDMyVGVuc29yRnJvbUJ1ZmZlcihvLHQpXX19KSl9KSl9LGUucHJvdG90eXBlLmNyZWF0ZVBCTz1mdW5jdGlvbigpe3ZhciBuLGU9dGhpcy50ZXh0dXJlQ29uZjtpZigyPT09dGhpcy5nbFZlcnNpb24pe3ZhciBvPXRoaXMuZ2wsdD10aGlzLnBibztvLmJpbmRCdWZmZXIoby5QSVhFTF9QQUNLX0JVRkZFUix0KTt2YXIgcj0xNip0aGlzLndpZHRoX3RleHR1cmVfb3V0KnRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0O3JldHVybiBvLmJ1ZmZlckRhdGEoby5QSVhFTF9QQUNLX0JVRkZFUixyLG8uU1RSRUFNX1JFQUQpLG8ucmVhZFBpeGVscygwLDAsdGhpcy53aWR0aF90ZXh0dXJlX291dCx0aGlzLmhlaWdodF90ZXh0dXJlX291dCxvLlJHQkEsby5GTE9BVCwwKSxvLmJpbmRCdWZmZXIoby5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSx0fXZhciBpPXRoaXMuZ2wscz1pLkZMT0FUO3JldHVybiBlLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQ/bj1uZXcgRmxvYXQzMkFycmF5KHRoaXMud2lkdGhfdGV4dHVyZV9vdXQqdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQqNCk6KG49bmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aF90ZXh0dXJlX291dCp0aGlzLmhlaWdodF90ZXh0dXJlX291dCo0KSxzPWkuVU5TSUdORURfQllURSksaS5yZWFkUGl4ZWxzKDAsMCx0aGlzLndpZHRoX3RleHR1cmVfb3V0LHRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0LGkuUkdCQSxzLG4pLGUuaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZD9uOm5ldyBGbG9hdDMyQXJyYXkobi5idWZmZXIpfSxlLnByb3RvdHlwZS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gUSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sZSxvLHQscj10aGlzO3JldHVybiBKKHRoaXMsKGZ1bmN0aW9uKGkpe3JldHVybiBuPXRoaXMuZ2wsZT1udWxsIT1uLmZlbmNlU3luYyxvPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGUmJih0PW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCksbi5mbHVzaCgpLG89ZnVuY3Rpb24oKXt2YXIgZT1uLmNsaWVudFdhaXRTeW5jKHQsMCwwKTtyZXR1cm4gZT09PW4uQUxSRUFEWV9TSUdOQUxFRHx8ZT09PW4uQ09ORElUSU9OX1NBVElTRklFRH0pLFsyLG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtyLnBvbGxJdGVtKG8sbil9KSldfSkpfSkpfSxlLnByb3RvdHlwZS5wb2xsSXRlbT1mdW5jdGlvbihuLGUpe3ZhciBvPWZ1bmN0aW9uKCl7bigpP2UoKTpzZXRUaW1lb3V0KG8sMSl9O28oKX0sZS5wcm90b3R5cGUuZG93bmxvYWRGbG9hdDMyVGVuc29yRnJvbUJ1ZmZlcj1mdW5jdGlvbihuLGUpe3ZhciBvPTQqdGhpcy53aWR0aF90ZXh0dXJlX291dCp0aGlzLmhlaWdodF90ZXh0dXJlX291dDtpZigyPT09dGhpcy5nbFZlcnNpb24pe3ZhciB0PXRoaXMuZ2wscj1uZXcgRmxvYXQzMkFycmF5KG8pO3QuYmluZEJ1ZmZlcih0LlBJWEVMX1BBQ0tfQlVGRkVSLG4pLHQuZ2V0QnVmZmVyU3ViRGF0YSh0LlBJWEVMX1BBQ0tfQlVGRkVSLDAsciksdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbnVsbCk7dmFyIGk9W107aWYoZi5nZXQoXCJ3ZWJnbF9wYWNrX291dHB1dFwiKSlyZXR1cm4gQXJyYXkuZnJvbShyKS5zbGljZSgwLGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSksMSl9KGUpKTtmb3IodmFyIHM9MDtzPHRoaXMud2lkdGhfdGV4dHVyZV9vdXQqdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQ7cysrKWkucHVzaChyWzQqc10pO3JldHVybiBpfXZhciBhPW4sdT1bXTtmb3Iocz0wO3M8dGhpcy53aWR0aF90ZXh0dXJlX291dCp0aGlzLmhlaWdodF90ZXh0dXJlX291dDtzKyspe3ZhciBsPXRoaXMudGV4dHVyZUNvbmYuaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZD80KnM6czt1LnB1c2goYVtsXSl9cmV0dXJuIHV9LGUucHJvdG90eXBlLnNldE91dFByb3BzPWZ1bmN0aW9uKG4pe3ZhciBlPW4ud2lkdGhfc2hhcGUsbz12b2lkIDA9PT1lPzE6ZSx0PW4uaGVpZ2h0X3NoYXBlLHI9dm9pZCAwPT09dD8xOnQsaT1uLndpZHRoX3RleHR1cmUscz12b2lkIDA9PT1pPzE6aSxhPW4uaGVpZ2h0X3RleHR1cmUsdT12b2lkIDA9PT1hPzE6YSxsPW4uY2hhbm5lbCxmPXZvaWQgMD09PWw/MDpsLGM9bi50b3RhbF9zaGFwZSxfPXZvaWQgMD09PWM/MDpjO3RoaXMud2lkdGhfc2hhcGVfb3V0PW8sdGhpcy5oZWlnaHRfc2hhcGVfb3V0PXIsdGhpcy53aWR0aF90ZXh0dXJlX291dD1zLHRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0PXUsdGhpcy5jaGFubmVsPWYsdGhpcy50b3RhbF9zaGFwZT1ffSxlLnByb3RvdHlwZS5hdHRhY2hDb2xvckJ1ZmZlcj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuZ2w7bi5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixudWxsKSxuLmNhbnZhcy53aWR0aD10aGlzLndpZHRoX3NoYXBlX291dCxuLmNhbnZhcy5oZWlnaHQ9dGhpcy5oZWlnaHRfc2hhcGVfb3V0LG4udmlld3BvcnQoMCwwLG4uY2FudmFzLndpZHRoLG4uY2FudmFzLmhlaWdodCksbi5zY2lzc29yKDAsMCxuLmNhbnZhcy53aWR0aCxuLmNhbnZhcy5oZWlnaHQpfSxlLnByb3RvdHlwZS5hdHRhY2hGcmFtZUJ1ZmZlcj1mdW5jdGlvbihuKXt0aGlzLmN1cnJlbnRUZXh0dXJlPXRoaXMudGV4dHVyZXNNYXBbbl07dmFyIGU9dGhpcy5nbDtlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsdGhpcy5jdXJyZW50VGV4dHVyZSwwKSxlLnZpZXdwb3J0KDAsMCx0aGlzLndpZHRoX3RleHR1cmVfb3V0LHRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0KSxlLnNjaXNzb3IoMCwwLHRoaXMud2lkdGhfdGV4dHVyZV9vdXQsdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQpfSxlLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obixlLG8sdCl7dmFyIHI9dGhpczt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09dCYmKHQ9ITEpO3ZhciBpPW4uaW5wdXRUZW5zb3JzLHM9dm9pZCAwPT09aT9bXTppLGE9bi51bmlmb3JtLHU9dm9pZCAwPT09YT9udWxsOmEsbD1uLmlMYXllcixmPXZvaWQgMD09PWw/MDpsLGM9bi5tb2RlbE5hbWUsXz10aGlzLmdsLGc9MDtzLmZvckVhY2goKGZ1bmN0aW9uKG4pe3IuaW5pdFRleHR1cmUoZyxuLHQpO3ZhciBpPXIuZ2V0VW5pZm9ybUxvYyhcInRleHR1cmVfXCIrbi5uYW1lLGYsZSxvLGMpO2kmJl8udW5pZm9ybTFpKGksZysrKX0pKSx1JiZ0aGlzLnNldFVuaWZvcm0odSxmLGUsbyxjKSxfLmRyYXdBcnJheXMoXy5UUklBTkdMRV9TVFJJUCwwLDQpfSxlLnByb3RvdHlwZS5pbml0VGV4dHVyZT1mdW5jdGlvbihuLGUsbyl7dmFyIHQscj10aGlzLmdsLGk9dGhpcy50ZXh0dXJlQ29uZixzPWUudGVuc29ySWQsYT1vfHxlLmlzUGFja2VkLHU9ZS5kYXRhO2lmKGUucGVyc2lzdGFibGUpe3RoaXMuY2FjaGVUZXh0dXJlcz10aGlzLmNhY2hlVGV4dHVyZXN8fHt9O3ZhciBsPXRoaXMuY2FjaGVUZXh0dXJlc1tzXTtsPyh0PWwsdSYmRi5nZW5UZXh0dXJlSW5mb0Zyb21UZW5zb3JTaGFwZSh0aGlzLk1BWF9URVhUVVJFX1NJWkUsZSkpOih0PXIuY3JlYXRlVGV4dHVyZSgpLHRoaXMuY2FjaGVUZXh0dXJlc1tzXT10KX1lbHNlIHQ9dGhpcy50ZXh0dXJlc01hcFtzXTtyLmFjdGl2ZVRleHR1cmUocltcIlRFWFRVUkVcIituXSksci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsdCksdSYmKGIudXBsb2FkRGF0YVRvVGV4dHVyZShyLGksZSxhKSxlLmRhdGE9bnVsbCl9LGUucHJvdG90eXBlLnNldFVuaWZvcm09ZnVuY3Rpb24obixlLG8sdCxyKXt2YXIgaT10aGlzLHM9T2JqZWN0LmtleXMobiksYT10aGlzLmdsO3MuZm9yRWFjaCgoZnVuY3Rpb24ocyl7dmFyIHU9bltzXS50eXBlLGw9bltzXS52YWx1ZSxmPWkuZ2V0VW5pZm9ybUxvYyhzLGUsbyx0LHIpO0Yuc2V0VW5pZm9ybVBhcmFtKGEsZix1LGwpfSkpfSxlLnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jPWZ1bmN0aW9uKG4sZSxvLHQscil7dmFyIGk9citcIl9cIjtpZihvKXJldHVybiB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbaStlXVtuK3RdO3ZhciBzPXRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbS5wcm9ncmFtLG4pO3JldHVybiB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbaStlXT10aGlzLnVuaWZvcm1Mb2NhdGlvbnNbaStlXXx8e30sdGhpcy51bmlmb3JtTG9jYXRpb25zW2krZV1bbit0XT1zLHN9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9LGV9KChmdW5jdGlvbigpe30pKSxubj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PW4uZmlsdGVyLHI9bi5vdXQsaT1uLmJpYXMscz1lLmdyb3VwcyxhPXZvaWQgMD09PXM/MTpzLHU9ZS5zdHJpZGVzLGw9dm9pZCAwPT09dT9bXTp1LGY9ZS5wYWRkaW5ncyxjPXZvaWQgMD09PWY/W106ZixfPWUuZGlsYXRpb25zLGc9dm9pZCAwPT09Xz9bXTpfLGg9ZS5mdXNlX3JlbHUsZD1lLmZpbHRlcl9uZWFyZXN0X3ZlYzQscD1lLmZpbHRlcl9yZW1haW5kZXJfdmVjNCxtPWUuYWN0X3R5cGUsUD12b2lkIDA9PT1tP1wiXCI6bSx2PWUucGFkZGluZ19hbGdvcml0aG0seD12b2lkIDA9PT12P1wiXCI6dixUPWUuaGFyZF9zd2lzaF9vZmZzZXQsRj12b2lkIDA9PT1UPzM6VCxiPWUuaGFyZF9zd2lzaF9zY2FsZSx5PXZvaWQgMD09PWI/NjpiLEU9ZS5oYXJkX3N3aXNoX3RocmVzaG9sZCx3PXZvaWQgMD09PUU/NjpFLFY9bFswXSxBPXZvaWQgMD09PVY/MTpWLE89bFsxXSxDPXZvaWQgMD09PU8/MTpPLFI9Y1swXSxTPXZvaWQgMD09PVI/MDpSLEk9Y1sxXSxMPXZvaWQgMD09PUk/MDpJLGs9Z1swXSxCPXZvaWQgMD09PWs/MTprLE09Z1sxXSxEPXZvaWQgMD09PU0/MTpNO3JldHVyblwiU0FNRVwiPT09eCYmTWF0aC5jZWlsKChvLndpZHRoX3NoYXBlLXQud2lkdGhfc2hhcGUpL0EpKzEhPT1yLndpZHRoX3NoYXBlJiYoUz0xLEw9MSksXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGludCB4ID0gb1Bvcy5hO1xcbiAgICAgICAgaW50IGMgPSBvUG9zLmc7XFxuICAgICAgICBpbnQgeSA9IG9Qb3MuYjtcXG4gICAgICAgIGludCBiID0gb1Bvcy5yO1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcblxcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpbnQgb1RlbnNvckNoYW5uZWwgPSAoYyAvIChcIityLmNoYW5uZWwrXCIgLyBcIithK1wiKSkgKiBcIit0LmNoYW5uZWwrXCI7XFxuICAgICAgICBpbnQgb3kgPSB5ICogXCIrQStcIiAtIFwiK1MrXCI7XFxuICAgICAgICBmb3IgKGludCBmeSA9IDA7IGZ5IDwgXCIrdC5oZWlnaHRfc2hhcGUrXCI7IGZ5KyspIHtcXG4gICAgICAgICAgICBpZiAob3kgPj0gXCIrby5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChveSA8IDApIHtcXG4gICAgICAgICAgICAgICAgb3kgKz0gXCIrQitcIjtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBveCA9IHggKiBcIitDK1wiIC0gXCIrTCtcIjtcXG4gICAgICAgICAgICBmb3IgKGludCBmeCA9IDA7IGZ4IDwgXCIrdC53aWR0aF9zaGFwZStcIjsgZngrKykge1xcbiAgICAgICAgICAgICAgICBpZiAob3ggPj0gXCIrby53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgb3ggKz0gXCIrRCtcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIGNoYW5uZWzorqHnrpdcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIitkK1wiOyBqICs9IDQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZlZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2ZpbHRlcihjLCBqLCBmeSwgZngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgaiArIDEsIGZ5LCBmeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2ZpbHRlcihjLCBqICsgMiwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIGogKyAzLCBmeSwgZngpXFxuICAgICAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBvVmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgaiwgb3ksIG94KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgaiArIDEsIG95LCBveCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIGogKyAyLCBveSwgb3gpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYiwgb1RlbnNvckNoYW5uZWwgKyBqICsgMywgb3ksIG94KVxcbiAgICAgICAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGRvdChmVmFsdWVzLCBvVmFsdWVzKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoXCIrcCtcIiA9PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZG90KFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgXCIrZCtcIiwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZCtcIiwgb3ksIG94KSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrcCtcIiA9PSAyKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWMyIGZWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgXCIrZCtcIiwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2QrXCIgKyAxLCBmeSwgZngpXFxuICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBvVmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZCtcIiwgb3ksIG94KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZCtcIiArIDEsIG95LCBveClcXG4gICAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBkb3QoZlZhbHVlcywgb1ZhbHVlcyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrcCtcIiA9PSAzKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWMzIGZWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgXCIrZCtcIiwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2QrXCIgKyAxLCBmeSwgZngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgXCIrZCtcIiArIDIsIGZ5LCBmeClcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICB2ZWMzIG9WYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYiwgb1RlbnNvckNoYW5uZWwgKyBcIitkK1wiLCBveSwgb3gpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYiwgb1RlbnNvckNoYW5uZWwgKyBcIitkK1wiICsgMSwgb3ksIG94KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZCtcIiArIDIsIG95LCBveClcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZG90KGZWYWx1ZXMsIG9WYWx1ZXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIG94ICs9IFwiK0QrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG95ICs9IFwiK0IrXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIisoaT9cInJlcyArPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfYmlhcygwLCAwLCAwLCBjKTtcIjpcIlwiKStcIlxcblxcbiAgICAgICAgaWYgKFwiK2grXCIpIHtcXG4gICAgICAgICAgICByZXMgPSBtYXgoMC4wLCByZXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoXCIrKFwicmVsdTZcIj09PVApK1wiKSB7XFxuICAgICAgICAgICAgcmVzID0gbWluKG1heCgwLjAsIHJlcyksIDYuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIisoXCJoYXJkX3N3aXNoXCI9PT1QKStcIikge1xcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIG1pbihcXG4gICAgICAgICAgICAgICAgbWF4KDAuMCwgcmVzICsgZmxvYXQoXCIrRitcIikpLFxcbiAgICAgICAgICAgICAgICBmbG9hdChcIit3K1wiKVxcbiAgICAgICAgICAgICkgLyBmbG9hdChcIit5K1wiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2ZpbHRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxiaWFzOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcImFkYXB0UGFkZGluZ3NcIixcImlzQXBwbHlTZXBhcmFibGVDb252XCIsXCJiYXRjaENvbXB1dGVDb252MmRcIixcInByb2Nlc3NCaWFzXCJdfTtmdW5jdGlvbiBlbihuLGUpe3ZhciBvPW5bMF0sdD1uWzFdLHI9blsyXSxpPW5bM107aWYoMT09PW8mJjE9PT10KXJldHVybltbMSwxLHJdLDMsW2ldLDEsW3IsaV1dO3ZhciBzPW4uc2xpY2UoMCxlKSxhPW4uc2xpY2UoZSk7cmV0dXJuW3Mscy5sZW5ndGgsYSxhLmxlbmd0aCxbcy5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4qZX0pKSxhLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSkpXV19ZnVuY3Rpb24gb24obixlLG8pe2lmKDE9PT1vKXJldHVyblwiXFxuICAgICAgICAgICAgaW50IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X1wiK24rXCIoaW50IG4pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbE1vZChuLCBcIitlWzBdK1wiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIjt2YXIgdD1nKGUpO3JldHVybiB0LnB1c2goMSksXCJcXG4gICAgaXZlY1wiK28rXCIgc2hhcGVWZWNfXCIrbitcIiA9IGl2ZWNcIitvK1wiKFwiK3Quam9pbihcIiwgXCIpK1wiKTtcXG4gICAgaXZlY1wiK28rXCIgZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfXCIrbitcIihpbnQgbikge1xcbiAgICAgICAgaXZlY1wiK28rXCIgcG9zO1xcbiAgICAgICAgcG9zWzBdID0gbiAvIHNoYXBlVmVjX1wiK24rXCJbMF07XFxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IFwiK28rXCI7IGkrKykge1xcbiAgICAgICAgICAgIG4gPSBjYWxNb2Qobiwgc2hhcGVWZWNfXCIrbitcIltpIC0gMV0pO1xcbiAgICAgICAgICAgIHBvc1tpXSA9IG4gLyBzaGFwZVZlY19cIituK1wiW2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHBvcztcXG4gICAgfVxcbiAgICBcIn1mdW5jdGlvbiB0bihuKXtyZXR1cm4gMT09PW4/XCJpbnRcIjpcIml2ZWNcIitufWZ1bmN0aW9uIHJuKG4pe3ZhciBlPW4udG90YWxfc2hhcGUsbz1uLmNoYW5uZWwsdD1uLmhlaWdodF9zaGFwZSxyPW4ud2lkdGhfc2hhcGU7cmV0dXJuW2Uvby90L3Isbyx0LHJdfWNvbnN0IHNuPXttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ub3JpZ2luLHQ9ZS50cmFuc3Bvc2VfWCxyPXZvaWQgMCE9PXQmJnQsaT1lLnRyYW5zcG9zZV9ZLHM9dm9pZCAwIT09aSYmaSxhPWUudHJhbnNfeCx1PXZvaWQgMCE9PWEmJmEsbD1lLnRyYW5zX3ksZj1yfHx1LGM9c3x8dm9pZCAwIT09bCYmbDtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICAvLyDojrflj5ZvdXRwdXTnmoTlnZDmoIdcXG4gICAgICAgIGl2ZWM0IG91dF9wb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGl2ZWM0IG9yaWdpbl9wb3MgPSBvdXRfcG9zO1xcbiAgICAgICAgaWYgKFwiK2YrXCIpIHtcXG4gICAgICAgICAgICBvcmlnaW5fcG9zWzNdID0gb3JpZ2luX3Bvc1syXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGl2ZWM0IGNvdW50ZXJfcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGlmIChcIitjK1wiKSB7XFxuICAgICAgICAgICAgY291bnRlcl9wb3NbMl0gPSBjb3VudGVyX3Bvc1szXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrKGY/by5oZWlnaHRfc2hhcGU6by53aWR0aF9zaGFwZSkrXCI7IGorKykge1xcbiAgICAgICAgICAgIGlmIChcIitmK1wiKSB7XFxuICAgICAgICAgICAgICAgIG9yaWdpbl9wb3NbMl0gPSBqO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgb3JpZ2luX3Bvc1szXSA9IGo7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChcIitjK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvdW50ZXJfcG9zWzNdID0gajtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGNvdW50ZXJfcG9zWzJdID0gajtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3JpZ2luX3Bvc1swXSwgb3JpZ2luX3Bvc1sxXSwgb3JpZ2luX3Bvc1syXSwgb3JpZ2luX3Bvc1szXSk7XFxuICAgICAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKGNvdW50ZXJfcG9zWzBdLCBjb3VudGVyX3Bvc1sxXSwgY291bnRlcl9wb3NbMl0sIGNvdW50ZXJfcG9zWzNdKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICByZXMgKz0gYyAqIG87XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX07ZnVuY3Rpb24gYW4obixlKXt2YXIgbz1uWzBdLHQ9blsxXSxyPW5bMl0saT1uWzNdO2lmKDE9PT1vJiYxPT09dClyZXR1cm5bWzEsMSxyXSwzLFtpXSwxLFtyLGldXTt2YXIgcz1uLnNsaWNlKDAsZSksYT1uLnNsaWNlKGUpO3JldHVybltzLHMubGVuZ3RoLGEsYS5sZW5ndGgsW3MucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSksYS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4qZX0pKV1dfWZ1bmN0aW9uIHVuKG4sZSxvKXtpZigxPT09bylyZXR1cm5cIlxcbiAgICAgICAgICAgIGludCBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9cIituK1wiKGludCBuKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxNb2QobiwgXCIrZVswXStcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCI7dmFyIHQ9ZyhlKTtyZXR1cm4gdC5wdXNoKDEpLFwiXFxuICAgIGl2ZWNcIitvK1wiIHNoYXBlVmVjX1wiK24rXCIgPSBpdmVjXCIrbytcIihcIit0LmpvaW4oXCIsIFwiKStcIik7XFxuICAgIGl2ZWNcIitvK1wiIGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X1wiK24rXCIoaW50IG4pIHtcXG4gICAgICAgIGl2ZWNcIitvK1wiIHBvcztcXG4gICAgICAgIHBvc1swXSA9IG4gLyBzaGFwZVZlY19cIituK1wiWzBdO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBcIitvK1wiOyBpKyspIHtcXG4gICAgICAgICAgICBuID0gY2FsTW9kKG4sIHNoYXBlVmVjX1wiK24rXCJbaSAtIDFdKTtcXG4gICAgICAgICAgICBwb3NbaV0gPSBuIC8gc2hhcGVWZWNfXCIrbitcIltpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwb3M7XFxuICAgIH1cXG4gICAgXCJ9ZnVuY3Rpb24gbG4obil7cmV0dXJuIDE9PT1uP1wiaW50XCI6XCJpdmVjXCIrbn1mdW5jdGlvbiBmbihuKXt2YXIgZT1uLnRvdGFsX3NoYXBlLG89bi5jaGFubmVsLHQ9bi5oZWlnaHRfc2hhcGUscj1uLndpZHRoX3NoYXBlO3JldHVybltlL28vdC9yLG8sdCxyXX1jb25zdCBjbj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgdmVjMiBvdXRDb29yZCA9IHZDb29yZC54eSAqIChfMmRfc2hhcGVfdGV4dHVyZV9vdXQpO1xcbiAgICAgICAgaW50IGluZGV4ID0gaW50KG91dENvb3JkLngpICsgaW50KG91dENvb3JkLnkpICogaW50KFwiK24ub3V0LndpZHRoX3RleHR1cmUrXCIpO1xcbiAgICAgICAgaXZlYzQgb3JpZ2luUG9zID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfb3JpZ2luKGluZGV4KTtcXG4gICAgICAgIGZsb2F0IHJlcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3JpZ2luUG9zWzBdLCBvcmlnaW5Qb3NbMV0sIG9yaWdpblBvc1syXSwgb3JpZ2luUG9zWzNdKTtcXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleFwiLFwiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sX249e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vdXQsdD1uLm9yaWdpbixyPWUuYWxpZ25fbW9kZSxpPXZvaWQgMD09PXI/MTpyLHM9ZS5hbGlnbl9jb3JuZXJzLGE9dm9pZCAwPT09c3x8cztyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcblxcbiAgICB2ZWM0IGdldERhdGEoZmxvYXQgbiwgZmxvYXQgc2NhbGUsIGJvb2wgYWxpZ25fZmxhZywgaW50IGluX2xlbikge1xcbiAgICAgICAgZmxvYXQgbSA9IGFsaWduX2ZsYWcgPyAoKG4gKyAwLjUpIC8gc2NhbGUgLSAwLjUpIDogKG4gLyBzY2FsZSk7XFxuICAgICAgICBpbnQgYTEgPSBpbnQoZmxvb3IobSkpO1xcbiAgICAgICAgYTEgPSBhMSA+IDAgPyBhMSA6IDA7XFxuICAgICAgICBpbnQgYTIgPSAoYTEgKyAxKSA8IChpbl9sZW4gLSAxKSA/IChhMSArIDEpIDogKGluX2xlbiAtIDEpO1xcblxcbiAgICAgICAgZmxvYXQgaWR4X3NyYyA9IChuICsgMC41KSAvIHNjYWxlIC0gMC41O1xcbiAgICAgICAgaWR4X3NyYyA9IGlkeF9zcmMgPiAwLjAgPyBpZHhfc3JjIDogMC4wO1xcbiAgICAgICAgZmxvYXQgYjEgPSBhbGlnbl9mbGFnID8gKGlkeF9zcmMgLSBmbG9hdChhMSkpIDogKG4gLyBzY2FsZSAtIGZsb2F0KGExKSk7XFxuICAgICAgICBmbG9hdCBiMiA9IDEuMCAtIGIxO1xcbiAgICAgICAgcmV0dXJuIHZlYzQoZmxvYXQoYTEpLCBmbG9hdChhMiksIGIxLCBiMik7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcblxcbiAgICAgICAgYm9vbCBhbGlnbl9mbGFnID0gXCIraStcIiA9PSAwICYmICFcIithK1wiO1xcblxcbiAgICAgICAgZmxvYXQgc2NhbGVfeCA9IDAuMDtcXG4gICAgICAgIGZsb2F0IHNjYWxlX3kgPSAwLjA7XFxuICAgICAgICBpZiAoXCIrYStcIikge1xcbiAgICAgICAgICAgIHNjYWxlX3ggPSBmbG9hdChcIitvLndpZHRoX3NoYXBlK1wiIC0gMSkgLyBmbG9hdChcIit0LndpZHRoX3NoYXBlK1wiIC0gMSk7XFxuICAgICAgICAgICAgc2NhbGVfeSA9IGZsb2F0KFwiK28uaGVpZ2h0X3NoYXBlK1wiIC0gMSkgLyBmbG9hdChcIit0LmhlaWdodF9zaGFwZStcIiAtIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgc2NhbGVfeCA9IGZsb2F0KFwiK28ud2lkdGhfc2hhcGUrXCIpIC8gZmxvYXQoXCIrdC53aWR0aF9zaGFwZStcIik7XFxuICAgICAgICAgICAgc2NhbGVfeSA9IGZsb2F0KFwiK28uaGVpZ2h0X3NoYXBlK1wiKSAvIGZsb2F0KFwiK3QuaGVpZ2h0X3NoYXBlK1wiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzQgdnggPSBnZXREYXRhKGZsb2F0KG9Qb3MuYSksIHNjYWxlX3gsIGFsaWduX2ZsYWcsIFwiK3Qud2lkdGhfc2hhcGUrXCIpO1xcbiAgICAgICAgdmVjNCB2eSA9IGdldERhdGEoZmxvYXQob1Bvcy5iKSwgc2NhbGVfeSwgYWxpZ25fZmxhZywgXCIrdC5oZWlnaHRfc2hhcGUrXCIpO1xcblxcbiAgICAgICAgaW50IHgxID0gaW50KHZ4LnIpO1xcbiAgICAgICAgaW50IHgyID0gaW50KHZ4LmcpO1xcbiAgICAgICAgZmxvYXQgeDMgPSB2eC5iO1xcbiAgICAgICAgZmxvYXQgeDQgPSB2eC5hO1xcbiAgICAgICAgaW50IHkxID0gaW50KHZ5LnIpO1xcbiAgICAgICAgaW50IHkyID0gaW50KHZ5LmcpO1xcbiAgICAgICAgZmxvYXQgeTMgPSB2eS5iO1xcbiAgICAgICAgZmxvYXQgeTQgPSB2eS5hO1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWUxMSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIHkxLCB4MSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZTEyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgeTIsIHgxKTtcXG4gICAgICAgIGZsb2F0IHZhbHVlMjEgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCB5MSwgeDIpO1xcbiAgICAgICAgZmxvYXQgdmFsdWUyMiA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIHkyLCB4Mik7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IHg0ICogeTQgKiB2YWx1ZTExICsgeDQgKiB5MyAqIHZhbHVlMTIgKyB4MyAqIHk0ICogdmFsdWUyMSArIHgzICogeTMgKiB2YWx1ZTIyO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHZhbHVlKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LGduPV9uO3ZhciBobj17cmVsdTpbXCJ0cmFuc1RvUHJlbHVcIl0scmVsdTY6W1widHJhbnNUb1JlbHU2XCJdLGxlYWt5X3JlbHU6W1widHJhbnNUb0xlYWt5cmVsdVwiXSx0cmFuc1RvTGVha3lyZWx1OltcInRyYW5zVG9MZWFreXJlbHVcIl0sc2NhbGU6W1widHJhbnNUb1NjYWxlXCJdLHNpZ21vaWQ6W1widHJhbnNUb1NpZ21vaWRcIl0saGFyZF9zaWdtb2lkOltcInRyYW5zVG9IYXJkU2lnbW9pZFwiXSxwb3c6W1widHJhbnNUb1Bvd1wiXSxleHA6W1widHJhbnNUb0V4cFwiXSxzcXJ0OltcInRyYW5zVG9TcXJ0XCJdLHRhbmg6W1widHJhbnNUb1RhbmhcIl19O2Z1bmN0aW9uIGRuKG4sZSl7dmFyIG89ZS5tdWx0aV92YWx1ZSx0PXZvaWQgMD09PW8/MTpvLHI9ZS5iaWFzX3ZhbHVlLGk9dm9pZCAwPT09cj8wOnI7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgZmxvYXQgbyA9IGdldFBpeGVsc0Zyb21UZXh0dXJlUG9zX29yaWdpbih2Q29vcmQpLnI7XFxuICAgICAgICBmbG9hdCByZXMgPSBcIitlLmFjdGl2ZV9mdW5jdGlvbitcIihvLCBmbG9hdChcIit0K1wiKSwgZmxvYXQoXCIraStcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9ZnVuY3Rpb24gcG4obil7cmV0dXJue21haW5GdW5jOmRuLHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFBpeGVsc0Zyb21UZXh0dXJlUG9zXCJdfSxiZWhhdmlvcnM6aG5bbl19fWNvbnN0IG1uPXttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPWUuYXhlcyx0PUFycmF5LmlzQXJyYXkobyk/bzpbb10scj1bMCwxLDIsM10uZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm4gbj49dC5sZW5ndGh9KSk7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKFwiK1swLDEsMiwzXS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiB0LmluZGV4T2Yobik+LTE/MDpcIm9Qb3NbXCIrci5zcGxpY2UoMCwxKStcIl1cIn0pKS5qb2luKFwiLFwiKStcIik7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxQbj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PW4ub3V0LHI9ZS5hbGlnbl9jb3JuZXJzO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIGludCBnZXREYXRhKGZsb2F0IG4sIGZsb2F0IHNjYWxlLCBib29sIGFsaWduX2Nvcm5lcnMpIHtcXG4gICAgICAgIGZsb2F0IG0gPSBhbGlnbl9jb3JuZXJzID8gKG4gLyBzY2FsZSArIDAuNSkgOiAobiAvIHNjYWxlKTtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IobSkpO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIFxcbiAgICAgICAgZmxvYXQgc2NhbGVfeCA9IDAuMDtcXG4gICAgICAgIGZsb2F0IHNjYWxlX3kgPSAwLjA7XFxuICAgICAgICBpZiAoXCIrcitcIikge1xcbiAgICAgICAgICAgIHNjYWxlX3ggPSBmbG9hdChcIit0LndpZHRoX3NoYXBlK1wiIC0xKSAvIGZsb2F0KFwiK28ud2lkdGhfc2hhcGUrXCIgLSAxKTtcXG4gICAgICAgICAgICBzY2FsZV95ID0gZmxvYXQoXCIrdC5oZWlnaHRfc2hhcGUrXCIgLSAxKSAvIGZsb2F0KFwiK28uaGVpZ2h0X3NoYXBlK1wiIC0gMSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBzY2FsZV94ID0gZmxvYXQoXCIrdC53aWR0aF9zaGFwZStcIikgLyBmbG9hdChcIitvLndpZHRoX3NoYXBlK1wiKTtcXG4gICAgICAgICAgICBzY2FsZV95ID0gZmxvYXQoXCIrdC5oZWlnaHRfc2hhcGUrXCIpIC8gZmxvYXQoXCIrby5oZWlnaHRfc2hhcGUrXCIpO1xcbiAgICAgICAgfVxcbiAgICBcXG4gICAgICAgIGludCB2eCA9IGdldERhdGEoZmxvYXQob1Bvcy5hKSwgc2NhbGVfeCwgXCIrcitcIik7XFxuICAgICAgICBpbnQgdnkgPSBnZXREYXRhKGZsb2F0KG9Qb3MuYiksIHNjYWxlX3ksIFwiK3IrXCIpO1xcbiAgICAgICAgXFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgdnksIHZ4KTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxufVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxjb21tb25GdW5jQ29uZjpbXCJ0cmFuc2ZlckZyb21OSFdDdG9OQ0hXXCJdfTt2YXIgdm49ZnVuY3Rpb24oKXtmb3IodmFyIG49MCxlPTAsbz1hcmd1bWVudHMubGVuZ3RoO2U8bztlKyspbis9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgdD1BcnJheShuKSxyPTA7Zm9yKGU9MDtlPG87ZSsrKWZvcih2YXIgaT1hcmd1bWVudHNbZV0scz0wLGE9aS5sZW5ndGg7czxhO3MrKyxyKyspdFtyXT1pW3NdO3JldHVybiB0fTtjb25zdCB4bj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PW4uaW1hZ2Uscj1uLm91dCxpPWUudmFyaWFuY2VzLHM9dm9pZCAwPT09aT9bLjEsLjEsLjIsLjJdOmksYT1lLmZpeGVkX3NpemVzLHU9ZS5maXhlZF9yYXRpb3MsbD1lLmRlbnNpdGllcyxmPWUuZmxhdHRlbl90b18yZCxjPWUuY2xpcCxfPWUuc3RlcF93LGQ9dm9pZCAwPT09Xz8wOl8scD1lLnN0ZXBfaCxtPXZvaWQgMD09PXA/MDpwLFA9ZS5vZmZzZXQsdj12b2lkIDA9PT1QPy41OlAseD1lLnJ1bnRpbWUsVD12b2lkIDA9PT14PzA6eCxGPXQuaGVpZ2h0X3NoYXBlLGI9dC53aWR0aF9zaGFwZSx5PW8uaGVpZ2h0X3NoYXBlLEU9by53aWR0aF9zaGFwZSx3PXIudG90YWxfc2hhcGUsVj1yLmNoYW5uZWwsQT1yLmhlaWdodF9zaGFwZSxPPXIud2lkdGhfc2hhcGUsQz13L1YvQS9PLFI9ZyhbQyxWLEEsT10pLFM9ZCxJPW07MCE9PWQmJjAhPT1tfHwoUz1iL0UsST1GL3kpO3ZhciBMPU1hdGgucm91bmQoLjUqKFMrSSkpLGs9dS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnNxcnQobil9KSksQj0xPT09ay5sZW5ndGg/XCJzcXJ0X2ZpeGVkX3JhdGlvc1wiOlwic3FydF9maXhlZF9yYXRpb3Nbcl1cIixNPXUubGVuZ3RoLEQ9QSxVPUMsaj1WO2YmJihVPXksaj1FLEQ9QS95L0UpO3ZhciBOPWcoW1UsaixELE9dKSxYPUcoXCJvdXQxXCIse251bWJlcnNfc2hhcGU6dm4oTixbMV0pLGxlbmd0aF9zaGFwZTo0fSksSD1sLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIG4qbipNfSkpLFc9SC5sZW5ndGgsej1mdW5jdGlvbihuKXt2YXIgZT1cIml2ZWMyIGNhbFJlbWFpbihpbnQgcmVtYWluLCBpbnQgY3VyQWNjSW5kZXgsIGludCBzKSB7XCIsbz1uLmxlbmd0aDtpZigxPT09byllKz1cIlxcbiAgICAgICAgICAgIGludCBhY2NJbmRleDAgPSBkZW5zaXR5X2FjY19zaGFwZTtcXG5cXG4gICAgICAgICAgICBpZiAocmVtYWluID49IGFjY0luZGV4MCkge1xcbiAgICAgICAgICAgICAgICBzKys7XFxuICAgICAgICAgICAgICAgIHJlbWFpbiAtPSBhY2NJbmRleDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaXZlYzIocmVtYWluLCBzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCI7ZWxzZSBmb3IodmFyIHQ9MDt0PG87dCsrKWUrPVwiXFxuICAgICAgICAgICAgaW50IGFjY0luZGV4XCIrdCtcIiA9IGRlbnNpdHlfYWNjX3NoYXBlW1wiK3QrXCJdO1xcblxcbiAgICAgICAgICAgIGlmIChyZW1haW4gPj0gYWNjSW5kZXhcIit0K1wiKSB7XFxuICAgICAgICAgICAgICAgIHMrKztcXG4gICAgICAgICAgICAgICAgcmVtYWluIC09IGFjY0luZGV4XCIrdCtcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpdmVjMihyZW1haW4sIHMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcIjtyZXR1cm4gZStcIlxcbiAgICB9XFxuICAgIFwifShIKSxZPWM/XCJ2ID0gbWluKG1heCh2LCAwLiksIDEuKTtcIjpcIlwiLHE9MT09PVc/XCJkZW5zaXR5X2FjY19zaGFwZVwiOlwiZGVuc2l0eV9hY2Nfc2hhcGVbMF1cIixaPVwiXFxuICAgIGZsb2F0IGdldEZsb2F0NFRlbnNvclZhbCh2ZWM0IHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMF07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsxXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzJdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMykge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbM107XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZ2V0RmxvYXQzVGVuc29yVmFsKHZlYzMgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclswXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzFdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMikge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMl07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZmxvYXQgZ2V0RmxvYXQyVGVuc29yVmFsKHZlYzIgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclswXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzFdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGdldEZsb2F0MVRlbnNvclZhbChmbG9hdCB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHRlbnNvcjtcXG4gICAgfVxcbiAgICBpbnQgZ2V0SW50NFRlbnNvclZhbChpdmVjNCB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMV07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsyXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzNdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGludCBnZXRJbnQzVGVuc29yVmFsKGl2ZWMzIHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMF07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsxXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzJdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGludCBnZXRJbnQyVGVuc29yVmFsKGl2ZWMyIHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMF07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsxXTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpbnQgZ2V0SW50MVRlbnNvclZhbChpbnQgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgcmV0dXJuIHRlbnNvcjtcXG4gICAgfVxcblxcbiAgICBcIitYK1wiXFxuICAgIFxcbiAgICAgICAgXCIraChsLFwiZGVuc2l0aWVzXCIpK1wiXFxuICAgICAgICBcIitoKGEsXCJmaXhlZF9zaXplc1wiKStcIlxcbiAgICAgICAgXCIraChrLFwic3FydF9maXhlZF9yYXRpb3NcIikrXCJcXG4gICAgICAgIFwiK2Z1bmN0aW9uKG4sZSl7aWYoMT09PW4ubGVuZ3RoKXJldHVyblwiaW50IFwiK2UrXCIgPSBpbnQoXCIrblswXStcIik7XCI7Zm9yKHZhciBvPW4ubGVuZ3RoLHQ9XCJcXG4gICAgICAgIGl2ZWNcIitvK1wiIFwiK2UrXCIgPSBpdmVjXCIrbytcIihcXG4gICAgXCIscj0wO3I8bztyKyspdCs9bltyXStcIixcIjtyZXR1cm4gdC5zbGljZSgwLC0xKStcIik7XCJ9KEgsXCJkZW5zaXR5X2FjY19zaGFwZVwiKStcIlxcbiAgICBcXG4gICAgXCIreitcIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgaW50IHJyID0gaW50KG9Qb3Mucik7XFxuICAgICAgICBpbnQgZ2cgPSBpbnQob1Bvcy5nKTtcXG4gICAgICAgIGludCBiYiA9IGludChvUG9zLmIpO1xcbiAgICAgICAgaW50IGFhID0gaW50KG9Qb3MuYSk7XFxuXFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGludCBpbmRleCA9IHJyICogXCIrUlswXStcIiArIGdnICogXCIrUlsxXStcIiArIGJiICogXCIrUlsyXStcIiArIGFhO1xcbiAgICAgICAgaXZlYzQgcmVhbE91dFBvcyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X291dDEoaW5kZXgpO1xcbiAgICAgICAgaW50IGggPSByZWFsT3V0UG9zLnI7XFxuICAgICAgICBpbnQgdyA9IHJlYWxPdXRQb3MuZztcXG4gICAgICAgIGludCBiID0gcmVhbE91dFBvcy5iO1xcbiAgICAgICAgaW50IGEgPSByZWFsT3V0UG9zLmE7XFxuICAgIFwiO3JldHVybiAxPT09VD9cIlxcbiAgICAgICAgXCIraChzLFwidmFyaWFuY2VzXCIpK1wiXFxuICAgICAgICBcIitaK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0RmxvYXQ0VGVuc29yVmFsKHZhcmlhbmNlcywgYWEpKTtcXG4gICAgICAgIH1cIjpcIlxcbiAgICAgICAgICAgIFwiK1orXCJcXG4gICAgICAgICAgICAvLyDmsYJpZHgg5a+55bqU55qEIHMsIHIsIGRpLCBkalxcbiAgICAgICAgICAgIGludCBzID0gMDtcXG4gICAgICAgICAgICBpbnQgcmVtYWluID0gYjtcXG4gICAgICAgICAgICBpbnQgY3VyQWNjSW5kZXggPSBcIitxK1wiO1xcblxcbiAgICAgICAgICAgIGl2ZWMyIHJlbWFpbkluZm8gPSBjYWxSZW1haW4ocmVtYWluLCBjdXJBY2NJbmRleCwgcyk7XFxuICAgICAgICAgICAgcmVtYWluID0gcmVtYWluSW5mb1swXTtcXG4gICAgICAgICAgICBzID0gcmVtYWluSW5mb1sxXTtcXG4gICAgICAgICAgICBpbnQgZGVuc2l0eSA9IGludChnZXRGbG9hdFwiK2wubGVuZ3RoK1wiVGVuc29yVmFsKGRlbnNpdGllcywgcykpO1xcbiAgICAgICAgICAgIGludCByID0gaW50KGZsb29yKGZsb2F0KHJlbWFpbiAvIGRlbnNpdHkgLyBkZW5zaXR5KSkpO1xcbiAgICAgICAgICAgIHJlbWFpbiAtPSByICogZGVuc2l0eSAqIGRlbnNpdHk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZGkgPSBmbG9vcihmbG9hdChyZW1haW4gLyBkZW5zaXR5KSk7XFxuICAgICAgICAgICAgZmxvYXQgZGogPSBmbG9hdChyZW1haW4gLSBpbnQoZGkpICogZGVuc2l0eSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgY2VudGVyX3ggPSAoZmxvYXQodykgKyBmbG9hdChcIit2K1wiKSkgKiBmbG9hdChcIitTK1wiKTtcXG4gICAgICAgICAgICBmbG9hdCBjZW50ZXJfeSA9IChmbG9hdChoKSArIGZsb2F0KFwiK3YrXCIpKSAqIGZsb2F0KFwiK0krXCIpO1xcbiAgICAgICAgICAgIGZsb2F0IGZpeGVkX3NpemUgPSBnZXRGbG9hdFwiK2EubGVuZ3RoK1wiVGVuc29yVmFsKGZpeGVkX3NpemVzLCBzKTtcXG4gICAgICAgICAgICBmbG9hdCBzaGlmdCA9IGZsb2F0KFwiK0wrXCIpIC8gZmxvYXQoZGVuc2l0eSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgdiA9IDAuMDtcXG4gICAgICAgICAgICBpZiAoYSA9PSAwIHx8IGEgPT0gMikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBib3hfd2lkdGhfcmF0aW8gPSBmaXhlZF9zaXplICogXCIrQitcIjtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZGVuc2l0eV9jZW50ZXJfeCA9IGNlbnRlcl94IC0gZmxvYXQoXCIrTCtcIikgLyAyLiArIHNoaWZ0IC8gMi47XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNlbnRlcl94X3RlbXAgPSBkZW5zaXR5X2NlbnRlcl94ICsgZGogKiBzaGlmdDtcXG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdiA9IG1heCgoY2VudGVyX3hfdGVtcCAtIGJveF93aWR0aF9yYXRpbyAvIDIuKSAvIGZsb2F0KFwiK2IrXCIpLCAwLik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB2ID0gbWluKChjZW50ZXJfeF90ZW1wICsgYm94X3dpZHRoX3JhdGlvIC8gMi4pIC8gZmxvYXQoXCIrYitcIiksIDEuKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgYm94X2hlaWdodF9yYXRpbyA9IGZpeGVkX3NpemUgLyBcIitCK1wiO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkZW5zaXR5X2NlbnRlcl95ID0gY2VudGVyX3kgLSBmbG9hdChcIitMK1wiKSAvIDIuICsgc2hpZnQgLyAyLjtcXG4gICAgICAgICAgICAgICAgZmxvYXQgY2VudGVyX3lfdGVtcCA9IGRlbnNpdHlfY2VudGVyX3kgKyBkaSAqIHNoaWZ0O1xcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ID0gbWF4KChjZW50ZXJfeV90ZW1wIC0gYm94X2hlaWdodF9yYXRpbyAvIDIuKSAvIGZsb2F0KFwiK0YrXCIpLCAwLik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB2ID0gbWluKChjZW50ZXJfeV90ZW1wICsgYm94X2hlaWdodF9yYXRpbyAvIDIuKSAvIGZsb2F0KFwiK0YrXCIpLCAxLik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIrWStcIlxcblxcbiAgICAgICAgICAgIHNldE91dHB1dCh2KTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2ltYWdlOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sVG49e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLmltYWdlLHI9bi5vdXQsaT1lLnZhcmlhbmNlcyxzPXZvaWQgMD09PWk/Wy4xLC4xLC4yLC4yXTppLGE9ZS5mbGlwLHU9ZS5jbGlwLGw9ZS5zdGVwX3csZj12b2lkIDA9PT1sPzA6bCxjPWUuc3RlcF9oLGc9dm9pZCAwPT09Yz8wOmMsbT1lLm9mZnNldCxQPXZvaWQgMD09PW0/LjU6bSx2PWUucnVudGltZSx4PXZvaWQgMD09PXY/MDp2LFQ9ZS5taW5fc2l6ZXMsRj12b2lkIDA9PT1UP1tdOlQsYj1lLm1heF9zaXplcyx5PXZvaWQgMD09PWI/W106YixFPWUuYXNwZWN0X3JhdGlvcyx3PXZvaWQgMD09PUU/W106RSxWPWUubWluX21heF9hc3BlY3RfcmF0aW9zX29yZGVyLEE9dm9pZCAwIT09ViYmVixPPXQuaGVpZ2h0X3NoYXBlLEM9dC53aWR0aF9zaGFwZSxSPW8uaGVpZ2h0X3NoYXBlLFM9by53aWR0aF9zaGFwZSxJPXIuY2hhbm5lbCxMPXIuaGVpZ2h0X3NoYXBlLGs9ZixCPWc7MCE9PWYmJjAhPT1nfHwoaz1DL1MsQj1PL1IpO3ZhciBNPVsxXTt3LmZvckVhY2goKGZ1bmN0aW9uKG4pezEhPT1uJiYoTS5wdXNoKE1hdGguc3FydChuKSksYSYmTS5wdXNoKE1hdGguc3FydCgxL24pKSl9KSk7dmFyIEQ9TS5sZW5ndGgsVT1cIlxcbiAgICAgICAgXCIrZChGLFwibWluX3NpemVzXCIsXy5GTE9BVF9UWVBFKStcIlxcbiAgICAgICAgXCIrZCh5LFwibWF4X3NpemVzXCIsXy5GTE9BVF9UWVBFKStcIlxcbiAgICAgICAgXCIrZChNLFwiYXNwZWN0X3JhdGlvc1wiLF8uRkxPQVRfVFlQRSkrXCJcXG4gICAgXCIsaj11P1wicmVzID0gbWluKG1heChyZXMsIDAuKSwgMS4pO1wiOlwiXCIsTj1cIlxcbiAgICBmbG9hdCBnZXRGbG9hdDRUZW5zb3JWYWwodmVjNCB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMV07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsyXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzNdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIFxcbiAgICAgICAgXCIrcChGLFwibWluX3NpemVzXCIsXy5GTE9BVF9UWVBFKStcIlxcbiAgICAgICAgXCIrcCh5LFwibWF4X3NpemVzXCIsXy5GTE9BVF9UWVBFKStcIlxcbiAgICAgICAgXCIrcChNLFwiYXNwZWN0X3JhdGlvc1wiLF8uRkxPQVRfVFlQRSkrXCJcXG4gICAgXFxuXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgbm4gPSBpbnQob1Bvcy5yKTtcXG4gICAgICAgIGludCBjYyA9IGludChvUG9zLmcpO1xcbiAgICAgICAgaW50IGhoID0gaW50KG9Qb3MuYik7XFxuICAgICAgICBpbnQgd3cgPSBpbnQob1Bvcy5hKTtcXG5cXG5cXG4gICAgICAgIFwiK1UrXCJcXG5cXG4gICAgXCI7cmV0dXJuIDE9PT14P1wiXFxuICAgICAgICAgICAgXCIraChzLFwidmFyaWFuY2VzXCIpK1wiXFxuICAgICAgICAgICAgXCIrTitcIlxcbiAgICAgICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgICAgICByZXMgPSBnZXRGbG9hdDRUZW5zb3JWYWwodmFyaWFuY2VzLCB3dyk7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgXCIrTitcIlxcbiAgICAgICAgICAgIGludCBpZHggPSBubiAqIFwiK0kqTCtcIiArIGNjICogXCIrTCtcIiArIGhoO1xcbiAgICAgICAgICAgIGludCBhc19udW0gPSBcIitEK1wiO1xcbiAgICAgICAgICAgIGZsb2F0IG9mZnNldCA9IFwiK1ArXCI7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgaW50IGZlYXR1cmVfd2lkdGggPSBcIitTK1wiO1xcbiAgICAgICAgICAgIGludCBudW1fcHJpb3JzID0gXCIrTCtcIjtcXG4gICAgICAgICAgICBmbG9hdCBzdGVwX3dpZHRoID0gZmxvYXQoXCIraytcIik7XFxuICAgICAgICAgICAgZmxvYXQgc3RlcF9oZWlnaHQgPSBmbG9hdChcIitCK1wiKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBpbV93aWR0aCA9IGZsb2F0KFwiK0MrXCIpO1xcbiAgICAgICAgICAgIGZsb2F0IGltX2hlaWdodCA9IGZsb2F0KFwiK08rXCIpO1xcblxcbiAgICAgICAgICAgIGJvb2wgbWluX21heF9hc3BlY3RfcmF0aW9zX29yZGVyID0gXCIrQStcIjtcXG5cXG4gICAgICAgICAgICAvLyDmsYJpZHgg5a+55bqU55qEIGggdyBwIG1cXG4gICAgICAgICAgICBpbnQgaCA9IGludChpZHggLyAobnVtX3ByaW9ycyAqIGZlYXR1cmVfd2lkdGgpKTtcXG4gICAgICAgICAgICBpbnQgdyA9IGNhbE1vZChpZHggLyBudW1fcHJpb3JzLCBmZWF0dXJlX3dpZHRoKTtcXG4gICAgICAgICAgICBpbnQgcCA9IGNhbE1vZChpZHgsIG51bV9wcmlvcnMpO1xcbiAgICAgICAgICAgIGludCBtID0gXCIrKHkubGVuZ3RoPjApK1wiID8gaW50KHAgLyAoYXNfbnVtICsgMSkpIDogaW50KHAgLyBhc19udW0pO1xcbiAgICAgICAgICAgIGZsb2F0IGN4ID0gKGZsb2F0KHcpICsgb2Zmc2V0KSAqIHN0ZXBfd2lkdGg7XFxuICAgICAgICAgICAgZmxvYXQgY3kgPSAoZmxvYXQoaCkgKyBvZmZzZXQpICogc3RlcF9oZWlnaHQ7XFxuICAgICAgICAgICAgZmxvYXQgbWluX3NpemUgPSBnZXRWYWx1ZUZyb21BcnJCeUluZGV4X21pbl9zaXplcyhtaW5fc2l6ZXMsIG0pO1xcbiAgICAgICAgICAgIGZsb2F0IGJ3ID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGJoID0gMC4wO1xcblxcbiAgICAgICAgICAgIFwiKyh5Lmxlbmd0aD4wP1wiXFxuICAgICAgICAgICAgaW50IHMgPSBjYWxNb2QocCwgYXNfbnVtICsgMSk7XFxuICAgICAgICAgICAgaWYgKFwiKyFBK1wiKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzIDwgYXNfbnVtKSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhciA9IGdldFZhbHVlRnJvbUFyckJ5SW5kZXhfYXNwZWN0X3JhdGlvcyhhc3BlY3RfcmF0aW9zLCBzKTtcXG4gICAgICAgICAgICAgICAgICAgIGJ3ID0gbWluX3NpemUgKiBhciAvIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGJoID0gbWluX3NpemUgLyBhciAvIDIuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heF9zaXplID0gZ2V0VmFsdWVGcm9tQXJyQnlJbmRleF9tYXhfc2l6ZXMobWF4X3NpemVzLCBtKTtcXG4gICAgICAgICAgICAgICAgICAgIGJ3ID0gc3FydChtaW5fc2l6ZSAqIG1heF9zaXplKSAvIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGJoID0gYnc7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmIChzID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGJoID0gbWluX3NpemUgLyAyLjA7XFxuICAgICAgICAgICAgICAgICAgICBidyA9IGJoO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWF4X3NpemUgPSBnZXRWYWx1ZUZyb21BcnJCeUluZGV4X21heF9zaXplcyhtYXhfc2l6ZXMsIG0pO1xcbiAgICAgICAgICAgICAgICAgICAgYncgPSBzcXJ0KG1pbl9zaXplICogbWF4X3NpemUpIC8gMi4wO1xcbiAgICAgICAgICAgICAgICAgICAgYmggPSBidztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGFyID0gZ2V0VmFsdWVGcm9tQXJyQnlJbmRleF9hc3BlY3RfcmF0aW9zKGFzcGVjdF9yYXRpb3MsIHMgLSAxKTtcXG4gICAgICAgICAgICAgICAgICAgIGJ3ID0gbWluX3NpemUgKiBzcXJ0KGFyKSAvIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGJoID0gbWluX3NpemUgLyBzcXJ0KGFyKSAvIDIuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cIjpcIlxcbiAgICAgICAgICAgIGludCBzID0gY2FsTW9kKHAsIGFzX251bSk7XFxuICAgICAgICAgICAgZmxvYXQgYXIgPSBnZXRWYWx1ZUZyb21BcnJCeUluZGV4X2FzcGVjdF9yYXRpb3MoYXNwZWN0X3JhdGlvcywgcyk7XFxuICAgICAgICAgICAgYncgPSBtaW5fc2l6ZSAqIGFyIC8gMi4wO1xcbiAgICAgICAgICAgIGJoID0gbWluX3NpemUgLyBhciAvIDIuMDtcXG4gICAgICAgIFwiKStcIlxcbiAgICAgICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgICAgICBpZiAod3cgPT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXMgPSAoY3ggLSBidykgLyBpbV93aWR0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAod3cgPT0gMSkge1xcbiAgICAgICAgICAgICAgICByZXMgPSAoY3kgLSBiaCkgLyBpbV9oZWlnaHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKHd3ID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcmVzID0gKGN4ICsgYncpIC8gaW1fd2lkdGg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXMgPSAoY3kgKyBiaCkgLyBpbV9oZWlnaHQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIFwiK2orXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzKSk7XFxuICAgICAgICB9XFxuICAgICAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntpbWFnZTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltdfTtjb25zdCBGbj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtmb3IodmFyIG89bi5vdXQsdD1mdW5jdGlvbihuLGUpe3ZhciBvPXt9O2Zvcih2YXIgdCBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHQpJiZlLmluZGV4T2YodCk8MCYmKG9bdF09blt0XSk7aWYobnVsbCE9biYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9MDtmb3IodD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG4pO3I8dC5sZW5ndGg7cisrKWUuaW5kZXhPZih0W3JdKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobix0W3JdKSYmKG9bdFtyXV09blt0W3JdXSl9cmV0dXJuIG99KG4sW1wib3V0XCJdKSxyPXQub3JpZ2luLGk9ci53aWR0aF9zaGFwZSxzPXIuaGVpZ2h0X3NoYXBlLGE9ci5jaGFubmVsLHU9ci50b3RhbF9zaGFwZSxsPXIubGVuZ3RoX3VuZm9ybWF0dGVkX3NoYXBlLGY9W3UvKGkqcyphKSxhLHMsaV0uc2xpY2UoNC1sKSxjPU9iamVjdC5rZXlzKHQpLmxlbmd0aCxfPWUuYXhpczwwP2UuYXhpcytmLmxlbmd0aCsxOmUuYXhpcyxnPTEsaD0xLGQ9MDtkPF87ZCsrKWcqPWZbZF07Zm9yKGQ9XztkPGYubGVuZ3RoO2QrKyloKj1mW2RdO3ZhciBwPW8udG90YWxfc2hhcGUvZyxtPVwiXCI7cmV0dXJuIG09QXJyYXkuZnJvbShBcnJheShjKS5rZXlzKCkpLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbisoMD09PWU/XCJcXG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfb3JpZ2luKGopO1xcbiAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihjby5yLCBjby5nLCBjby5iLCBjby5hKTtcXG4gICAgICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgICBlbHNlIGlmIChpID09IFwiK2UrXCIpIHtcXG4gICAgICAgICAgICAgICAgaXZlYzQgY28gPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW5fXCIrZStcIihqKTtcXG4gICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW5fXCIrZStcIihjby5yLCBjby5nLCBjby5iLCBjby5hKTtcXG4gICAgICAgICAgICB9XCIpfSksbSksXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgaW50IHN1bVZhbCA9IG9Qb3MuYVxcbiAgICAgICAgICAgICsgb1Bvcy5iICogXCIrby53aWR0aF9zaGFwZStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5nICogXCIrby5oZWlnaHRfc2hhcGUrXCIgKiBcIitvLndpZHRoX3NoYXBlK1wiXFxuICAgICAgICAgICAgKyBvUG9zLnIgKiBcIitvLmNoYW5uZWwrXCIgKiBcIitvLndpZHRoX3NoYXBlK1wiICogXCIrby5oZWlnaHRfc2hhcGUrXCI7XFxuXFxuICAgICAgICBpbnQgaW5kZXggPSBjYWxNb2Qoc3VtVmFsLCBcIitwK1wiKTtcXG5cXG4gICAgICAgIGludCBsYXllciA9IHN1bVZhbCAvIFwiK3ArXCI7XFxuXFxuICAgICAgICBpbnQgaSA9IGluZGV4IC8gXCIraCtcIjtcXG4gICAgICAgIGludCBqID0gY2FsTW9kKGluZGV4LCBcIitoK1wiKSArIGxheWVyICogXCIraCtcIjtcXG5cXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBcIittK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e1wiQGFsbFwiOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiLFwiZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhcIl19fSxibj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm91dCx0PW4ub3JpZ2luLHI9ZS5heGVzLGk9ZS5zdGFydHMscz1lLmVuZHMsYT1lLmRlY3JlYXNlX2F4aXM7aWYoci5sZW5ndGg+MXx8aS5sZW5ndGg+MXx8cy5sZW5ndGg+MXx8YSYmMD09PWEubGVuZ3RoKXRocm93IEVycm9yKFwiW3NsaWNlIG9wIGZlYXR1cmVdOiBjdXJyZW50IHN1cHBvcnQgb25lIGRpbSwgc3VwcG9ydCBkZWNyZWFzZV9heGlzXCIpO3ZhciB1PXQud2lkdGhfc2hhcGUsbD10LmhlaWdodF9zaGFwZSxmPXQuY2hhbm5lbCxjPXQudG90YWxfc2hhcGUsZz10Lmxlbmd0aF91bmZvcm1hdHRlZF9zaGFwZSxoPVtjLyh1KmwqZiksZixsLHVdLG09clswXTtpZihtPDAmJihtPW0rZysxKSw0IT09KG09NC1nK20pKXRocm93IEVycm9yKFwiW3NsaWNlIG9wIGZlYXR1cmVdOiB1bnN1cHBvcnQgYXhpcyB2YWx1ZVwiKTtmb3IodmFyIFA9aVswXSx2PXNbMF0seD1oWzBdLFQ9aFsxXSxGPWhbMl0sYj1oWzNdLHk9W10sRT1QO0U8djtFKyspZm9yKHZhciB3PTA7dzx4O3crKylmb3IodmFyIFY9MDtWPFQ7VisrKWZvcih2YXIgQT0wO0E8RjtBKyspeS5wdXNoKHcqVCpGKmIrVipGKmIrQSpiK0UpO3ZhciBPPWQoeSxcImFyclwiLF8uSU5UX1RZUEUpO3JldHVyblwiXFxuICAgIFwiK3AoeSxcImFyclwiLF8uSU5UX1RZUEUpK1wiXFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBcIitPK1wiXFxuXFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGludCBzdW1WYWwgPSBvUG9zLmFcXG4gICAgICAgICAgICArIG9Qb3MuYiAqIFwiK28ud2lkdGhfc2hhcGUrXCJcXG4gICAgICAgICAgICArIG9Qb3MuZyAqIFwiK28uaGVpZ2h0X3NoYXBlK1wiICogXCIrby53aWR0aF9zaGFwZStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5yICogXCIrby5jaGFubmVsK1wiICogXCIrby53aWR0aF9zaGFwZStcIiAqIFwiK28uaGVpZ2h0X3NoYXBlK1wiO1xcblxcbiAgICAgICAgaW50IGluZGV4ID0gZ2V0VmFsdWVGcm9tQXJyQnlJbmRleF9hcnIoYXJyLCBzdW1WYWwpO1xcblxcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgaXZlYzQgY28gPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW4oaW5kZXgpO1xcbiAgICAgICAgcmVzID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihjby5yLCBjby5nLCBjby5iLCBjby5hKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCIsXCJnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleFwiXX19O3ZhciB5bj17YXJnX21heDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PWUuYXhpcyxyPXZvaWQgMD09PXQ/LTE6dCxpPWUuZmxhdHRlbixzPW8udG90YWxfc2hhcGUsYT1vLmhlaWdodF9zaGFwZSx1PW8ud2lkdGhfc2hhcGUsbD1vLmNoYW5uZWwsZj1vLmxlbmd0aF91bmZvcm1hdHRlZF9zaGFwZSxjPXMvKHUqYSpsKSxfPXI8MD8zOjQtZityLGc9W2MsbCxhLHVdW19dO3JldHVyblwiXFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBpbnQgcG9zID0gMDtcXG4gICAgICAgIGlmIChcIishaStcIikge1xcbiAgICAgICAgICAgIGlmIChcIitfK1wiID09IDEpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIDAsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK2crXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgaW5kZXgsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChcIitfK1wiID09IDIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIG9Qb3MuYiwgMCwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK2crXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBpbmRleCwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChcIitfK1wiID09IDMpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hLCAwKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK2crXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEsIGluZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbigwLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK2crXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGluZGV4LCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XFxuICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbigwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgICBmb3IgKGludCBuID0gMDsgbiA8IFwiK2MrXCI7IG4rKykge1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjID0gMDsgYyA8IFwiK2wrXCI7IGMrKykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaCA9IDA7IGggPCBcIithK1wiOyBoKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCB3ID0gMDsgdyA8IFwiK3UrXCI7IHcrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihuLCBjLCBoLCB3KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPiB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG87XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChwb3MpKTtcXG4gICAgfVwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxhcmdfbWluOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe2Zvcih2YXIgbz1uLm9yaWdpbix0PWUuYXhpcyxyPXZvaWQgMD09PXQ/LTE6dCxpPWUuZmxhdHRlbixzPW8udG90YWxfc2hhcGUsYT1vLmhlaWdodF9zaGFwZSx1PW8ud2lkdGhfc2hhcGUsbD1vLmNoYW5uZWwsZj1zLyh1KmEqbCksYz1bZixsLGEsdV0sXz0wLGc9MDtnPDQmJiEoY1tnXT4xKTtnKyspXysrO3ZhciBoPXI8MD80LV8rcjpyLGQ9Y1toPV8raF07cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIGludCBwb3MgPSAwO1xcbiAgICAgICAgaWYgKFwiKyFpK1wiKSB7XFxuICAgICAgICAgICAgaWYgKFwiK2grXCIgPT0gMSkge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgMCwgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZCtcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBpbmRleCwgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKFwiK2grXCIgPT0gMikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCAwLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZCtcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBvUG9zLmIsIGluZGV4LCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKFwiK2grXCIgPT0gMykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEsIDApO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZCtcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSwgaW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9ICAgICBcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHRtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oMCwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGluZGV4ID0gMDsgaW5kZXggPCBcIitkK1wiOyBpbmRleCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihpbmRleCwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobyA8IHRtcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG87XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xcbiAgICAgICAgICAgIGZsb2F0IHRtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oMCwgMCwgMCwgMCk7XFxuICAgICAgICAgICAgZm9yIChpbnQgbiA9IDA7IG4gPCBcIitmK1wiOyBuKyspIHtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBcIitsK1wiOyBjKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGggPSAwOyBoIDwgXCIrYStcIjsgaCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgdyA9IDA7IHcgPCBcIit1K1wiOyB3KyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4obiwgYywgaCwgdyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvIDwgdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQocG9zKSk7XFxuICAgIH1cIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sY29udjJkOm5uLGNvbnYyZF9wYWNraW5nOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ub3JpZ2luLHQ9bi5maWx0ZXIscj1uLm91dCxpPW4uYmlhcyxzPWUuZ3JvdXBzLGE9dm9pZCAwPT09cz8xOnMsdT1lLnN0cmlkZXMsbD12b2lkIDA9PT11P1tdOnUsZj1lLnBhZGRpbmdzLGM9dm9pZCAwPT09Zj9bXTpmLF89ZS5kaWxhdGlvbnMsZz12b2lkIDA9PT1fP1tdOl8saD1lLmZ1c2VfcmVsdSxkPWUuYWN0X3R5cGUscD1lLmhhcmRfc3dpc2hfb2Zmc2V0LG09dm9pZCAwPT09cD8zOnAsUD1lLmhhcmRfc3dpc2hfc2NhbGUsdj12b2lkIDA9PT1QPzY6UCx4PWUuaGFyZF9zd2lzaF90aHJlc2hvbGQsVD12b2lkIDA9PT14PzY6eCxGPWxbMF0sYj12b2lkIDA9PT1GPzE6Rix5PWxbMV0sRT12b2lkIDA9PT15PzE6eSx3PWNbMF0sVj12b2lkIDA9PT13PzA6dyxBPWNbMV0sTz12b2lkIDA9PT1BPzA6QSxDPWdbMF0sUj12b2lkIDA9PT1DPzE6QyxTPWdbMV0sST12b2lkIDA9PT1TPzE6UztyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgeCA9IG9Qb3MuYTtcXG4gICAgICAgIGludCBjID0gb1Bvcy5nO1xcbiAgICAgICAgaW50IHkgPSBvUG9zLmI7XFxuICAgICAgICBpbnQgYiA9IG9Qb3MucjtcXG4gICAgICAgIHZlYzQgcmVzID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgaW50IG95ID0geSAqIFwiK2IrXCIgLSBcIitWK1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK3QuaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK28uaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG95ICs9IFwiK1IrXCI7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgb3ggPSB4ICogXCIrRStcIiAtIFwiK08rXCI7XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK3Qud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK28ud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIG94ICs9IFwiK0krXCI7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVs6K6h566XXFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdC5jaGFubmVsK1wiOyBqICs9IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGludCBjMCA9IChjIC8gKFwiK3IuY2hhbm5lbCtcIiAqIDQgLyBcIithK1wiKSkgKiBcIit0LmNoYW5uZWwrXCIgKyBqO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBmVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX2ZpbHRlcihjICogNCwgaiwgZnksIGZ4KTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgb1ZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19vcmlnaW4oYiwgYzAsIG95LCBveCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBwYWNrZWRfaW5kZXggPSAwOyBwYWNrZWRfaW5kZXggPCA0OyBwYWNrZWRfaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWNrZWRfaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuciArPSBkb3QoZlZhbHVlLCBvVmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFja2VkX2luZGV4ID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGMxID0gKChjICsgMSkgLyAoXCIrci5jaGFubmVsK1wiICogNCAvIFwiK2ErXCIpKSAqIFwiK3QuY2hhbm5lbCtcIiArIGo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9WYWx1ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfb3JpZ2luKGIsIGMxLCBveSwgb3gpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX2ZpbHRlcihjICogNCArIDEsIGosIGZ5LCBmeCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5nICs9IGRvdChmVmFsdWUsIG9WYWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYWNrZWRfaW5kZXggPT0gMikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgYzIgPSAoKGMgKyAyKSAvIChcIityLmNoYW5uZWwrXCIgKiA0IC8gXCIrYStcIikpICogXCIrdC5jaGFubmVsK1wiICsgajtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb1ZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19vcmlnaW4oYiwgYzIsIG95LCBveCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZWYWx1ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfZmlsdGVyKGMgKiA0ICsgMiwgaiwgZnksIGZ4KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmIgKz0gZG90KGZWYWx1ZSwgb1ZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhY2tlZF9pbmRleCA9PSAzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBjMyA9ICgoYyArIDMpIC8gKFwiK3IuY2hhbm5lbCtcIiAqIDQgLyBcIithK1wiKSkgKiBcIit0LmNoYW5uZWwrXCIgKyBqO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX29yaWdpbihiLCBjMywgb3ksIG94KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZlZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19maWx0ZXIoYyAqIDQgKyAzLCBqLCBmeSwgZngpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuYSArPSBkb3QoZlZhbHVlLCBvVmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBveCArPSBcIitJK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBveSArPSBcIitSK1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrKGk/XCJyZXMgKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19iaWFzKDAsIGMsIDAsIDApO1wiOlwiXCIpK1wiXFxuXFxuICAgICAgICBpZiAoXCIraCtcIikge1xcbiAgICAgICAgICAgIHJlcyA9IG1heCh2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCksIHJlcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIisoXCJyZWx1NlwiPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICByZXMgPSBtaW4obWF4KHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKSwgcmVzKSwgdmVjNCg2LjAsIDYuMCwgNi4wLCA2LjApKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKFwiKyhcImhhcmRfc3dpc2hcIj09PWQpK1wiKSB7XFxuICAgICAgICAgICAgcmVzID0gcmVzICogbWluKFxcbiAgICAgICAgICAgICAgICBtYXgodmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApLCByZXMgKyB2ZWM0KFwiK20rXCIpKSxcXG4gICAgICAgICAgICAgICAgdmVjNChcIitUK1wiKVxcbiAgICAgICAgICAgICkgLyB2ZWM0KFwiK3YrXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0UGFja2VkT3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7ZmlsdGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdcIl0sYmlhczpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdfSxiZWhhdmlvcnM6W1wiYWRhcHRQYWRkaW5nc1wiLFwiaXNBcHBseVNlcGFyYWJsZUNvbnZcIixcImJhdGNoQ29tcHV0ZUNvbnYyZFwiLFwicHJvY2Vzc0JpYXNcIl19LGNvbnYyZF90cmFuc3Bvc2U6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLmZpbHRlcixyPW4ub3V0LGk9bi5iaWFzLHM9ZS5ncm91cHMsYT12b2lkIDA9PT1zPzE6cyx1PWUuc3RyaWRlcyxsPXZvaWQgMD09PXU/W106dSxmPWUucGFkZGluZ3MsYz12b2lkIDA9PT1mP1tdOmYsXz1lLmRpbGF0aW9ucyxnPXZvaWQgMD09PV8/W106XyxoPWUuZnVzZV9yZWx1LGQ9ZS5hY3RfdHlwZSxwPWxbMF0sbT12b2lkIDA9PT1wPzE6cCxQPWxbMV0sdj12b2lkIDA9PT1QPzE6UCx4PWNbMF0sVD12b2lkIDA9PT14PzA6eCxGPWNbMV0sYj12b2lkIDA9PT1GPzA6RjtiPXQuaGVpZ2h0X3NoYXBlLWItMSxUPXQud2lkdGhfc2hhcGUtVC0xO3ZhciB5PWdbMF0sRT12b2lkIDA9PT15PzE6eSx3PWdbMV0sVj12b2lkIDA9PT13PzE6dztyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgaW50IHggPSBvUG9zLmE7XFxuICAgICAgICBpbnQgYyA9IG9Qb3MuZztcXG4gICAgICAgIGludCB5ID0gb1Bvcy5iO1xcbiAgICAgICAgaW50IGIgPSBvUG9zLnI7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICBpbnQgdGVtcF94ID0gMDtcXG4gICAgICAgIGludCB0ZW1wX3kgPSAwO1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIGZsb2F0IGYgPSAwLjA7XFxuXFxuICAgICAgICAvLyDojrflj5ZvdXRwdXTnmoTlnZDmoIdcXG4gICAgICAgIGludCBvVGVuc29yQ2hhbm5lbCA9IGludChjICogXCIrYStcIiAvIFwiK3IuY2hhbm5lbCtcIikgKiBcIitvLmNoYW5uZWwrXCI7XFxuICAgICAgICBpbnQgb3kgPSB5IC0gXCIrYitcIjtcXG4gICAgICAgIGNvbnN0IGludCBncm91cExlbiA9IGludChcIitvLmNoYW5uZWwrXCIgLyBcIithK1wiKTtcXG4gICAgICAgIGludCBncm91cEluZGV4ID0gaW50KGMgLyBncm91cExlbik7XFxuXFxuICAgICAgICBmb3IgKGludCBmeSA9IDA7IGZ5IDwgXCIrdC5oZWlnaHRfc2hhcGUrXCI7IGZ5KyspIHtcXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG95ICs9IFwiK0UrXCI7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgb3ggPSB4IC0gXCIrVCtcIjtcXG4gICAgICAgICAgICBmb3IgKGludCBmeCA9IDA7IGZ4IDwgXCIrdC53aWR0aF9zaGFwZStcIjsgZngrKykge1xcblxcbiAgICAgICAgICAgICAgICBpZiAob3ggPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBveCArPSBcIitWK1wiO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gY2hhbm5lbOiuoeeul1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGdyb3VwTGVuOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGludCBjdXJJbmRleCA9IGogKyBiICogZ3JvdXBMZW47XFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsTW9kKG94LCBpbnQoXCIrditcIikpID09IDAgJiYgY2FsTW9kKG95LCBpbnQoXCIrbStcIikpID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wX3ggPSBpbnQoZmxvb3IoZmxvYXQob3gpIC8gZmxvYXQoXCIrditcIikpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wX3kgPSBpbnQoZmxvb3IoZmxvYXQob3kpIC8gZmxvYXQoXCIrbStcIikpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcF94IDwgXCIrby53aWR0aF9zaGFwZStcIiAmJiB0ZW1wX3kgPCBcIitvLmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBjdXJJbmRleCAsIHRlbXBfeSwgdGVtcF94KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJJbmRleCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludChjIC8gXCIrYStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIit0LmhlaWdodF9zaGFwZStcIi0xLWZ5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrdC53aWR0aF9zaGFwZStcIi0xLWZ4XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBmICogbztcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb3ggKz0gXCIrVitcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgb3kgKz0gXCIrRStcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgXCIrKGk/XCJyZXMgKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2JpYXMoMCwgMCwgMCwgYyk7XCI6XCJcIikrXCJcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKFwiK2grXCIpIHtcXG4gICAgICAgICAgICByZXMgPSBtYXgoMC4wLCByZXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoXCIrKFwicmVsdTZcIj09PWQpK1wiKSB7XFxuICAgICAgICAgICAgcmVzID0gbWluKG1heCgwLjAsIHJlcyksIDYuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcblwifSx0ZXh0dXJlRnVuY0NvbmY6e2ZpbHRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxiaWFzOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcImFkYXB0UGFkZGluZ3NcIixcImlzQXBwbHlTZXBhcmFibGVDb252XCIsXCJiYXRjaENvbXB1dGVDb252MmRcIixcInByb2Nlc3NCaWFzXCJdfSxkZXB0aHdpc2VfY29udjJkOm5uLGNvbnYyZF9kZXB0aHdpc2U6bm4sY29udjJkX2VsZW1lbnR3aXNlX2FkZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PW4uZmlsdGVyLHI9bi5vdXQsaT1uLmNvdW50ZXIscz1lLmFjdGl2ZV9mdW5jdGlvbixhPWUuZ3JvdXBzLHU9dm9pZCAwPT09YT8xOmEsbD1lLmF4aXMsZj1lLnN0cmlkZXMsYz12b2lkIDA9PT1mP1tdOmYsXz1lLnBhZGRpbmdzLGc9dm9pZCAwPT09Xz9bXTpfLGg9ZS5kaWxhdGlvbnMsZD12b2lkIDA9PT1oP1tdOmgscD1lLm11bHRpX3ZhbHVlLG09ZS5iaWFzX3ZhbHVlLFA9Y1swXSx2PXZvaWQgMD09PVA/MTpQLHg9Y1sxXSxUPXZvaWQgMD09PXg/MTp4LEY9Z1swXSxiPXZvaWQgMD09PUY/MDpGLHk9Z1sxXSxFPXZvaWQgMD09PXk/MDp5LHc9ZFswXSxWPXZvaWQgMD09PXc/MTp3LEE9ZFsxXSxPPXZvaWQgMD09PUE/MTpBO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuXFxuICAgIGZsb2F0IGdldFZhbHVlRnJvbUNvdW50ZXIoaW50IGluZGV4KSB7XFxuICAgICAgICBmbG9hdCB4UG9zID0gZmxvYXQoaW5kZXgpIC8gZmxvYXQoXCIraS53aWR0aF9zaGFwZStcIik7XFxuICAgICAgICB2ZWM0IHBpeGVscyA9IFRFWFRVUkUyRCh0ZXh0dXJlX2NvdW50ZXIsIHZlYzIoeFBvcywgMC41KSk7XFxuICAgICAgICByZXR1cm4gcGl4ZWxzLnI7XFxuICAgIH1cXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG5cXG4gICAgICAgIGludCB4ID0gb1Bvcy5hO1xcbiAgICAgICAgaW50IGMgPSBvUG9zLmc7XFxuICAgICAgICBpbnQgeSA9IG9Qb3MuYjtcXG4gICAgICAgIGludCBiID0gb1Bvcy5yO1xcbiAgICAgICAgaW50IGFkZEF4aXMgPSBvUG9zW1wiK2wrXCJdO1xcbiAgICAgICAgZmxvYXQgcmVzID0gZ2V0VmFsdWVGcm9tQ291bnRlcihhZGRBeGlzKTtcXG5cXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaW50IG9UZW5zb3JDaGFubmVsID0gKGMgLyAoXCIrci5jaGFubmVsK1wiIC8gXCIrdStcIikpICogXCIrdC5jaGFubmVsK1wiO1xcbiAgICAgICAgaW50IG95ID0geSAqIFwiK3YrXCIgLSBcIitiK1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK3QuaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK28uaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG95ICs9IFwiK1YrXCI7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgb3ggPSB4ICogXCIrVCtcIiAtIFwiK0UrXCI7XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK3Qud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK28ud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIG94ICs9IFwiK08rXCI7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVs6K6h566XXFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdC5jaGFubmVsK1wiOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGYgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIGosIGZ5LCBmeCk7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIGosIG95LCBveCk7XFxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZiAqIG87XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb3ggKz0gXCIrTytcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgb3kgKz0gXCIrVitcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIitzK1wiKHJlcywgIFwiK3ArXCIsICBcIittK1wiKSk7XFxuICAgIH1cXG5cIn0sdGV4dHVyZUZ1bmNDb25mOntmaWx0ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJtZXJnZUF0dHJzXCIsXCJjaGVja0lzTWVyZ2VcIixcInNldEFjdGl2ZUZ1bmNcIl19LHBvb2wyZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PWUuc3RyaWRlcyxyPXZvaWQgMD09PXQ/W106dCxpPWUucGFkZGluZ3Mscz12b2lkIDA9PT1pP1tdOmksYT1lLnBvb2xpbmdfdHlwZSx1PWUua3NpemUsbD1yWzBdLGY9dm9pZCAwPT09bD8xOmwsYz1yWzFdLF89dm9pZCAwPT09Yz8xOmMsZz1zWzBdLGg9dm9pZCAwPT09Zz8wOmcsZD1zWzFdLHA9dm9pZCAwPT09ZD8wOmQsbT11WzBdLFA9dVsxXTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgaWYgKFwiK2ErXCIgPT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IC0xLjcwMTQxMTg0ZTM4O1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyBY44CBWeaWueWQkeeahOenu+WKqOatpemVv1xcbiAgICAgICAgaW50IGNvdW50X3Bvb2wgPSAwO1xcbiAgICAgICAgaW50IG95X2Jhc2UgPSBvdXRfcG9zWzJdICogXCIrZitcIiAtIFwiK2grXCI7XFxuICAgICAgICBpbnQgb3hfYmFzZSA9IG91dF9wb3NbM10gKiBcIitfK1wiIC0gXCIrcCtcIjtcXG4gICAgICAgIGZvciAoaW50IGZ5ID0gMDsgZnkgPCBcIittK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaW50IG95ID0gb3lfYmFzZSArIGZ5O1xcbiAgICAgICAgICAgIGlmIChveSA+PSBcIitvLmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG95IDwgMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK1ArXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaW50IG94ID0gb3hfYmFzZSArIGZ4O1xcbiAgICAgICAgICAgICAgICBpZiAob3ggPj0gXCIrby53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2lu5pWw5o2uXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG91dF9wb3NbMF0sIG91dF9wb3NbMV0sIG95LCBveCk7XFxuICAgICAgICAgICAgICAgIGlmIChcIithK1wiID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID4gcmVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gY3VycjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBjdXJyO1xcbiAgICAgICAgICAgICAgICAgICAgLy8g5Zyo5bmz5Z2H5rGg5YyW5qih5byP5b+955Wl5aGr5YWF5YC8KGV4Y2x1c2l2Zem7mOiupOS4unRydWXvvIlcXG4gICAgICAgICAgICAgICAgICAgIGNvdW50X3Bvb2wrKztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcIithK1wiICE9IDEpIHtcXG4gICAgICAgICAgICByZXMgPSByZXMgLyBmbG9hdChjb3VudF9wb29sKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJpc01heFwiLFwic2V0UGFja2VkXCIsXCJzZXRBZGFwdGl2ZVwiLFwiaXNHbG9iYWxQb29saW5nXCJdfSxwb29sMmRfbWF4OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ub3JpZ2luLHQ9ZS5zdHJpZGVzLHI9dm9pZCAwPT09dD9bXTp0LGk9ZS5wYWRkaW5ncyxzPXZvaWQgMD09PWk/W106aSxhPWUua3NpemUsdT1lLmdsb2JhbF9wb29saW5nLGw9ZS5ydW50aW1lLGY9clswXSxjPXZvaWQgMD09PWY/MTpmLF89clsxXSxnPXZvaWQgMD09PV8/MTpfLGg9c1swXSxkPXZvaWQgMD09PWg/MDpoLHA9c1sxXSxtPXZvaWQgMD09PXA/MDpwLFA9YVswXSx2PWFbMV0seD1mdW5jdGlvbihuKXt2YXIgZT1uLnRvdGFsX3NoYXBlLG89bi5jaGFubmVsLHQ9bi5oZWlnaHRfc2hhcGUscj1uLndpZHRoX3NoYXBlO3JldHVybltlL28vdC9yLG8sdCxyXX0obyksVD1cIlwiLEY9XCJzZXRPdXRwdXQoZmxvYXQocmVzKSk7XCI7cmV0dXJuIDA9PT1sJiYhMD09PXUmJihUPVwiXFxuICAgICAgICAgICAgaWYgKGN1cnIgPiByZXMpIHtcXG4gICAgICAgICAgICAgICAgaW5kZXggPSBcIit4WzJdKnhbM10rXCIgKiBvdXRfcG9zWzFdICsgXCIreFszXStcIiAqIG95ICsgb3g7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIsRj1cInNldE91dHB1dChmbG9hdChpbmRleCkpO1wiKSxcIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gLTEuNzAxNDExODRlMzg7XFxuICAgICAgICBpbnQgaW5kZXggPSAwO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgYiA9IG91dF9wb3NbMF07XFxuICAgICAgICBpbnQgYyA9IG91dF9wb3NbMV07XFxuICAgICAgICBpbnQgeSA9IG91dF9wb3NbMl07XFxuICAgICAgICBpbnQgeCA9IG91dF9wb3NbM107XFxuICAgICAgICAvLyBY44CBWeaWueWQkeeahOenu+WKqOatpemVv1xcbiAgICAgICAgaW50IG95X2Jhc2UgPSBvdXRfcG9zWzJdICogXCIrYytcIiAtIFwiK2QrXCI7XFxuICAgICAgICBpbnQgb3hfYmFzZSA9IG91dF9wb3NbM10gKiBcIitnK1wiIC0gXCIrbStcIjtcXG4gICAgICAgIGZvciAoaW50IGZ5ID0gMDsgZnkgPCBcIitQK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaW50IG95ID0gb3lfYmFzZSArIGZ5O1xcbiAgICAgICAgICAgIGlmIChveSA+PSBcIitvLmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG95IDwgMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK3YrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaW50IG94ID0gb3hfYmFzZSArIGZ4O1xcbiAgICAgICAgICAgICAgICBpZiAob3ggPj0gXCIrby53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2lu5pWw5o2uXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG91dF9wb3NbMF0sIG91dF9wb3NbMV0sIG95LCBveCk7XFxuICAgICAgICAgICAgICAgIFwiK1QrXCJcXG4gICAgICAgICAgICAgICAgcmVzID0gbWF4KHJlcywgY3Vycik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXCIrRitcIlxcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJpc01heFwiLFwic2V0UGFja2VkXCIsXCJzZXRBZGFwdGl2ZVwiLFwiaXNHbG9iYWxQb29saW5nXCJdfSxwb29sMmRfd2lub2dyYWQ6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLnBvb2wscj1lLnN0cmlkZXMsaT12b2lkIDA9PT1yP1tdOnIscz1lLnBhZGRpbmdzLGE9dm9pZCAwPT09cz9bXTpzLHU9ZS50eXBlX3Bvb2wsbD1pWzBdLGY9dm9pZCAwPT09bD8xOmwsYz1pWzFdLF89dm9pZCAwPT09Yz8xOmMsZz1hWzBdLGg9dm9pZCAwPT09Zz8wOmcsZD1hWzFdLHA9dm9pZCAwPT09ZD8wOmQsbT1vLmhlaWdodF9zaGFwZSxQPW8ud2lkdGhfdGV4dHVyZSx2PW8uaGVpZ2h0X3RleHR1cmU7cmV0dXJuXCJcXG5cXG4gICAgZmxvYXQgZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2VkX29yaWdpbihpbnQgciwgaW50IGcsIGludCBiLCBpbnQgYSkge1xcbiAgICAgICAgaW50IHkgPSBiIC8gMjtcXG4gICAgICAgIGludCB5T2Zmc2V0ID0gY2FsTW9kKGIsIDIpO1xcbiAgICAgICAgaW50IHggPSBhIC8gMjtcXG4gICAgICAgIGludCB4T2Zmc2V0ID0gY2FsTW9kKGEsIDIpO1xcbiAgICAgICAgaW50IGhlaWdodCA9IFwiK20rXCIgKyBcIitvLm9mZnNldF95K1wiO1xcbiAgICAgICAgdmVjNCBwaXhlbHMgPSBURVhUVVJFMkQoXFxuICAgICAgICAgICAgdGV4dHVyZV9vcmlnaW4sXFxuICAgICAgICAgICAgdmVjMigoZmxvYXQoeCkgKyAwLjUpIC8gZmxvYXQoXCIrUCtcIiksXFxuICAgICAgICAgICAgKGZsb2F0KGcgKiBoZWlnaHQgLyAyICsgeSkgKyAwLjUpIC8gZmxvYXQoXCIrditcIikpXFxuICAgICAgICApO1xcbiAgICAgICAgaW50IGluZGV4ID0gMDtcXG4gICAgICAgIGlmICh4T2Zmc2V0ID09IDAgJiYgeU9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHBpeGVsc1swXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHhPZmZzZXQgPT0gMSAmJiB5T2Zmc2V0ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzWzFdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoeE9mZnNldCA9PSAwICYmIHlPZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiBwaXhlbHNbMl07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcGl4ZWxzWzNdO1xcbiAgICB9XFxuXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAoLTEuMCAvIGV4cCgtMjAuMCkpO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyBpbnQgYiA9IG91dF9wb3NbMF07XFxuICAgICAgICAvLyBpbnQgYyA9IG91dF9wb3NbMV07XFxuICAgICAgICAvLyBpbnQgeSA9IG91dF9wb3NbMl07XFxuICAgICAgICAvLyBpbnQgeCA9IG91dF9wb3NbM107XFxuICAgICAgICAvLyBY44CBWeaWueWQkeeahOenu+WKqOatpemVv1xcbiAgICAgICAgaW50IGNvdW50X3Bvb2wgPSAwO1xcbiAgICAgICAgaW50IG95X2Jhc2UgPSBvdXRfcG9zWzJdICogXCIrZitcIiAtIFwiK2grXCI7XFxuICAgICAgICBpbnQgb3hfYmFzZSA9IG91dF9wb3NbM10gKiBcIitfK1wiIC0gXCIrcCtcIjtcXG5cXG4gICAgICAgIGZvciAoaW50IGZ5ID0gMDsgZnkgPCBcIit0LmhlaWdodF9zaGFwZStcIjsgZnkrKykge1xcbiAgICAgICAgICAgIGludCBveSA9IG95X2Jhc2UgKyBmeTtcXG4gICAgICAgICAgICBpZiAob3kgPj0gXCIrby5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChveSA8IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAoaW50IGZ4ID0gMDsgZnggPCBcIit0LndpZHRoX3NoYXBlK1wiOyBmeCsrKSB7XFxuICAgICAgICAgICAgICAgIGludCBveCA9IG94X2Jhc2UgKyBmeDtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK28ud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbuaVsOaNrlxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2VkX29yaWdpbihvdXRfcG9zWzBdLCBvdXRfcG9zWzFdLCBveSwgb3gpO1xcbiAgICAgICAgICAgICAgICBpZiAoXCIrdStcIiA9PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyciA+IHJlcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGN1cnI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gY3VycjtcXG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqOW5s+Wdh+axoOWMluaooeW8j+W/veeVpeWhq+WFheWAvChleGNsdXNpdmXpu5jorqTkuLp0cnVl77yJXFxuICAgICAgICAgICAgICAgICAgICBjb3VudF9wb29sKys7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoXCIrdStcIiAhPSAxKSB7XFxuICAgICAgICAgICAgcmVzID0gcmVzIC8gZmxvYXQoY291bnRfcG9vbCk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sYmVoYXZpb3JzOltcImlzTWF4XCIsXCJzZXRQYWNrZWRcIixcInNldEFkYXB0aXZlXCIsXCJpc0dsb2JhbFBvb2xpbmdcIl19LGVsZW1lbnR3aXNlX2FkZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1lLmNvdW50ZXJQb3MsdD1lLlNjYWxlX3kscj12b2lkIDA9PT10PzE6dCxpPWUuU2NhbGVfeCxzPXZvaWQgMD09PWk/MTppLGE9ZS5TY2FsZV9vdXQsdT12b2lkIDA9PT1hPzE6YTtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcblxcbiAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKFwiK28rXCIpO1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrdS9yK1wiKSAqIGMgKyBmbG9hdChcIit1L3MrXCIpICogbztcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wicHJvY2Vzc0VsZW1lbnR3aXNlQXhpc1wiLFwiZ2VuRWxlbWVudHdpc2VDb3VudGVyUG9zXCJdfSxlbGVtZW50d2lzZV9tdWw6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5jb3VudGVyLHQ9ZS5jb3VudGVyUG9zLHI9ZS5TY2FsZV95LGk9dm9pZCAwPT09cj8xOnIscz1lLlNjYWxlX3gsYT12b2lkIDA9PT1zPzE6cyx1PWUuU2NhbGVfb3V0LGw9dm9pZCAwPT09dT8xOnU7cmV0dXJuXCJcXG4gICAgaXZlYzQgZm9ybWF0TkNIVyhpbnQgbiwgaW50IGMsIGludCBoLCBpbnQgdykge1xcbiAgICAgICAgaW50IG5ld04gPSBuO1xcbiAgICAgICAgaW50IG5ld0MgPSBjO1xcbiAgICAgICAgaW50IG5ld0ggPSBoO1xcbiAgICAgICAgaW50IG5ld1cgPSB3O1xcblxcbiAgICAgICAgaWYgKG4gPj0gXCIrby5oZWlnaHRfdGV4dHVyZS9vLmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld04gPSBpbnQoXCIrby5oZWlnaHRfdGV4dHVyZS9vLmhlaWdodF9zaGFwZStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYyA+PSBcIitvLmNoYW5uZWwrXCIpIHtcXG4gICAgICAgICAgICBuZXdDID0gaW50KFwiKyhvLmNoYW5uZWwtMSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGggPj0gXCIrby5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICBuZXdIID0gXCIrKG8uaGVpZ2h0X3NoYXBlLTEpK1wiO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHcgPj0gXCIrby53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld1cgPSBcIisoby53aWR0aF9zaGFwZS0xKStcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdmVjNChuZXdOLCBuZXdDLCBuZXdILCBuZXdXKTtcXG4gICAgfVxcblxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MxID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zMS5yLCBvUG9zMS5nLCBvUG9zMS5iLCBvUG9zMS5hKTtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBmb3JtYXROQ0hXKG9Qb3MxLnIsIG9Qb3MxLmcsIG9Qb3MxLmIsIG9Qb3MxLmEpO1xcblxcbiAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKFwiK3QrXCIpO1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrbC9hK1wiKSAqIG8gKiBmbG9hdChcIisxL2krXCIpICogYztcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcblxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wicHJvY2Vzc0VsZW1lbnR3aXNlQXhpc1wiLFwiZ2VuRWxlbWVudHdpc2VDb3VudGVyUG9zXCJdfSxlbGVtZW50d2lzZV9kaXY6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5jb3VudGVyLHQ9ZS5jb3VudGVyUG9zLHI9ZS5TY2FsZV95LGk9dm9pZCAwPT09cj8xOnIscz1lLlNjYWxlX3gsYT12b2lkIDA9PT1zPzE6cyx1PWUuU2NhbGVfb3V0LGw9dm9pZCAwPT09dT8xOnU7cmV0dXJuXCJcXG4gICAgaXZlYzQgZm9ybWF0TkNIVyhpbnQgbiwgaW50IGMsIGludCBoLCBpbnQgdykge1xcbiAgICAgICAgaW50IG5ld04gPSBuO1xcbiAgICAgICAgaW50IG5ld0MgPSBjO1xcbiAgICAgICAgaW50IG5ld0ggPSBoO1xcbiAgICAgICAgaW50IG5ld1cgPSB3O1xcblxcbiAgICAgICAgaWYgKG4gPj0gXCIrby5oZWlnaHRfdGV4dHVyZS9vLmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld04gPSBpbnQoXCIrby5oZWlnaHRfdGV4dHVyZS9vLmhlaWdodF9zaGFwZStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYyA+PSBcIitvLmNoYW5uZWwrXCIpIHtcXG4gICAgICAgICAgICBuZXdDID0gaW50KFwiKyhvLmNoYW5uZWwtMSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGggPj0gXCIrby5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICBuZXdIID0gXCIrKG8uaGVpZ2h0X3NoYXBlLTEpK1wiO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHcgPj0gXCIrby53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld1cgPSBcIisoby53aWR0aF9zaGFwZS0xKStcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpdmVjNChuZXdOLCBuZXdDLCBuZXdILCBuZXdXKTtcXG4gICAgfVxcblxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MxID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zMS5yLCBvUG9zMS5nLCBvUG9zMS5iLCBvUG9zMS5hKTtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBmb3JtYXROQ0hXKG9Qb3MxLnIsIG9Qb3MxLmcsIG9Qb3MxLmIsIG9Qb3MxLmEpO1xcblxcbiAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKFwiK3QrXCIpO1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrbCtcIikgKiAoZmxvYXQoXCIrMS9hK1wiKSAqIG8gLyAoZmxvYXQoXCIrMS9pK1wiKSAqIGMpKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcblxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wicHJvY2Vzc0VsZW1lbnR3aXNlQXhpc1wiLFwiZ2VuRWxlbWVudHdpc2VDb3VudGVyUG9zXCJdfSxlbGVtZW50d2lzZV9wb3c6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89ZS5jb3VudGVyUG9zLHQ9ZS5TY2FsZV95LHI9dm9pZCAwPT09dD8xOnQsaT1lLlNjYWxlX3gscz12b2lkIDA9PT1pPzE6aSxhPWUuU2NhbGVfb3V0LHU9dm9pZCAwPT09YT8xOmE7cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG5cXG4gICAgICAgIGZsb2F0IGMgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY291bnRlcihcIitvK1wiKTtcXG4gICAgICAgIGZsb2F0IHJlcyA9IHBvdyhmbG9hdChcIit1L3MrXCIpICogbywgZmxvYXQoXCIrdS9yK1wiKSAqIGMpO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2NvdW50ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJwcm9jZXNzRWxlbWVudHdpc2VBeGlzXCIsXCJnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3NcIl19LGVsZW1lbnR3aXNlX3N1Yjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1lLmNvdW50ZXJQb3MsdD1lLlNjYWxlX3kscj12b2lkIDA9PT10PzE6dCxpPWUuU2NhbGVfeCxzPXZvaWQgMD09PWk/MTppLGE9ZS5TY2FsZV9vdXQsdT12b2lkIDA9PT1hPzE6YTtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcblxcbiAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKFwiK28rXCIpO1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrdS9zK1wiKSAqIG8gLSBmbG9hdChcIit1L3IrXCIpICogYztcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wicHJvY2Vzc0VsZW1lbnR3aXNlQXhpc1wiLFwiZ2VuRWxlbWVudHdpc2VDb3VudGVyUG9zXCJdfSxtdWw6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLmNvdW50ZXIscj1lLnhfbnVtX2NvbF9kaW1zLGk9ZS55X251bV9jb2xfZGltcyxzPXJuKG8pLGE9cm4odCksdT1lbihzLHIpLGw9dVswXSxmPXVbMV0sYz11WzJdLF89dVszXSxnPXVbNF0saD1lbihhLGkpLGQ9aFswXSxwPWhbMV0sbT1oWzJdLFA9aFszXTtyZXR1cm5cIlxcbiAgICBcIitvbihcIngxXCIsbCxmKStcIlxcbiAgICBcIitvbihcIngyXCIsYyxfKStcIlxcbiAgICBcIitvbihcInkxXCIsZCxwKStcIlxcbiAgICBcIitvbihcInkyXCIsbSxQKStcIlxcblxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcblxcbiAgICAgICAgLy8gb3V0cHV0IGlzIDJEXFxuICAgICAgICBpbnQgYiA9IG9wb3MuYjtcXG4gICAgICAgIGludCBhID0gb3Bvcy5hO1xcblxcbiAgICAgICAgXCIrdG4oZikrXCIgeDEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF94MShiKTtcXG4gICAgICAgIFwiK3RuKFApK1wiIHkyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeTIoYSk7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2dbMV0rXCI7IGorKykge1xcbiAgICAgICAgICAgIFwiK3RuKF8pK1wiIHgyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeDIoaik7XFxuICAgICAgICAgICAgXCIrdG4ocCkrXCIgeTEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF95MShqKTtcXG5cXG4gICAgICAgICAgICBpdmVjNCB4UG9zID0gaXZlYzQoXCIrdG4oZikrXCIoeDEpLCBcIit0bihfKStcIih4MikpO1xcbiAgICAgICAgICAgIGl2ZWM0IHlQb3MgPSBpdmVjNChcIit0bihwKStcIih5MSksIFwiK3RuKFApK1wiKHkyKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oeFBvcy5yLCB4UG9zLmcsIHhQb3MuYiwgeFBvcy5hKTtcXG4gICAgICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoeVBvcy5yLCB5UG9zLmcsIHlQb3MuYiwgeVBvcy5hKTtcXG4gICAgICAgICAgICByZXMgKz0gYyAqIG87XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sbWF0bXVsOnNuLG1hdG11bF92MjpzbixmYzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PW4ud2VpZ2h0LHI9ZS54X251bV9jb2xfZGltcyxpPWUueV9udW1fY29sX2RpbXMscz1mbihvKSxhPWZuKHQpLHU9YW4ocyxyKSxsPXVbMF0sZj11WzFdLGM9dVsyXSxfPXVbM10sZz11WzRdLGg9YW4oYSxpKSxkPWhbMF0scD1oWzFdLG09aFsyXSxQPWhbM107cmV0dXJuXCJcXG4gICAgXCIrdW4oXCJ4MVwiLGwsZikrXCJcXG4gICAgXCIrdW4oXCJ4MlwiLGMsXykrXCJcXG4gICAgXCIrdW4oXCJ5MVwiLGQscCkrXCJcXG4gICAgXCIrdW4oXCJ5MlwiLG0sUCkrXCJcXG5cXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgYmlhcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19iaWFzKG9wb3Muciwgb3Bvcy5nLCBvcG9zLmIsIG9wb3MuYSk7XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcblxcbiAgICAgICAgLy8gb3V0cHV0IGlzIDJEXFxuICAgICAgICBpbnQgYiA9IG9wb3MuYjtcXG4gICAgICAgIGludCBhID0gb3Bvcy5hO1xcblxcbiAgICAgICAgXCIrbG4oZikrXCIgeDEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF94MShiKTtcXG4gICAgICAgIFwiK2xuKFApK1wiIHkyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeTIoYSk7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2dbMV0rXCI7IGorKykge1xcbiAgICAgICAgICAgIFwiK2xuKF8pK1wiIHgyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeDIoaik7XFxuICAgICAgICAgICAgXCIrbG4ocCkrXCIgeTEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF95MShqKTtcXG5cXG4gICAgICAgICAgICBpdmVjNCB4UG9zID0gaXZlYzQoXCIrbG4oZikrXCIoeDEpLCBcIitsbihfKStcIih4MikpO1xcbiAgICAgICAgICAgIGl2ZWM0IHlQb3MgPSBpdmVjNChcIitsbihwKStcIih5MSksIFwiK2xuKFApK1wiKHkyKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oeFBvcy5yLCB4UG9zLmcsIHhQb3MuYiwgeFBvcy5hKTtcXG4gICAgICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3dlaWdodCh5UG9zLnIsIHlQb3MuZywgeVBvcy5iLCB5UG9zLmEpO1xcbiAgICAgICAgICAgIHJlcyArPSBjICogbztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJlcyA9IHJlcyArIGJpYXM7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOnt3ZWlnaHQ6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sYmlhczpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxkcm9wb3V0OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgaWYgKFwiKyhcImRvd25ncmFkZV9pbl9pbmZlclwiPT09ZS5kcm9wb3V0X2ltcGxlbWVudGF0aW9uKStcIikge1xcbiAgICAgICAgICAgIG8gPSBvICogKDEuMCAtIGZsb2F0KFwiK2UuZHJvcG91dF9wcm9iK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxjb25jYXQ6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89ZS5kaW0sdD1PYmplY3Qua2V5cyhuKS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVyblwib3V0XCIhPT1ufSkpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIG5bZV19KSkubWFwKChmdW5jdGlvbihuKXt2YXIgZT1uLndpZHRoX3NoYXBlLHQ9bi5oZWlnaHRfc2hhcGUscj1uLmNoYW5uZWw7cmV0dXJuW24udG90YWxfc2hhcGUvKGUqdCpyKSxyLHQsZV1bb119KSkscj10Lm1hcCgoZnVuY3Rpb24obixlKXtyZXR1cm4gdC5zbGljZSgwLGUrMSkucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuK2V9KSwwKX0pKSxpPVwiXCI7cmV0dXJuIHIuZm9yRWFjaCgoZnVuY3Rpb24obixlKXtpKz0wPT09ZT9cIlxcbiAgICAgICAgICAgIGlmIChvUG9zW1wiK28rXCJdIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcIjpcIlxcbiAgICAgICAgICAgIGVsc2UgaWYgKG9Qb3NbXCIrbytcIl0gPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgIG9Qb3NbXCIrbytcIl0gPSBvUG9zW1wiK28rXCJdIC0gXCIrcltlLTFdK1wiO1xcbiAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbl9cIitlK1wiKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwifSkpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e1wiQGFsbFwiOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm5vcm1hbGl6ZURpbVwiXX0sY29uY2F0X211bDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1lLmRpbSx0PU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuXCJvdXRcIiE9PW59KSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbltlXX0pKS5tYXAoKGZ1bmN0aW9uKG4pe3ZhciBlPW4ud2lkdGhfc2hhcGUsdD1uLmhlaWdodF9zaGFwZSxyPW4uY2hhbm5lbDtyZXR1cm5bbi50b3RhbF9zaGFwZS8oZSp0KnIpLHIsdCxlXVtvXX0pKSxyPXQubWFwKChmdW5jdGlvbihuLGUpe3JldHVybiB0LnNsaWNlKDAsZSsxKS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rZX0pLDApfSkpLGk9XCJcIjtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbihuLGUpe2krPTA9PT1lP1wiXFxuICAgICAgICAgICAgaWYgKG9Qb3NbXCIrbytcIl0gPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgZWxzZSBpZiAob1Bvc1tcIitvK1wiXSA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitvK1wiXSA9IG9Qb3NbXCIrbytcIl0gLSBcIityW2UtMV0rXCI7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luX1wiK2UrXCIob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCJ9KSksXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7XCJAYWxsXCI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wibm9ybWFsaXplRGltXCJdfSxzcGxpdDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1lLnRhcmdldF9sZW5ndGgsdD1lLm51bSxyPWUuZGltLGk9ZS5zZWN0aW9ucztyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaW50IGxlbmd0aCA9IGludChcIisoaSYmaS5sZW5ndGg+MT9pWzBdOm8vdCkrXCIpO1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBvUG9zW1wiK3IrXCJdID0gb1Bvc1tcIityK1wiXSArIGxheWVyX3J1bl90aW1lICogbGVuZ3RoO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm5vcm1hbGl6ZURpbVwiXX0sc29mdG1heDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PWUuYXhpcyxyPXQ7cmV0dXJuKCF0fHx0PDApJiYocj0odHx8LTEpKzQpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBjb25zdCBpbnQgbiA9IGludChcIitvLnRvdGFsX3NoYXBlK1wiL1wiK28uY2hhbm5lbCtcIi9cIitvLmhlaWdodF9zaGFwZStcIi9cIitvLndpZHRoX3NoYXBlK1wiKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3NbMF0sIG9Qb3NbMV0sIG9Qb3NbMl0sIG9Qb3NbM10pO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIGlmIChcIityK1wiID09IDApIHtcXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKyl7XFxuICAgICAgICAgICAgZmxvYXQgdGVtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oaSwgb1Bvc1sxXSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICAgICAgdG90YWwgKz0gZXhwKHRlbXApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXMgPSBleHAobykgLyB0b3RhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKFwiK3IrXCIgPT0gMSkge1xcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrby5jaGFubmVsK1wiOyBpKyspe1xcbiAgICAgICAgICAgIGZsb2F0IHRlbXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3NbMF0sIGksIG9Qb3NbMl0sIG9Qb3NbM10pO1xcbiAgICAgICAgICAgIHRvdGFsICs9IGV4cCh0ZW1wKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVzID0gZXhwKG8pIC8gdG90YWw7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGkrKyl7XFxuICAgICAgICAgICAgZmxvYXQgdGVtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvc1swXSwgb1Bvc1sxXSwgb1Bvc1syXSwgaSk7XFxuICAgICAgICAgICAgdG90YWwgKz0gZXhwKHRlbXApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXMgPSBleHAobykgLyB0b3RhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxiYXRjaG5vcm06e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5iaWFzLHQ9bi5zY2FsZSxyPW4ubWVhbixpPW4udmFyaWFuY2Uscz1lLmVwc2lsb247cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG5cXG4gICAgICAgIC8vIOW9kuS4gOWMluaVsOaNrlxcbiAgICAgICAgdmVjNCBzY2FsZSA9IGdldFBpeGVsc0Zyb21UZXh0dXJlUG9zX3NjYWxlKHZlYzIoIGZsb2F0KG9Qb3MuZykgLyBmbG9hdChcIit0LndpZHRoX3RleHR1cmUrXCIpICsgMC4wMDAwMSwgMC4wKSk7XFxuICAgICAgICB2ZWM0IGJpYXMgPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19iaWFzKHZlYzIoIGZsb2F0KG9Qb3MuZykgLyBmbG9hdChcIitvLndpZHRoX3RleHR1cmUrXCIpICsgMC4wMDAwMSwgMC4wKSk7XFxuICAgICAgICB2ZWM0IG1lYW4gPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19tZWFuKHZlYzIoKGZsb2F0KG9Qb3MuZykpIC8gZmxvYXQoXCIrci53aWR0aF90ZXh0dXJlK1wiKSAgKyAwLjAwMDAxLCAwLjApKTtcXG4gICAgICAgIHZlYzQgdmFyaWFuY2UgPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc192YXJpYW5jZShcXG4gICAgICAgICAgICB2ZWMyKChmbG9hdChvUG9zLmcpKSAvIGZsb2F0KFwiK2kud2lkdGhfdGV4dHVyZStcIikgKyAwLjAwMDAxLFxcbiAgICAgICAgICAgIDAuMClcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBmbG9hdCB4ID0gKG8gLSBtZWFuWzBdKSAvIHNxcnQodmFyaWFuY2VbMF0gKyBcIitzK1wiKTtcXG4gICAgICAgIGZsb2F0IHJlcyA9IHNjYWxlWzBdICogeCArIGJpYXNbMF07XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHNjYWxlOltcImdldFBpeGVsc0Zyb21UZXh0dXJlUG9zXCJdLGJpYXM6W1wiZ2V0UGl4ZWxzRnJvbVRleHR1cmVQb3NcIl0sbWVhbjpbXCJnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc1wiXSx2YXJpYW5jZTpbXCJnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc1wiXX19LHJlc2hhcGU6Y24scmVzaGFwZTI6Y24sYmlsaW5lYXJfaW50ZXJwOl9uLHRyYW5zcG9zZTI6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89ZS5wZXJtX2Fycix0PWUucGVybV9zaXplLHI9b1swXSxpPW9bMV0scz1vWzJdO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG5cXG4gICAgICAgIC8vIOi9rOe9riDlnZDmoIflj5jmjaJcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBpZiAoXCIrdCtcIiA9PSAxKSB7XFxuICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvc1swXSwgb1Bvc1sxXSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIit0K1wiID09IDIpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1swXSwgb1Bvc1sxXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMiArIFwiK3IrXCIpID4gMyA/IDMgOiAoMiArIFwiK3IrXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMiArIFwiK2krXCIpID4gMyA/IDMgOiAoMiArIFwiK2krXCIpXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIit0K1wiID09IDMpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1swXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK3IrXCIpID4gMyA/IDMgOiAoMSArIFwiK3IrXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK2krXCIpID4gMyA/IDMgOiAoMSArIFwiK2krXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK3MrXCIpID4gMyA/IDMgOiAoMSArIFwiK3MrXCIpXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIit0K1wiID09IDQpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIityK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitpK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitzK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitvWzNdK1wiXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJub3JtYWxpemVQZXJtXCJdfSx1bnBhY2tlZF8yX3BhY2tlZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICB2ZWM0IG91dDQ7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xcbiAgICAgICAgICAgIHZlYzQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfb3JpZ2luKG9Qb3NbMF0sIG9Qb3NbMV0gKiA0ICsgaSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICAgICAgb3V0NFtpXSA9IG9bMF07XFxuICAgICAgICB9XFxuICAgICAgICBzZXRQYWNrZWRPdXRwdXQob3V0NCk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdcIl19fSxwYWNrZWRfMl91bnBhY2tlZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICBpbnQgYzEgPSBjYWxNb2Qob1Bvc1sxXSwgNCk7XFxuICAgICAgICB2ZWM0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX29yaWdpbihvUG9zWzBdLCBvUG9zWzFdIC8gNCwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuXFxuICAgICAgICBpZiAoYzEgPT0gMCkge1xcbiAgICAgICAgICAgIHJlcyA9IG8ucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IG8uZztcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMikge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMykge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdfX0sdW5zcXVlZXplMjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PWUuYXhlcyxyPW8ubGVuZ3RoX3VuZm9ybWF0dGVkX3NoYXBlLGk9QXJyYXkuaXNBcnJheSh0KT90Olt0XSxzPTQtci1pLmxlbmd0aCxhPWkubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gbitzfSkpLHU9WzAsMSwyLDNdLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuLTE9PT1hLmluZGV4T2Yobil9KSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm5cIm9Qb3NbXCIrbitcIl1cIn0pKSxsPUFycmF5LmZyb20obmV3IEFycmF5KGEubGVuZ3RoKSwoZnVuY3Rpb24oKXtyZXR1cm5cIjBcIn0pKTtyZXR1cm4gdS5zcGxpY2UuYXBwbHkodSxmdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCxvPWFyZ3VtZW50cy5sZW5ndGg7ZTxvO2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciB0PUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8bztlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKyl0W3JdPWlbc107cmV0dXJuIHR9KFswLDBdLGwpKSxcIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oXCIrdS5qb2luKFwiLFwiKStcIik7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxmbGF0dGVuX2NvbnRpZ3VvdXNfcmFuZ2U6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLm91dDtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGludCBzdW1WYWwgPSBvUG9zLmFcXG4gICAgICAgICAgICArIG9Qb3MuYiAqIFwiK3Qud2lkdGhfc2hhcGUrXCJcXG4gICAgICAgICAgICArIG9Qb3MuZyAqIFwiK3QuaGVpZ2h0X3NoYXBlK1wiICogXCIrdC53aWR0aF9zaGFwZStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5yICogXCIrdC5jaGFubmVsK1wiICogXCIrdC53aWR0aF9zaGFwZStcIiAqIFwiK3QuaGVpZ2h0X3NoYXBlK1wiO1xcbiAgICAgICAgaXZlYzQgbmV3X29Qb3MgPSB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICAgICAgICAgIHN1bVZhbCxcXG4gICAgICAgICAgICBcIitvLmNoYW5uZWwrXCIsXFxuICAgICAgICAgICAgXCIrby53aWR0aF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIitvLmhlaWdodF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIitvLnRvdGFsX3NoYXBlK1wiXFxuICAgICAgICApO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4obmV3X29Qb3MuciwgbmV3X29Qb3MuZywgbmV3X29Qb3MuYiwgbmV3X29Qb3MuYSk7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGNvbW1vbkZ1bmNDb25mOltcInRyYW5zZmVyRnJvbU5IV0N0b05DSFdcIl19LGZsYXR0ZW4yOmNuLGdyZWF0ZXJfdGhhbjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCB4ID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2lucHV0KG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCB5ID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChib29sKHggPj0geSkpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxyZWR1Y2Vfc3VtOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UuaW5wdXRzX2RpbStcIjsgaSsrKSB7XFxuICAgICAgICAgICAgb1Bvc1tcIitlLmRpbStcIl0gPSBpO1xcbiAgICAgICAgICAgIG8gKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpOztcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm5vcm1hbGl6ZURpbVwiXX0sd2hlcmU6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19pbnB1dChvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgeSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBjb25kaXRpb24gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY29uZGl0aW9uKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcblxcbiAgICAgICAgaWYgKGJvb2woY29uZGl0aW9uKSkge1xcbiAgICAgICAgICAgIG8gPSB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgbyA9IHk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQobyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxjb25kaXRpb246W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sY29ubmVjdDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm91dCx0PW8udG90YWxfc2hhcGUscj1vLndpZHRoX3NoYXBlLGk9by5oZWlnaHRfc2hhcGUscz1vLmNoYW5uZWwsYT1nKFt0LyhyKmkqcykscyxpLHJdKSx1PU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuXCJvdXRcIiE9PW59KSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbltlXS50b3RhbF9zaGFwZX0pKSxsPXUubWFwKChmdW5jdGlvbihuLGUpe3JldHVybiB1LnNsaWNlKDAsZSsxKS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rZX0pLDApfSkpLGY9XCJcIjtyZXR1cm4gbC5mb3JFYWNoKChmdW5jdGlvbihuLGUpe2YrPTA9PT1lP1wiXFxuICAgICAgICAgICAgaWYgKHN1bVZhbCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgY28gPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW4oc3VtVmFsKTtcXG4gICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oY28uciwgY28uZywgY28uYiwgY28uYSk7XFxuICAgICAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgZWxzZSBpZiAoc3VtVmFsIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICBjbyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbl9cIitlK1wiKHN1bVZhbCAtIFwiK2xbZS0xXStcIik7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luX1wiK2UrXCIoY28uciwgY28uZywgY28uYiwgY28uYSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwifSkpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgaXZlYzQgY287XFxuICAgICAgICBpbnQgc3VtVmFsID0gb1Bvcy5iICogXCIrYVsyXStcIiArIG9Qb3MuYTtcXG4gICAgICAgIFwiK2YrXCJcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7XCJAYWxsXCI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCIsXCJnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleFwiXX19LHJlZHVjZV9tZWFuOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPWUuaW5wdXRzX2RpbTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitvK1wiOyBpKyspIHtcXG4gICAgICAgICAgICBvUG9zW1wiK2UuZGltK1wiXSA9IGk7XFxuICAgICAgICAgICAgbyArPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICB9XFxuICAgICAgICBvID0gbyAvIGZsb2F0KFwiK28rXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KG8pO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJub3JtYWxpemVEaW1cIl19LGhhcmRfc3dpc2g6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89ZS5vZmZzZXQsdD12b2lkIDA9PT1vPzM6byxyPWUuc2NhbGUsaT12b2lkIDA9PT1yPzY6cixzPWUudGhyZXNob2xkO3JldHVyblwiXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCByZXMgPSBvICogbWluKG1heCgwLjAsIG8gKyBmbG9hdChcIit0K1wiKSksIGZsb2F0KFwiKyh2b2lkIDA9PT1zPzY6cykrXCIpKSAvIGZsb2F0KFwiK2krXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LG5lYXJlc3RfaW50ZXJwOlBuLG5lYXJlc3RfaW50ZXJwX3YyOlBuLGNhc3Q6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89XCJcIjtzd2l0Y2goZS5vdXRfZHR5cGUpe2Nhc2UgMDpvPVwiXFxuICAgICAgICAgICAgZmxvYXQgcmVzX2Jvb2wgPSAwLjA7XFxuICAgICAgICAgICAgaWYgKG8gIT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIHJlc19ib29sID0gMS4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzZXRPdXRwdXQocmVzX2Jvb2wpO1wiO2JyZWFrO2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOm89XCJcXG4gICAgICAgICAgICBpbnQgcmVzX2ludCA9IGludChvKTtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzX2ludCkpO1wiO2JyZWFrO2RlZmF1bHQ6bz1cIiAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCByZXNfZmxvYXQgPSBvO1xcbiAgICAgICAgICAgIHNldE91dHB1dChyZXNfZmxvYXQpO1wifXJldHVyblwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgXCIrbytcIlxcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxmaWxsX2NvbnN0YW50X2JhdGNoX3NpemVfbGlrZTp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrZS52YWx1ZStcIik7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcblwifX0scm5uX21hdG11bDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLndlaWdodGxpc3RfMCx0PWUuaW5wdXRfYXhpcyxyPWUuc3RhdGVfYXhpcyxpPWUuYmF0Y2gscz1lLnJldmVyc2UsYT12b2lkIDAhPT1zJiZzP2ktdC0xOnQ7cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3V0X3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAoXCIrKDA9PT10KStcIikge1xcbiAgICAgICAgICAgIHJlcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgXCIrYStcIiwgb3V0X3Bvc1syXSwgb3V0X3Bvc1szXSk7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICBpdmVjNCBvcmlnaW5fcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGl2ZWM0IHdlaWdodF9wb3MgPSBvdXRfcG9zO1xcblxcbiAgICAgICAgd2VpZ2h0X3Bvc1sxXSA9IDA7XFxuICAgICAgICB3ZWlnaHRfcG9zWzJdID0gd2VpZ2h0X3Bvc1szXTtcXG5cXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBmbG9hdCB3X2hoID0gMC4wO1xcbiAgICAgICAgZmxvYXQgcHJlc3RhdGVfaCA9IDAuMDtcXG4gICAgICAgIHJlcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgXCIrYStcIiwgb3V0X3Bvc1syXSwgb3V0X3Bvc1szXSk7XFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGorKykge1xcbiAgICAgICAgICAgIHByZXN0YXRlX2ggPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfcHJlc3RhdGUob3JpZ2luX3Bvc1swXSwgb3JpZ2luX3Bvc1sxXSwgb3JpZ2luX3Bvc1syXSwgaik7XFxuICAgICAgICAgICAgd19oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzAob3V0X3Bvc1swXSwgXCIrcitcIiwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgbyArPSB3X2hoICogcHJlc3RhdGVfaDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlcyArPSBvO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxwcmVzdGF0ZTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sd2VpZ2h0bGlzdF8wOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LHJubl9oaWRkZW46e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89ZS5zdGF0ZV9heGlzLHQ9ZS5oaWRkZW5fc2l6ZTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgb3JpZ2luID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgY2VsbCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrdCtcIik7XFxuICAgICAgICBmbG9hdCBhcHBlbmRlciA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrMip0K1wiKTtcXG4gICAgICAgIGZsb2F0IGZvdXJ0aCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrMyp0K1wiKTtcXG4gICAgICAgIGZsb2F0IGNvdW50ZXIgID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIob1Bvcy5yLCBcIitvK1wiLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBpID0gMS4wIC8gKDEuMCArIGV4cCgtb3JpZ2luKSk7XFxuICAgICAgICBmbG9hdCBmID0gMS4wIC8gKDEuMCArIGV4cCgtY2VsbCkpO1xcbiAgICAgICAgZmxvYXQgbyA9IDEuMCAvICgxLjAgKyBleHAoLWZvdXJ0aCkpO1xcbiAgICAgICAgZmxvYXQgYyA9IGYgKiBjb3VudGVyICsgaSAqIHRhbmhfY2FsYyhhcHBlbmRlcik7XFxuICAgICAgICBmbG9hdCBoID0gbyAqIHRhbmhfY2FsYyhjKTtcXG4gICAgICAgIFxcbiAgICAgICAgc2V0T3V0cHV0KGgpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxybm5fY2VsbDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1lLnN0YXRlX2F4aXMsdD1lLmhpZGRlbl9zaXplO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvcmlnaW4gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBjZWxsID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIit0K1wiKTtcXG4gICAgICAgIGZsb2F0IGFwcGVuZGVyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIisyKnQrXCIpO1xcbiAgICAgICAgZmxvYXQgZm91cnRoID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIiszKnQrXCIpO1xcbiAgICAgICAgZmxvYXQgY291bnRlciAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY291bnRlcihvUG9zLnIsIFwiK28rXCIsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgIGZsb2F0IGkgPSAxLjAgLyAoMS4wICsgZXhwKC1vcmlnaW4pKTtcXG4gICAgICAgIGZsb2F0IGYgPSAxLjAgLyAoMS4wICsgZXhwKC1jZWxsKSk7XFxuICAgICAgICBmbG9hdCBjID0gZiAqIGNvdW50ZXIgKyBpICogdGFuaF9jYWxjKGFwcGVuZGVyKTtcXG4gICAgICAgIFxcbiAgICAgICAgc2V0T3V0cHV0KGMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxybm5fb3JpZ2luOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ud2VpZ2h0bGlzdF8wLHQ9bi53ZWlnaHRsaXN0XzEscj1lLnN0YXRlX2F4aXM7cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpdmVjNCBvcmlnaW5fcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGl2ZWM0IHdlaWdodF9wb3MgPSBvdXRfcG9zO1xcbiAgICAgIFxcbiAgICAgICAgd2VpZ2h0X3Bvc1sxXSA9IDA7XFxuICAgICAgICB3ZWlnaHRfcG9zWzJdID0gd2VpZ2h0X3Bvc1szXTtcXG5cXG4gICAgICAgIGZsb2F0IGJfaWggPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfd2VpZ2h0bGlzdF8yKDAsIDAsIDAsIG91dF9wb3NbM10pO1xcbiAgICAgICAgZmxvYXQgYl9oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzMoMCwgMCwgMCwgb3V0X3Bvc1szXSk7XFxuICAgICAgICBcXG4gICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrby53aWR0aF9zaGFwZStcIjsgaisrKSB7XFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3JpZ2luX3Bvc1swXSwgb3JpZ2luX3Bvc1sxXSwgMCwgaik7XFxuICAgICAgICAgICAgZmxvYXQgd19paCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzAoMCwgMCwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgcmVzICs9IHdfaWggKiBvO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzICs9IGJfaWg7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3Qud2lkdGhfc2hhcGUrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwcmVzdGF0ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19wcmVzdGF0ZSgwLCAwLCAwLCBqKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd19oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzEoMCwgXCIrcitcIiwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgICAgIHJlcyArPSB3X2hoICogcHJlc3RhdGU7XFxuICAgICAgICB9XFxuICAgICAgICByZXMgKz0gYl9oaDtcXG4gXFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHByZXN0YXRlOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSx3ZWlnaHRsaXN0XzA6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHdlaWdodGxpc3RfMTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sd2VpZ2h0bGlzdF8yOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSx3ZWlnaHRsaXN0XzM6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0scG9vbDJkX2F2Zzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgbz1uLm9yaWdpbix0PWUuc3RyaWRlcyxyPXZvaWQgMD09PXQ/W106dCxpPWUucGFkZGluZ3Mscz12b2lkIDA9PT1pP1tdOmksYT1lLmtzaXplLHU9clswXSxsPXZvaWQgMD09PXU/MTp1LGY9clsxXSxjPXZvaWQgMD09PWY/MTpmLF89c1swXSxnPXZvaWQgMD09PV8/MDpfLGg9c1sxXSxkPXZvaWQgMD09PWg/MDpoLHA9YVswXSxtPWFbMV07cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3V0X3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8gWOOAgVnmlrnlkJHnmoTnp7vliqjmraXplb9cXG4gICAgICAgIGludCBveV9iYXNlID0gb3V0X3Bvc1syXSAqIFwiK2wrXCIgLSBcIitnK1wiO1xcbiAgICAgICAgaW50IG94X2Jhc2UgPSBvdXRfcG9zWzNdICogXCIrYytcIiAtIFwiK2QrXCI7XFxuICAgICAgICBmb3IgKGludCBmeSA9IDA7IGZ5IDwgXCIrcCtcIjsgZnkrKykge1xcbiAgICAgICAgICAgIGludCBveSA9IG95X2Jhc2UgKyBmeTtcXG4gICAgICAgICAgICBpZiAob3kgPj0gXCIrby5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChveSA8IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAoaW50IGZ4ID0gMDsgZnggPCBcIittK1wiOyBmeCsrKSB7XFxuICAgICAgICAgICAgICAgIGludCBveCA9IG94X2Jhc2UgKyBmeDtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK28ud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbuaVsOaNrlxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvdXRfcG9zWzBdLCBvdXRfcG9zWzFdLCBveSwgb3gpO1xcbiAgICAgICAgICAgICAgICByZXMgKz0gY3VycjtcXG4gICAgICAgICAgICAgICAgLy8g5Zyo5bmz5Z2H5rGg5YyW5qih5byP5b+955Wl5aGr5YWF5YC8KGV4Y2x1c2l2Zem7mOiupOS4unRydWXvvIlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXMgPSByZXMgLyBmbG9hdChcIitwK1wiICogXCIrbStcIik7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wic2V0UGFja2VkXCIsXCJzZXRBZGFwdGl2ZVwiLFwiaXNHbG9iYWxQb29saW5nXCJdfSxwcmVsdTpwbihcInByZWx1XCIpLHJlbHU2OnBuKFwicmVsdTZcIiksbGVha3lSZWx1OnBuKFwibGVha3lSZWx1XCIpLHNjYWxlOnBuKFwic2NhbGVcIiksc2lnbW9pZDpwbihcInNpZ21vaWRcIikscmVsdTpwbihcInJlbHVcIiksaGFyZF9zaWdtb2lkOnBuKFwiaGFyZF9zaWdtb2lkXCIpLHBvdzpwbihcInBvd1wiKSxzcXJ0OnBuKFwic3FydFwiKSx0YW5oOnBuKFwidGFuaFwiKSxleHA6cG4oXCJleHBcIiksc3F1ZWV6ZTI6bW4scGFkM2Q6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1lLnBhZGRpbmdzLHI9ZS5tb2RlLGk9ZS52YWx1ZSxzPWZ1bmN0aW9uKG4pe3ZhciBlPW4udG90YWxfc2hhcGUsbz1uLmNoYW5uZWwsdD1uLmhlaWdodF9zaGFwZSxyPW4ud2lkdGhfc2hhcGU7cmV0dXJuW2Uvby90L3Isbyx0LHJdfShvKSxhPXtyZWZsZWN0OlwiXFxuICAgICAgICAgICAgaW50IGE7XFxuICAgICAgICAgICAgaW50IGI7XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYSAtIFwiK3RbMF0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGEgPSBcIit0WzBdK1wiIC0gb1Bvcy5hO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zLmEgLSBcIit0WzBdK1wiID49IFwiK3NbM10rXCIpIHtcXG4gICAgICAgICAgICAgICAgYSA9IFwiK3NbM10rXCIgLSAob1Bvcy5hIC0gXCIrdFswXStcIiAtIFwiK3NbM10rXCIgKyAxKSAtIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhID0gb1Bvcy5hIC0gXCIrdFswXStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYiAtIFwiK3RbMl0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGIgPSBcIit0WzJdK1wiIC0gb1Bvcy5iO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zLmIgLSBcIit0WzJdK1wiID49IFwiK3NbMl0rXCIpIHtcXG4gICAgICAgICAgICAgICAgYiA9IFwiK3NbMl0rXCIgLSAob1Bvcy5iIC0gXCIrdFsyXStcIiAtIFwiK3NbMl0rXCIgKyAxKSAtIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBiID0gb1Bvcy5iIC0gXCIrdFsyXStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIGIsIGEpO1xcbiAgICAgICAgXCIscmVwbGljYXRlOlwiXFxuICAgICAgICAgICAgaW50IGE7XFxuICAgICAgICAgICAgaW50IGI7XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYSAtIFwiK3RbMF0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGEgPSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zLmEgLSBcIit0WzBdK1wiID49IFwiK3NbM10rXCIpIHtcXG4gICAgICAgICAgICAgICAgYSA9IFwiK3NbM10rXCIgLSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYSA9IG9Qb3MuYSAtIFwiK3RbMF0rXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChvUG9zLmIgLSBcIit0WzJdK1wiIDwgMCkge1xcbiAgICAgICAgICAgICAgICBiID0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAob1Bvcy5iIC0gXCIrdFsyXStcIiA+PSBcIitzWzJdK1wiKSB7XFxuICAgICAgICAgICAgICAgIGIgPSBcIitzWzJdK1wiIC0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGIgPSBvUG9zLmIgLSBcIit0WzJdK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgYiwgYSk7XFxuICAgICAgICBcIixjaXJjdWxhcjpcIlxcbiAgICAgICAgICAgIGludCBhO1xcbiAgICAgICAgICAgIGludCBiO1xcbiAgICAgICAgICAgIGlmIChvUG9zLmEgLSBcIit0WzBdK1wiIDwgMCkge1xcbiAgICAgICAgICAgICAgICBhID0gaW50KG1vZChmbG9hdChcIit0WzBdK1wiICsgb1Bvcy5hIC0gMSksIGZsb2F0KFwiK3NbM10rXCIpKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKG9Qb3MuYSAtIFwiK3RbMF0rXCIgPj0gXCIrc1szXStcIikge1xcbiAgICAgICAgICAgICAgICBhID0gaW50KG1vZChmbG9hdChvUG9zLmEgLSBcIit0WzBdK1wiIC0gXCIrc1szXStcIiksIGZsb2F0KFwiK3NbM10rXCIpKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhID0gb1Bvcy5hIC0gXCIrdFswXStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYiAtIFwiK3RbMl0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGIgPSBpbnQobW9kKGZsb2F0KFwiK3RbMl0rXCIgKyBvUG9zLmIgLSAxKSwgZmxvYXQoXCIrc1syXStcIikpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAob1Bvcy5iIC0gXCIrdFsyXStcIiA+PSBcIitzWzJdK1wiKSB7XFxuICAgICAgICAgICAgICAgIGIgPSBpbnQobW9kKGZsb2F0KG9Qb3MuYiAtIFwiK3RbMl0rXCIgLSBcIitzWzJdK1wiKSwgZmxvYXQoXCIrc1syXStcIikpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGIgPSBvUG9zLmIgLSBcIit0WzJdK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgYiwgYSk7XFxuICAgICAgICBcIixjb25zdGFudDpcIlwiLHVuZGVmaW5lZDpcIlwifTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IFwiKyhpfHxcIjAuMFwiKStcIjtcXG4gICAgICAgIGlmIChvUG9zLmEgLSBcIit0WzBdK1wiID49IDBcXG4gICAgICAgICAgICAmJiBvUG9zLmIgLSBcIit0WzJdK1wiID49IDBcXG4gICAgICAgICAgICAmJiBvUG9zLmEgLSBcIit0WzBdK1wiIDwgXCIrc1szXStcIlxcbiAgICAgICAgICAgICYmIG9Qb3MuYiAtIFwiK3RbMl0rXCIgPCBcIitzWzJdK1wiXFxuICAgICAgICApIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iIC0gXCIrdFsyXStcIiwgb1Bvcy5hIC0gXCIrdFswXStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBcIithW3JdK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxiaWxpbmVhcl9pbnRlcnBfdjI6Z24sc2h1ZmZsZV9jaGFubmVsOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ub3V0LHQ9ZS5ncm91cCxyPXZvaWQgMD09PXQ/Mjp0LGk9by50b3RhbF9zaGFwZSxzPW8uaGVpZ2h0X3NoYXBlLGE9by53aWR0aF9zaGFwZSx1PW8uY2hhbm5lbCxsPVsxLDAsMiwzXTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcblxcbiAgICAgICAgaW50IHN1bVZhbCA9IG9Qb3MuYVxcbiAgICAgICAgICAgICsgb1Bvcy5iICogXCIrYStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5nICogXCIrcytcIiAqIFwiK2ErXCJcXG4gICAgICAgICAgICArIG9Qb3MuciAqIFwiK3UrXCIgKiBcIithK1wiICogXCIrcytcIjtcXG5cXG4gICAgICAgIGl2ZWM0IHRyYW5zcG9zZV9vdXRfcG9zID0gdHJhbnNmZXJGcm9tTkhXQ3RvTkNIVyhcXG4gICAgICAgICAgICBzdW1WYWwsXFxuICAgICAgICAgICAgXCIrcitcIixcXG4gICAgICAgICAgICBcIithK1wiLFxcbiAgICAgICAgICAgIFwiK3MrXCIsXFxuICAgICAgICAgICAgXCIraStcIlxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGl2ZWM0IHRyYW5zcG9zZV9pbl9wb3MgPSBpdmVjNCh0cmFuc3Bvc2Vfb3V0X3Bvc1tcIitsWzBdK1wiXSxcXG4gICAgICAgICAgICB0cmFuc3Bvc2Vfb3V0X3Bvc1tcIitsWzFdK1wiXSwgdHJhbnNwb3NlX291dF9wb3NbXCIrbFsyXStcIl0sIHRyYW5zcG9zZV9vdXRfcG9zW1wiK2xbM10rXCJdKTtcXG4gICAgICAgIGludCBzdW1WYWwyID0gdHJhbnNwb3NlX2luX3Bvcy5hXFxuICAgICAgICAgICAgKyB0cmFuc3Bvc2VfaW5fcG9zLmIgKiBcIithK1wiXFxuICAgICAgICAgICAgKyB0cmFuc3Bvc2VfaW5fcG9zLmcgKiBcIitzK1wiICogXCIrYStcIlxcbiAgICAgICAgICAgICsgdHJhbnNwb3NlX2luX3Bvcy5yICogXCIrdS9yK1wiICogXCIrYStcIiAqIFwiK3MrXCI7XFxuICAgICAgICBpdmVjNCBvcmlnaW5fb1BvcyA9IHRyYW5zZmVyRnJvbU5IV0N0b05DSFcoXFxuICAgICAgICAgICAgc3VtVmFsMixcXG4gICAgICAgICAgICBcIit1K1wiLFxcbiAgICAgICAgICAgIFwiK2ErXCIsXFxuICAgICAgICAgICAgXCIrcytcIixcXG4gICAgICAgICAgICBcIitpK1wiXFxuICAgICAgICApO1xcblxcblxcbiAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oXFxuICAgICAgICAgICAgb3JpZ2luX29Qb3NbMF0sXFxuICAgICAgICAgICAgb3JpZ2luX29Qb3NbMV0sXFxuICAgICAgICAgICAgb3JpZ2luX29Qb3NbMl0sXFxuICAgICAgICAgICAgb3JpZ2luX29Qb3NbM11cXG4gICAgICAgICk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGNvbW1vbkZ1bmNDb25mOltcInRyYW5zZmVyRnJvbU5IV0N0b05DSFdcIl19LHBhY2tfb3V0OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3JldHVyblwiXFxuXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIHZlYzIgb3V0Q29vcmQgPSB2Q29vcmQueHkgKiBfMmRfc2hhcGVfdGV4dHVyZV9vdXQ7XFxuICAgICAgICBpbnQgaW5kZXggPSBpbnQob3V0Q29vcmQueCkgKyBpbnQob3V0Q29vcmQueSkgKiBpbnQoXCIrbi5vdXQud2lkdGhfdGV4dHVyZStcIik7XFxuXFxuICAgICAgICBpbnQgZmlyc3QgPSBpbmRleCAqIDQ7XFxuICAgICAgICBpbnQgc2VjID0gaW5kZXggKiA0ICsgMTtcXG4gICAgICAgIGludCB0aGlyZCA9IGluZGV4ICogNCArIDI7XFxuICAgICAgICBpbnQgZm91cnRoID0gaW5kZXggKiA0ICsgMztcXG5cXG4gICAgICAgIGl2ZWM0IHJQb3MgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW4oZmlyc3QpO1xcbiAgICAgICAgaXZlYzQgZ1BvcyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbihzZWMpO1xcbiAgICAgICAgaXZlYzQgYlBvcyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbih0aGlyZCk7XFxuICAgICAgICBpdmVjNCBhUG9zID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfb3JpZ2luKGZvdXJ0aCk7XFxuXFxuICAgICAgICBmbG9hdCByID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihyUG9zLnIsIHJQb3MuZywgclBvcy5iLCByUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgZyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oZ1Bvcy5yLCBnUG9zLmcsIGdQb3MuYiwgZ1Bvcy5hKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGJQb3MuciwgYlBvcy5nLCBiUG9zLmIsIGJQb3MuYSk7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihhUG9zLnIsIGFQb3MuZywgYVBvcy5iLCBhUG9zLmEpO1xcblxcbiAgICAgICAgc2V0UGFja2VkT3V0cHV0KHZlYzQociwgZywgYiwgYSkpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIixcImdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4XCJdfX0sbmh3Y18yX25jaHc6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIG89bi5vcmlnaW4sdD1uLm91dDtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGludCBzdW1WYWwgPSBvUG9zLmEgKiBcIit0LmNoYW5uZWwrXCJcXG4gICAgICAgICAgICArIG9Qb3MuYiAqIFwiK3Qud2lkdGhfc2hhcGUrXCIgKiBcIit0LmNoYW5uZWwrXCJcXG4gICAgICAgICAgICArIG9Qb3MuZ1xcbiAgICAgICAgICAgICsgb1Bvcy5yICogXCIrdC5jaGFubmVsK1wiICogXCIrdC53aWR0aF9zaGFwZStcIiAqIFwiK3QuaGVpZ2h0X3NoYXBlK1wiO1xcbiAgICAgICAgaXZlYzQgbmV3X29Qb3MgPSB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICAgICAgICAgIHN1bVZhbCxcXG4gICAgICAgICAgICBcIitvLmNoYW5uZWwrXCIsXFxuICAgICAgICAgICAgXCIrby53aWR0aF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIitvLmhlaWdodF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIitvLnRvdGFsX3NoYXBlK1wiXFxuICAgICAgICApO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4obmV3X29Qb3MuciwgbmV3X29Qb3MuZywgbmV3X29Qb3MuYiwgbmV3X29Qb3MuYSk7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGNvbW1vbkZ1bmNDb25mOltcInRyYW5zZmVyRnJvbU5IV0N0b05DSFdcIl19LGZlZWRQb3N0OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPW4ub3V0LHQ9ZS5tZWFuLHI9dm9pZCAwPT09dD9bMCwwLDBdOnQsaT1lLnN0ZCxzPXZvaWQgMD09PWk/WzEsMSwxXTppLGE9by50b3RhbF9zaGFwZSx1PW8uaGVpZ2h0X3NoYXBlLGw9by53aWR0aF9zaGFwZSxmPW8uY2hhbm5lbDtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgbmh3Y1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgaW50IHN1bVZhbCA9IG5od2NQb3MuYVxcbiAgICAgICAgICAgICsgbmh3Y1Bvcy5iICogXCIrbCtcIlxcbiAgICAgICAgICAgICsgbmh3Y1Bvcy5nICogXCIrdStcIiAqIFwiK2wrXCJcXG4gICAgICAgICAgICArIG5od2NQb3MuciAqIFwiK2YrXCIgKiBcIitsK1wiICogXCIrdStcIjtcXG5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICAgICAgICAgIHN1bVZhbCxcXG4gICAgICAgICAgICBcIitmK1wiLFxcbiAgICAgICAgICAgIFwiK2wrXCIsXFxuICAgICAgICAgICAgXCIrdStcIixcXG4gICAgICAgICAgICBcIithK1wiXFxuICAgICAgICApO1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgaW50IGMxID0gaW50KG1vZChmbG9hdChvUG9zWzFdKSwgNC4wKSk7XFxuICAgICAgICBpbnQgYyA9IG9Qb3NbMV07XFxuICAgICAgICB2ZWM0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX29yaWdpbihvUG9zWzBdLCBjIC8gNCwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuXFxuICAgICAgICBpZiAoYzEgPT0gMCkge1xcbiAgICAgICAgICAgIHJlcyA9IG8ucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IG8uZztcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMikge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMykge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjID09IDApIHtcXG4gICAgICAgICAgICByZXMgPSAocmVzIC0gZmxvYXQoXCIrclswXStcIikpIC8gZmxvYXQoXCIrc1swXStcIik7XFxuICAgICAgICB9IGVsc2UgaWYgKGMgPT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IChyZXMgLSBmbG9hdChcIityWzFdK1wiKSkgLyBmbG9hdChcIitzWzFdK1wiKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PSAyKSB7XFxuICAgICAgICAgICAgcmVzID0gKHJlcyAtIGZsb2F0KFwiK3JbMl0rXCIpKSAvIGZsb2F0KFwiK3NbMl0rXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdfSxjb21tb25GdW5jQ29uZjpbXCJ0cmFuc2ZlckZyb21OSFdDdG9OQ0hXXCJdfSxpbWdGZWVkOnttYWluRnVuYzpmdW5jdGlvbigpe3JldHVyblwiXFxuICAgIHVuaWZvcm0gdmVjMiB1X3NjYWxlO1xcbiAgICB1bmlmb3JtIGludCB1X2tlZXBfcmF0aW87XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICB2ZWMyIG91dENvb3JkID0gdkNvb3JkLnh5O1xcbiAgICAgICAgLy8g5pSv5oyB5qih5Z6L5LiN5oyJ5q+U5L6L5ouJ5Ly4XFxuICAgICAgICBpZiAodV9rZWVwX3JhdGlvID09IDApIHtcXG4gICAgICAgICAgICB2ZWM0IG9yaWdpbiA9IFRFWFRVUkUyRCh0ZXh0dXJlX29yaWdpbiwgb3V0Q29vcmQpO1xcbiAgICAgICAgICAgIHNldFBhY2tlZE91dHB1dChvcmlnaW4pO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHN0YXJ0WCA9ICgxLjAgLSB1X3NjYWxlLngpIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgZW5kWCA9IHN0YXJ0WCArIHVfc2NhbGUueDtcXG4gICAgICAgIGZsb2F0IHN0YXJ0WSA9ICgxLjAgLSB1X3NjYWxlLnkpIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgZW5kWSA9IHN0YXJ0WSArIHVfc2NhbGUueTtcXG5cXG4gICAgICAgIGlmIChvdXRDb29yZC54ID49IHN0YXJ0WCAmJiBvdXRDb29yZC54IDw9IGVuZFggJiYgb3V0Q29vcmQueSA+PSBzdGFydFkgJiYgb3V0Q29vcmQueSA8PSBlbmRZKSB7XFxuICAgICAgICAgICAgdmVjMiBuZXdQb3MgPSAob3V0Q29vcmQgLSB2ZWMyKHN0YXJ0WCwgc3RhcnRZKSkgLyB1X3NjYWxlO1xcbiAgICAgICAgICAgIHZlYzQgb3JpZ2luID0gVEVYVFVSRTJEKHRleHR1cmVfb3JpZ2luLCBuZXdQb3MpO1xcbiAgICAgICAgICAgIHNldFBhY2tlZE91dHB1dChvcmlnaW4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgc2V0UGFja2VkT3V0cHV0KHZlYzQoMS4wKSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltdfX0sYm94X2NvZGVyOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciBvPVwiZGVjb2RlX2NlbnRlcl9zaXplXCI9PT1lLmNvZGVfdHlwZTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2ZWMyIGdldFByaW9yQm94RGF0YShpbnQgciwgaW50IGcsIGludCBiLCBpbnQgbSwgaW50IG4pIHtcXG4gICAgICAgIGZsb2F0IHN0YXJ0ID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3ByaW9yYm94KHIsIGcsIGIsIG0pO1xcbiAgICAgICAgZmxvYXQgZW5kID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3ByaW9yYm94KHIsIGcsIGIsIG4pO1xcbiAgICAgICAgZmxvYXQgbGVuID0gZW5kIC0gc3RhcnQ7XFxuICAgICAgICByZXR1cm4gdmVjMihzdGFydCArIGxlbiAvIDIuMCwgbGVuKTtcXG4gICAgfVxcbiAgICB2ZWMyIGdldEJveFZhckRhdGEoaW50IHIsIGludCBnLCBpbnQgYiwgaW50IG0sIGludCBuKSB7XFxuICAgICAgICByZXR1cm4gdmVjMihcXG4gICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfcHJpb3Jib3h2YXIociwgZywgYiwgbSksXFxuICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3ByaW9yYm94dmFyKHIsIGcsIGIsIG4pXFxuICAgICAgICApO1xcbiAgICB9XFxuICAgIHZlYzIgZ2V0VGFyZ2V0Qm94RGF0YShpbnQgciwgaW50IGcsIGludCBiLCBpbnQgbSwgaW50IG4pIHtcXG4gICAgICAgIFwiKyhvP1wiXFxuICAgICAgICAgICAgcmV0dXJuIHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc190YXJnZXRib3gociwgZywgYiwgbSksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc190YXJnZXRib3gociwgZywgYiwgbilcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICBmbG9hdCBzdGFydCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc190YXJnZXRib3gociwgZywgYiwgbSk7XFxuICAgICAgICAgICAgZmxvYXQgZW5kID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3RhcmdldGJveChyLCBnLCBiLCBuKTtcXG4gICAgICAgICAgICBmbG9hdCBsZW4gPSBlbmQgLSBzdGFydDtcXG4gICAgICAgICAgICByZXR1cm4gdmVjMihzdGFydCArIGxlbiAvIDIuMCwgbGVuKTtcXG4gICAgICAgIFwiKStcIlxcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgciA9IGludChvUG9zLnIpO1xcbiAgICAgICAgaW50IGcgPSBpbnQob1Bvcy5nKTtcXG4gICAgICAgIGludCBiID0gaW50KG9Qb3MuYik7XFxuICAgICAgICBpbnQgYSA9IGludChvUG9zLmEpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcblxcbiAgICAgICAgaW50IG0gPSAwO1xcbiAgICAgICAgaW50IG4gPSAwO1xcbiAgICAgICAgaWYgKGEgPT0gMCB8fCBhID09IFwiKyhvPzI6MSkrXCIpIHtcXG4gICAgICAgICAgICBtID0gMDtcXG4gICAgICAgICAgICBuID0gMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIG0gPSAxO1xcbiAgICAgICAgICAgIG4gPSAzO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmVjMiBwcmlvcmJveCA9IGdldFByaW9yQm94RGF0YShyLCBnLCBiLCBtLCBuKTtcXG4gICAgICAgIHZlYzIgYm94dmFyID0gZ2V0Qm94VmFyRGF0YShyLCBnLCBiLCBtLCBuKTtcXG4gICAgICAgIHZlYzIgdGFyZ2V0Ym94ID0gZ2V0VGFyZ2V0Qm94RGF0YShyLCBnLCBiLCBtLCBuKTtcXG4gICAgICAgIGZsb2F0IHAxID0gcHJpb3Jib3gucjtcXG4gICAgICAgIGZsb2F0IHAyID0gcHJpb3Jib3guZztcXG4gICAgICAgIGZsb2F0IHQxID0gdGFyZ2V0Ym94LnI7XFxuICAgICAgICBmbG9hdCB0MiA9IHRhcmdldGJveC5nO1xcbiAgICAgICAgZmxvYXQgdjEgPSBib3h2YXIucjtcXG4gICAgICAgIGZsb2F0IHYyID0gYm94dmFyLmc7XFxuXFxuICAgICAgICBcIisobz9cIlxcbiAgICAgICAgICAgIGZsb2F0IGIxID0gcDIgKiB2MSAqIHQxICsgcDE7XFxuICAgICAgICAgICAgZmxvYXQgYjIgPSBleHAodjIgKiB0MikgKiBwMjtcXG4gICAgICAgICAgICBpZiAoYSA9PSAwIHx8IGEgPT0gMSkge1xcbiAgICAgICAgICAgICAgICBvID0gYjEgLSBiMiAvIDIuMCA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBvID0gYjEgKyBiMiAvIDIuMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIjpcIlxcbiAgICAgICAgICAgIGlmIChhID09IDAgfHwgYSA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIG8gPSAodDEgLSBwMSkgLyBwMiAvIHYxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbyA9IGxvZyhhYnModDIgLyBwMikpIC8gdjI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIpK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e3RhcmdldGJveDpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0scHJpb3Jib3g6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHByaW9yYm94dmFyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltdfSxkZW5zaXR5X3ByaW9yX2JveDp4bixwcmlvcl9ib3g6VG4sc3RhY2s6Rm4sc2xpY2U6Ym59LEVuPW5ldyAkOyFmdW5jdGlvbihuLGUsbyl7biYmKHUuYmFja2VuZD1uKSxlJiYodS5iYWNrZW5kSW5zdGFuY2U9ZSksbyYmT2JqZWN0LmtleXMobykuZm9yRWFjaCgoZnVuY3Rpb24obil7IWZ1bmN0aW9uKG4sZSl7dmFyIG89bi5jb25mLHQ9bi5wYXJhbXMscj1uLm1haW4saT1uLm1haW5GdW5jLHM9bi50ZXh0dXJlRnVuY0NvbmYsYT1uLmNvbW1vbkZ1bmNDb25mLGw9bi5iZWhhdmlvcnMsZj12b2lkIDA9PT1sP1tdOmwsYz11LmJhY2tlbmQrXCJfXCIrZTt1Lm9wUmVnaXN0cnkub3BzW2NdfHwodS5vcFJlZ2lzdHJ5Lm9wc1tjXT17bmFtZTplLGNvbmY6byxwYXJhbXM6dCxtYWluOnIsbWFpbkZ1bmM6aSx0ZXh0dXJlRnVuY0NvbmY6cyxjb21tb25GdW5jQ29uZjphLGJlaGF2aW9yczpmfSl9KG9bbl0sbil9KSl9KFwid2ViZ2xcIixFbix5bil9fSxlPXt9O2Z1bmN0aW9uIG8odCl7aWYoZVt0XSlyZXR1cm4gZVt0XS5leHBvcnRzO3ZhciByPWVbdF09e2V4cG9ydHM6e319O3JldHVybiBuW3RdKHIsci5leHBvcnRzLG8pLHIuZXhwb3J0c31yZXR1cm4gby5kPShuLGUpPT57Zm9yKHZhciB0IGluIGUpby5vKGUsdCkmJiFvLm8obix0KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sdCx7ZW51bWVyYWJsZTohMCxnZXQ6ZVt0XX0pfSxvLmc9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gZ2xvYmFsVGhpczt0cnl7cmV0dXJuIHRoaXN8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2gobil7aWYoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93fX0oKSxvLm89KG4sZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLGUpLG8ucj1uPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbyg0MDApfSkoKX0pKTsiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnBhZGRsZWpzPWUoKToodC5wYWRkbGVqcz10LnBhZGRsZWpzfHx7fSx0LnBhZGRsZWpzLmNvcmU9ZSgpKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4oKCk9Pnt2YXIgdD17OTExOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZilyZXR1cm4gc2VsZjtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3c7aWYodm9pZCAwIT09cilyZXR1cm4gcjt0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIil9KCk7dC5leHBvcnRzPWU9ci5mZXRjaCxyLmZldGNoJiYoZS5kZWZhdWx0PXIuZmV0Y2guYmluZChyKSksZS5IZWFkZXJzPXIuSGVhZGVycyxlLlJlcXVlc3Q9ci5SZXF1ZXN0LGUuUmVzcG9uc2U9ci5SZXNwb25zZX0sOTk0Oih0LGUscik9PntcInVzZSBzdHJpY3RcIjtyLnIoZSksci5kKGUse1BhZGRsZWpzQmFja2VuZDooKT0+eXQsUnVubmVyOigpPT5tdCxUcmFuc2Zvcm1lcjooKT0+ayxjb3JlVXRpbHM6KCk9Pm4sZW52OigpPT5wLGludGVyZmFjZXM6KCk9PmkscmVnaXN0ZXJCYWNrZW5kOigpPT5fLHJlZ2lzdGVyT3A6KCk9Pnd9KTt2YXIgbj17fTtyLnIobiksci5kKG4se0FkZEl0ZW1Ub1ZhcnM6KCk9PnUsZGVsVXNlbGVzc0RhdGE6KCk9PmMsZmluZFZhckJ5S2V5OigpPT5vLGdldEdsb2JhbEludGVyZmFjZTooKT0+cyxnZXRPck1ha2VHbG9iYWxQcm9wZXJ0eTooKT0+YSx0cmF2ZXJzZVZhcnM6KCk9Pmh9KTt2YXIgaT17fTtmdW5jdGlvbiBzKCl7dmFyIHQ7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl0PXdpbmRvdztlbHNlIGlmKHZvaWQgMCE9PXIuZyl0PXIuZztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTt0PXNlbGZ9cmV0dXJuIHR9ZnVuY3Rpb24gYSh0LGUpe3ZhciByPXMoKTtyZXR1cm4gclt0XXx8KHJbdF09ZSksclt0XX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lPT09ZX0pKTp0W2VdfWZ1bmN0aW9uIHUodCxlKXt2YXIgcj1BcnJheS5pc0FycmF5KHQpLG49QXJyYXkuaXNBcnJheShlKT9lOltlXTtyP24uZm9yRWFjaCgoZnVuY3Rpb24oZSl7Zm9yKHZhciByPW51bGwsbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl0ubmFtZT09PWUubmFtZSl7cj1uO2JyZWFrfW51bGwhPT1yP3Rbcl09ZTp0LnB1c2goZSl9KSk6bi5mb3JFYWNoKChmdW5jdGlvbihlKXt0W2UubmFtZV09ZX0pKX1mdW5jdGlvbiBoKHQsZSl7QXJyYXkuaXNBcnJheSh0KT90LmZvckVhY2goKGZ1bmN0aW9uKHQpe2UodCl9KSk6T2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24ocil7ZSh0W3JdKX0pKX1mdW5jdGlvbiBjKHQpe2lmKHQub3BzPW51bGwsdC52YXJzIGluc3RhbmNlb2YgQXJyYXkpZm9yKHZhciBlPTA7ZTx0LnZhcnMubGVuZ3RoO2UrKyl0LnZhcnNbZV0uZGF0YSYmZGVsZXRlIHQudmFyc1tlXS5kYXRhO2Vsc2UgZm9yKHZhciByIGluIHQudmFycyl0LnZhcnNbcl0uZGF0YSYmZGVsZXRlIHQudmFyc1tyXS5kYXRhfXIucihpKSxyLmQoaSx7QnVmZmVyVHlwZTooKT0+dixHcmFwaFR5cGU6KCk9PnksVW5pZm9ybVR5cGU6KCk9Pm0sV2FzbU1lbW9yeVR5cGU6KCk9Pmd9KTtjb25zdCBwPWEoXCJlbnZcIixuZXcoZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5FTlY9e319cmV0dXJuIHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe3RoaXMuRU5WW3RdPWV9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5FTlZbdF19LHR9KCkpKTt2YXIgZj1mdW5jdGlvbih0LGUscixuKXtyZXR1cm4gbmV3KHJ8fChyPVByb21pc2UpKSgoZnVuY3Rpb24oaSxzKXtmdW5jdGlvbiBhKHQpe3RyeXt1KG4ubmV4dCh0KSl9Y2F0Y2godCl7cyh0KX19ZnVuY3Rpb24gbyh0KXt0cnl7dShuLnRocm93KHQpKX1jYXRjaCh0KXtzKHQpfX1mdW5jdGlvbiB1KHQpe3ZhciBlO3QuZG9uZT9pKHQudmFsdWUpOihlPXQudmFsdWUsZSBpbnN0YW5jZW9mIHI/ZTpuZXcgcigoZnVuY3Rpb24odCl7dChlKX0pKSkudGhlbihhLG8pfXUoKG49bi5hcHBseSh0LGV8fFtdKSkubmV4dCgpKX0pKX0sbD1mdW5jdGlvbih0LGUpe3ZhciByLG4saSxzLGE9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIHM9e25leHQ6bygwKSx0aHJvdzpvKDEpLHJldHVybjpvKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihzW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHM7ZnVuY3Rpb24gbyhzKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIGZ1bmN0aW9uKHMpe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDthOyl0cnl7aWYocj0xLG4mJihpPTImc1swXT9uLnJldHVybjpzWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sc1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYocz1bMiZzWzBdLGkudmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOmk9czticmVhaztjYXNlIDQ6cmV0dXJuIGEubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6YS5sYWJlbCsrLG49c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1hLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKChpPShpPWEudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pfHw2IT09c1swXSYmMiE9PXNbMF0pKXthPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighaXx8c1sxXT5pWzBdJiZzWzFdPGlbM10pKXthLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJmEubGFiZWw8aVsxXSl7YS5sYWJlbD1pWzFdLGk9czticmVha31pZihpJiZhLmxhYmVsPGlbMl0pe2EubGFiZWw9aVsyXSxhLm9wcy5wdXNoKHMpO2JyZWFrfWlbMl0mJmEub3BzLnBvcCgpLGEudHJ5cy5wb3AoKTtjb250aW51ZX1zPWUuY2FsbCh0LGEpfWNhdGNoKHQpe3M9WzYsdF0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLG9dKX19fTtjb25zdCBkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnVybENvbmY9e2RpcjpcIlwiLG1haW46XCJcIn0sdGhpcy5zZXBhcmF0ZUNodW5rPSEwLHRoaXMuY2h1bmtOdW09MSx0aGlzLmRhdGFUeXBlPVwiYmluYXJ5XCIsdGhpcy5wYXJhbXM9e3R5cGU6XCJmZXRjaFwifSx0aGlzLmluTm9kZT0hMSx0aGlzLmlzTG9jYWxGaWxlPSExLHRoaXMucmVhbEZldGNoPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGVtcHR5IGZldGNoIGZ1bmNpdG9uXCIpfTt2YXIgZT10LHI9XCJtb2RlbC5qc29uXCI7aWYodC5lbmRzV2l0aChcIi5qc29uXCIpKXt2YXIgbj10Lmxhc3RJbmRleE9mKFwiL1wiKSsxO2U9dC5zdWJzdHIoMCxuKSxyPXQuc3Vic3RyKG4pfWVsc2VcIi9cIiE9PXQuY2hhckF0KHQubGVuZ3RoLTEpJiYoZT10K1wiL1wiKTt0aGlzLmlzTG9jYWxGaWxlPTAhPT1lLmluZGV4T2YoXCJodHRwXCIpLHRoaXMudXJsQ29uZj17ZGlyOnRoaXMuaXNMb2NhbEZpbGU/XCIvXCI9PT1lLmNoYXJBdCgwKT9cIlwiK2U6XCIvXCIrZTplLG1haW46cn0sdGhpcy5pbk5vZGU9XCJub2RlXCI9PT1wLmdldChcInBsYXRmb3JtXCIpfXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIGYodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBsKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5mZXRjaE1vZGVsKCldO2Nhc2UgMTpyZXR1cm4gZT1yLnNlbnQoKSx0aGlzLnNlcGFyYXRlQ2h1bms9ISFlLmNodW5rTnVtJiZlLmNodW5rTnVtPjAsdGhpcy5jaHVua051bT10aGlzLnNlcGFyYXRlQ2h1bms/ZS5jaHVua051bTowLHRoaXMuc2VwYXJhdGVDaHVuaz9cImJpbmFyeVwiIT09dGhpcy5kYXRhVHlwZT9bMywzXTpbNCx0aGlzLmZldGNoQ2h1bmtzKCkudGhlbigoZnVuY3Rpb24ocil7cmV0dXJuIHQuYWxsb2NhdGVQYXJhbXNWYXIoZS52YXJzLHIpfSkpXTpbMywzXTtjYXNlIDI6ci5zZW50KCksci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMixlXX19KSl9KSl9LHQucHJvdG90eXBlLmZldGNoT25lQ2h1bms9ZnVuY3Rpb24odCl7cmV0dXJuIGYodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBsKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHAuZ2V0KFwiZmV0Y2hcIik/WzQscC5nZXQoXCJmZXRjaFwiKSh0LHt0eXBlOlwiYXJyYXlCdWZmZXJcIn0pXTpbMywyXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCldO2Nhc2UgMjpyZXR1cm5bMix0aGlzLmZldGNoKHQpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSldfX0pKX0pKX0sdC5wcm90b3R5cGUuZmV0Y2hKc29uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZldGNoKHQpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmpzb24oKX0pKX0sdC5wcm90b3R5cGUuZ2V0RmlsZU5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuXCJjaHVua19cIit0K1wiLmRhdFwifSx0LnByb3RvdHlwZS5mZXRjaENodW5rcz1mdW5jdGlvbigpe3JldHVybiBmKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLHI7cmV0dXJuIGwodGhpcywoZnVuY3Rpb24obil7Zm9yKHQ9dGhpcy5jaHVua051bSxlPVtdLHI9MTtyPD10O3IrKyllLnB1c2godGhpcy5mZXRjaE9uZUNodW5rKHRoaXMudXJsQ29uZi5kaXIrdGhpcy5nZXRGaWxlTmFtZShyKSkpO3JldHVyblsyLFByb21pc2UuYWxsKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciBlLHI9MCxuPVtdO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZT1uZXcgRmxvYXQzMkFycmF5KHQpLG4ucHVzaChlKSxyKz1lLmxlbmd0aH0pKTt2YXIgaT1uZXcgRmxvYXQzMkFycmF5KHIpLHM9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2lbc109dCxzKz0xfSkpfSkpLGl9KSldfSkpfSkpfSx0LmFsbG9jYXRlUGFyYW1zVmFyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbj0wLGk9QXJyYXkuaXNBcnJheShlKT9lOk9iamVjdC52YWx1ZXMoZSk7aCh0LChmdW5jdGlvbih0KXtyPXQuc2hhcGUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksdC5wZXJzaXN0YWJsZSYmKHQuZGF0YT1pLnNsaWNlKG4sbityKSxuKz1yKX0pKX0sdC5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24odCxlKXtpZihwLmdldChcImZldGNoXCIpKXJldHVybiBwLmdldChcImZldGNoXCIpKHQsZXx8e30pO3ZhciBuPShlfHx0aGlzLnBhcmFtcykubWV0aG9kfHxcImdldFwiLGk9bmV3KHRoaXMuaW5Ob2RlP3IoOTExKS5IZWFkZXJzOkhlYWRlcnMpO3JldHVybiB0aGlzLnJlYWxGZXRjaD10aGlzLmluTm9kZT90aGlzLmlzTG9jYWxGaWxlP3RoaXMuZmV0Y2hMb2NhbEZpbGU6cig5MTEpOndpbmRvdy5mZXRjaC5iaW5kKHdpbmRvdyksdGhpcy5yZWFsRmV0Y2godCx7bWV0aG9kOm4saGVhZGVyczppfSl9LHQucHJvdG90eXBlLmZldGNoTG9jYWxGaWxlPWZ1bmN0aW9uKHQpe3ZhciBlPXIoOTkzKTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbil7dHJ5e3IoZS5yZWFkRmlsZVN5bmModCxcInV0ZjhcIikpfWNhdGNoKHQpe24odCl9fSkpfSx0LnByb3RvdHlwZS5mZXRjaE1vZGVsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMucGFyYW1zLHI9dGhpcy51cmxDb25mLmRpcit0aGlzLnVybENvbmYubWFpbixuPW51bGw7cmV0dXJuXCJmZXRjaFwiPT09ZS50eXBlJiYobj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24obixpKXt0LmZldGNoKHIsZSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIHAuZ2V0KFwiZmV0Y2hcIik/ZTp0LmlzTG9jYWxGaWxlJiZ0LmluTm9kZT9KU09OLnBhcnNlKGUpOmUuanNvbigpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBpKHQpfSkpfSkpKSxufSx0fSgpO3ZhciB2LGcsbSx5OyFmdW5jdGlvbih0KXt0LkZyYW1lQnVmZmVyPVwiZnJhbWVCdWZmZXJcIix0LkNvbG9yQnVmZmVyPVwiY29sb3JCdWZmZXJcIn0odnx8KHY9e30pKSxmdW5jdGlvbih0KXt0Lm1lbW9yeTEwMD1cIjEwMFwiLHQubWVtb3J5MjAwPVwiMjAwXCIsdC5tZW1vcnkzMDA9XCIzMDBcIix0Lm1lbW9yeTQwMD1cIjQwMFwiLHQubWVtb3J5NTAwPVwiNTAwXCIsdC5tZW1vcnk2MDA9XCI2MDBcIix0Lm1lbW9yeTcwMD1cIjcwMFwiLHQubWVtb3J5ODAwPVwiODAwXCIsdC5tZW1vcnk5MDA9XCI5MDBcIn0oZ3x8KGc9e30pKSxmdW5jdGlvbih0KXt0LnVuaWZvcm0xZj1cIjFmXCIsdC51bmlmb3JtMWZ2PVwiMWZ2XCIsdC51bmlmb3JtMWk9XCIxaVwiLHQudW5pZm9ybTFpdj1cIjFpdlwiLHQudW5pZm9ybTJmPVwiMmZcIix0LnVuaWZvcm0yZnY9XCIyZnZcIix0LnVuaWZvcm0yaT1cIjJpXCIsdC51bmlmb3JtMml2PVwiMml2XCIsdC51bmlmb3JtM2Y9XCIzZlwiLHQudW5pZm9ybTNmdj1cIjNmdlwiLHQudW5pZm9ybTNpPVwiM2lcIix0LnVuaWZvcm0zaXY9XCIzaXZcIix0LnVuaWZvcm00Zj1cIjRmXCIsdC51bmlmb3JtNGZ2PVwiNGZ2XCIsdC51bmlmb3JtNGk9XCI0aVwiLHQudW5pZm9ybTRpdj1cIjRpdlwifShtfHwobT17fSkpLGZ1bmN0aW9uKHQpe3QuU2luZ2xlT3V0cHV0PVwic2luZ2xlXCIsdC5NdWx0aXBsZU91dHB1dD1cIm11bHRpcGxlXCIsdC5NdWx0aXBsZUlucHV0PVwibXVsdGlwbGVJbnB1dFwifSh5fHwoeT17fSkpO3ZhciBiPXtvcFJlZ2lzdHJ5OntvcHM6e319LGJhY2tlbmQ6XCJcIixiYWNrZW5kSW5zdGFuY2U6bnVsbH07ZnVuY3Rpb24gdyh0LGUpe3ZhciByPXQuY29uZixuPXQucGFyYW1zLGk9dC5tYWluLHM9dC5tYWluRnVuYyxhPXQudGV4dHVyZUZ1bmNDb25mLG89dC5jb21tb25GdW5jQ29uZix1PXQuYmVoYXZpb3JzLGg9dm9pZCAwPT09dT9bXTp1LGM9Yi5iYWNrZW5kK1wiX1wiK2U7Yi5vcFJlZ2lzdHJ5Lm9wc1tjXXx8KGIub3BSZWdpc3RyeS5vcHNbY109e25hbWU6ZSxjb25mOnIscGFyYW1zOm4sbWFpbjppLG1haW5GdW5jOnMsdGV4dHVyZUZ1bmNDb25mOmEsY29tbW9uRnVuY0NvbmY6byxiZWhhdmlvcnM6aH0pfWZ1bmN0aW9uIF8odCxlLHIpe3QmJihiLmJhY2tlbmQ9dCksZSYmKGIuYmFja2VuZEluc3RhbmNlPWUpLHImJk9iamVjdC5rZXlzKHIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3coclt0XSx0KX0pKX1iPWEoXCJHTE9CQUxTXCIsYik7dmFyIEE9cygpO0EuSW1hZ2VCaXRtYXB8fChBLkltYWdlQml0bWFwPWZ1bmN0aW9uKCl7fSk7Y29uc3QgeD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmlkPVwiXCIsdGhpcy50eXBlPVwiXCIsdGhpcy5pbnB1dHM9e30sdGhpcy5vdXRwdXRzPXt9LHRoaXMuYXR0cnM9e30sdGhpcy5zdWJBdHRycz1bXSx0aGlzLm5leHQ9XCJcIix0aGlzLm9wRGF0YT1udWxsLHRoaXMuaXNQYWNrZWQ9ITEsdGhpcy5idWZmZXJUeXBlPXYuRnJhbWVCdWZmZXIsdGhpcy51bmlmb3JtPW51bGw7dmFyIHI9dC5pbnB1dHMsbj10Lm91dHB1dHMsaT10LmF0dHJzLHM9dm9pZCAwPT09aT97fTppLGE9dC50eXBlLG89dC5pc1BhY2tlZCx1PXZvaWQgMCE9PW8mJm8saD10LmJ1ZmZlclR5cGUsYz12b2lkIDA9PT1oP3YuRnJhbWVCdWZmZXI6aCxwPXQudW5pZm9ybSxmPXZvaWQgMD09PXA/bnVsbDpwO3RoaXMuaWQ9YStcIl9cIisgK25ldyBEYXRlK1wiX1wiK2UsdGhpcy5pbnB1dHM9cix0aGlzLm91dHB1dHM9bix0aGlzLmF0dHJzPXMsdGhpcy5zdWJBdHRycz10W1wic3ViLWF0dHJzXCJdfHxbXSx0aGlzLnVuaWZvcm09Zix0aGlzLnR5cGU9YSx0aGlzLmlzUGFja2VkPXUsdGhpcy5idWZmZXJUeXBlPWMsdGhpcy5uZXh0PVwiXCIsdGhpcy5vcERhdGE9bnVsbH1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW5wdXRzTmFtZVwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaW5wdXRzKS5mb3JFYWNoKChmdW5jdGlvbihyKXtlLnB1c2godC5pbnB1dHNbcl1bMF0pfSkpLGV9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0c05hbWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0cHV0cy5PdXRwdXR8fHRoaXMub3V0cHV0cy5PdXR8fHRoaXMub3V0cHV0cy5ZfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24odCl7Yi5iYWNrZW5kSW5zdGFuY2UucnVuUHJvZ3JhbSh0aGlzLm9wRGF0YSx0KX0sdH0oKSxrPWZ1bmN0aW9uKHQpe3RoaXMubmFtZT10fTt2YXIgTyxQPShPPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKE89T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fU8odCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihyLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgcil9KSxUPXtjb252MmQ6ZnVuY3Rpb24odCxlKXt2YXIgcj10LmF0dHJzLnN0cmlkZXMsbj10LmlucHV0cy5JbnB1dFswXSxpPXQuaW5wdXRzLkZpbHRlclswXTtpZihcImltYWdlXCI9PT1uKXJldHVybiExO3ZhciBzPW8oZSxuKS5zaGFwZSxhPW8oZSxpKS5zaGFwZTtyZXR1cm4hci5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdD4xfSkpJiZzW3MubGVuZ3RoLTEtMl0lND09MCYmND09PWEubGVuZ3RoJiZhWzBdJTQ9PTAmJmFbMV0lND09MH19O2Z1bmN0aW9uIGoodCl7cmV0dXJue3R5cGU6XCJwYWNrZWRfMl91bnBhY2tlZFwiLGF0dHJzOnt9LGlucHV0czp7SW5wdXQ6W3QuaW5wdXROYW1lXX0sb3V0cHV0czp7T3V0cHV0Olt0Lm91dHB1dE5hbWVdfX19ZnVuY3Rpb24gTSh0KXtyZXR1cm57dHlwZTpcInVucGFja2VkXzJfcGFja2VkXCIsYXR0cnM6e30saW5wdXRzOntJbnB1dDpbdC5pbnB1dE5hbWVdfSxvdXRwdXRzOntPdXRwdXQ6W3Qub3V0cHV0TmFtZV19fX1mdW5jdGlvbiBFKHQsZSl7T2JqZWN0LmtleXModC5pbnB1dHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuaW5wdXRzW2VdPVt0LmlucHV0c1tlXStcIl9wYWNrZWRcIl19KSksT2JqZWN0LmtleXModC5vdXRwdXRzKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0Lm91dHB1dHNbZV09W3Qub3V0cHV0c1tlXStcIl9wYWNrZWRcIl19KSksdC50eXBlPXQudHlwZStcIl9wYWNraW5nXCIsdC5pZD10LnR5cGUrXCJfXCIrICtuZXcgRGF0ZStcIl9cIitlLmxlbmd0aCx0LmlzUGFja2VkPSEwfWNvbnN0IEY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiB0LmNhbGwodGhpcyxcIlRleHR1cmVQYWNraW5nXCIpfHx0aGlzfXJldHVybiBQKGUsdCksZS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO2lmKFwid2ViZ2xcIj09PWIuYmFja2VuZCYmcC5nZXQoXCJ3ZWJnbF9wYWNrX2NoYW5uZWxcIikpe3ZhciByPXRbMF0sbj10WzFdLGk9dFsyXSxzPVwiZGVwdGh3aXNlX2NvbnYyZFwiPT09ci50eXBlP1wiY29udjJkXCI6ci50eXBlLGE9VFtzXTtpZihhJiZhKHIsbikpe3ZhciBvPXIuaW5wdXRzLHU9ci5vdXRwdXRzLGg9by5JbnB1dFswXSxjPXUuT3V0cHV0P3UuT3V0cHV0WzBdOnUuT3V0WzBdLGY9TSh7aW5wdXROYW1lOmgsb3V0cHV0TmFtZTpoK1wiX3BhY2tlZFwifSksbD1pLmxlbmd0aDtpLnB1c2gobmV3IHgoZixsKSksRShyLGkpO3ZhciBkPWooe2lucHV0TmFtZTpjK1wiX3BhY2tlZFwiLG91dHB1dE5hbWU6Y30pLHY9aS5sZW5ndGgrMTtpLnB1c2gobmV3IHgoZCx2KSl9fX0sZX0oayk7dmFyIEQ9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybih0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX0pKGUscil9O3JldHVybiBmdW5jdGlvbihlLHIpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLHIpLGUucHJvdG90eXBlPW51bGw9PT1yP09iamVjdC5jcmVhdGUocik6KG4ucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyBuKX19KCk7Y29uc3QgTj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHQuY2FsbCh0aGlzLFwiRm9ybWF0SW5wdXRzWFwiKXx8dGhpc31yZXR1cm4gRChlLHQpLGUucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTt2YXIgcj10WzBdLG49W1wiY29uY2F0XCIsXCJjb25uZWN0XCIsXCJmY1wiLFwicm5uX29yaWdpblwiLFwicm5uX21hdG11bFwiLFwic3RhY2tcIl07aWYobi5pbmNsdWRlcyhyLnR5cGUpKXt2YXIgaT1yLmlucHV0cztpZigoXCJybm5fb3JpZ2luXCI9PT1yLnR5cGV8fFwicm5uX21hdG11bFwiPT09ci50eXBlKSYmaS5XZWlnaHRMaXN0Lmxlbmd0aD4wKWkuV2VpZ2h0TGlzdC5mb3JFYWNoKChmdW5jdGlvbih0LGUpe2lbXCJ3ZWlnaHRsaXN0X1wiK2VdPVt0XX0pKTtlbHNle3ZhciBzPWkuWHx8aS5JbnB1dDtpZihcIndhc21cIiE9PXAuZ2V0KFwiYmFja2VuZFwiKSlzLmxlbmd0aD4xJiYocy5mb3JFYWNoKChmdW5jdGlvbih0LGUpe2lbXCJvcmlnaW5cIisoZT4wP1wiX1wiK2U6XCJcIildPVt0XX0pKSxkZWxldGUgaS5YLGRlbGV0ZSBpLklucHV0KTtlbHNle2lmKHMubGVuZ3RoPjQpdGhyb3cgRXJyb3IoXCJOb3QgeWV0IHN1cHBvcnRpbmcgY29uY2F0IGlucHV0IHRlbnNvcnMgbW9yZSB0aGFuIDQuXCIpO2lmKHMubGVuZ3RoPjEpe3ZhciBhPXNbMF0sbz1zWzFdLHU9c1syXSxoPXNbM107aS5YPVthXSxvJiYoaS5ZPVtvXSksdSYmKGkuWj1bdV0sci50eXBlKz1cIl9tdWxcIiksaCYmKGkuTT1baF0pfX19fX0sZX0oayk7dmFyIFM9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybih0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX0pKGUscil9O3JldHVybiBmdW5jdGlvbihlLHIpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLHIpLGUucHJvdG90eXBlPW51bGw9PT1yP09iamVjdC5jcmVhdGUocik6KG4ucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyBuKX19KCksQz1mdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MCxyPWFyZ3VtZW50cy5sZW5ndGg7ZTxyO2UrKyl0Kz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciBuPUFycmF5KHQpLGk9MDtmb3IoZT0wO2U8cjtlKyspZm9yKHZhciBzPWFyZ3VtZW50c1tlXSxhPTAsbz1zLmxlbmd0aDthPG87YSsrLGkrKyluW2ldPXNbYV07cmV0dXJuIG59O2Z1bmN0aW9uIEkodCxlKXt2YXIgcj1vKGUsdCk7cmV0dXJuIHI/ci5zaGFwZTpbXX1mdW5jdGlvbiBMKHQsZSxyLG4pe2Zvcih2YXIgaT1DKGUpLHM9MCxhPTAsbz10O2E8by5sZW5ndGg7YSsrKXMrPUkob1thXSxuKVtyXTtyZXR1cm4gaVtyXT1zLHtuYW1lOnRbdC5sZW5ndGgtMV0rXCJfb3V0XCIsc2hhcGU6aX19Y29uc3QgUj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHQuY2FsbCh0aGlzLFwic3BsaXRPcFwiKXx8dGhpc31yZXR1cm4gUyhlLHQpLGUucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbigpe2Zvcih2YXIgdCxlPVtdLHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWVbcl09YXJndW1lbnRzW3JdO2Zvcih2YXIgbj1lWzBdLGk9ZVsxXSxzPTAsYT1uLmxlbmd0aDtzPGE7cysrKXt2YXIgbz1uW3NdO2lmKFwiY29uY2F0XCI9PT1vLnR5cGUmJihudWxsPT09KHQ9by5pbnB1dHMpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LlgpJiYhKG8uaW5wdXRzLlgubGVuZ3RoPD00KSl7dmFyIGg9by5hdHRycyxjPW8uaW5wdXRzLHA9by5vdXRwdXRzLGY9Yy5YLGw9Zi5sZW5ndGgsZD1NYXRoLmNlaWwoKGwtNCkvMykrMSx2PXAuT3V0WzBdLGc9SSh2LGkpLG09aC5heGlzfHwwO209bT4tMT9tOmcubGVuZ3RoK207Zm9yKHZhciB5PVtdLGI9W10sdz1mLnNsaWNlKDAsNCksXz12b2lkIDAsQT0wO0E8ZDtBKyspe3ZhciB4PTA9PT1BP3c6Zi5zbGljZSgzKkErMSwzKihBKzEpKzEpLGs9TCh4LGcsbSxpKTswIT09QSYmeC5zcGxpY2UoMCwwLF8ubmFtZSksay5zaGFwZVttXSs9Xz9fLnNoYXBlW21dOjA7dmFyIE89e091dDpbay5uYW1lXX07Yi5wdXNoKHthdHRyczpoLGlucHV0czp7WDp4fSxvdXRwdXRzOk8sdHlwZTpcImNvbmNhdFwifSkseS5wdXNoKGspLF89a31iW2QtMV0ub3V0cHV0cy5PdXQ9W3ZdLG4uc3BsaWNlLmFwcGx5KG4sQyhbcywxXSxiKSksdShpLHkpfX19LGV9KGspO3ZhciBXPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLHI9YXJndW1lbnRzLmxlbmd0aDtlPHI7ZSsrKXQrPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG49QXJyYXkodCksaT0wO2ZvcihlPTA7ZTxyO2UrKylmb3IodmFyIHM9YXJndW1lbnRzW2VdLGE9MCxvPXMubGVuZ3RoO2E8bzthKyssaSsrKW5baV09c1thXTtyZXR1cm4gbn07ZnVuY3Rpb24gSCh0KXtpZih0Lmxlbmd0aDw0KXtmb3IodmFyIGU9W10scj0wO3I8NC10Lmxlbmd0aDtyKyspZS5wdXNoKDEpO3JldHVybiBlLmNvbmNhdCh0KX1yZXR1cm4gVyh0KX1mdW5jdGlvbiBCKHQpe3JldHVybiB0LnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSkpfWZ1bmN0aW9uIEcodCxlKXt2YXIgcj10Lmxlbmd0aDtyZXR1cm4gNC1yKyhlPi0xP2U6citlKX1mdW5jdGlvbiB6KHQsZSl7Zm9yKHZhciByPWVbMF0sbj1lWzFdLGk9ZVsyXSxzPWVbM10sYT1pKnMsbz1uKmkqcyx1PVtdLGg9MDtoPHI7aCsrKWZvcih2YXIgYz0wO2M8cztjKyspZm9yKHZhciBwPTA7cDxuO3ArKylmb3IodmFyIGY9MDtmPGk7ZisrKXUucHVzaCh0W2gqbytwKmErZipzK2NdKTtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh1KX1mdW5jdGlvbiBYKHQpe2Zvcih2YXIgZSxyPXQuZGF0YSxuPXQuc2hhcGUsaT1XKG4pLnJldmVyc2UoKSxzPTAsYT1pLmxlbmd0aC0xO3M8YTtzKyspZT1WKGV8fHIsaVtzXSk7cmV0dXJuIGV9ZnVuY3Rpb24gVih0LGUpe2Zvcih2YXIgcj1bXSxuPTAsaT10Lmxlbmd0aDtuPGk7bis9ZSlyLnB1c2godC5zbGljZShuLG4rZSkpO3JldHVybiByfXZhciBVPWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9KShlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxyKSxlLnByb3RvdHlwZT1udWxsPT09cj9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpLFk9XCJmZXRjaF9wYWNrXCI7Y29uc3QgcT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHQuY2FsbCh0aGlzLFwiUGFja091dFwiKXx8dGhpc31yZXR1cm4gVShlLHQpLGUucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtpZihwLmdldChcIndlYmdsX3BhY2tfb3V0cHV0XCIpJiYxIT09cC5nZXQoXCJ3ZWJnbFZlcnNpb25cIikpe3ZhciByPXRbMF0sbj10WzFdLGk9ci5maW5kKChmdW5jdGlvbih0KXtyZXR1cm5cImZldGNoXCI9PT10LnR5cGV9KSkscz1pLmlucHV0cy5YWzBdLGE9byhuLHMpLGg9SChhLnNoYXBlKSxjPWhbMF0sZj1oWzFdLGw9aFsyXSxkPWhbM10sdj17YXR0cnM6e30saW5wdXRzOntYOltzXX0sb3V0cHV0czp7WTpbWV19LHR5cGU6XCJwYWNrX291dFwifSxnPWYqZCxtPU1hdGguY2VpbChjKmwvNCkseT17bmFtZTpZLHNoYXBlOlsxLDEsbSxnXSxwZXJzaXN0YWJsZTohMX07aS5pbnB1dHMuWD1bWV0saS5hdHRycy5vcmlnaW5fc2hhcGU9W2MsZixsLGRdLHIucHVzaCh2KSx1KG4sW3ldKX19LGV9KGspO3ZhciBKPWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9KShlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxyKSxlLnByb3RvdHlwZT1udWxsPT09cj9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpLEs9XCJpbWdfcHJlX3Byb2Nlc3NlZFwiLFo9XCJpbWdfb3JpZ2luXCI7Y29uc3QgJD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHQuY2FsbCh0aGlzLFwiRmVlZFByb2Nlc3NcIil8fHRoaXN9cmV0dXJuIEooZSx0KSxlLnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07dmFyIHI9dFswXSxuPXRbMV0saT10WzJdO2lmKGkud2ViZ2xGZWVkUHJvY2Vzc3x8cC5nZXQoXCJ3ZWJnbF9ncHVfcGlwZWxpbmVcIikpe3ZhciBzPWkubWVhbixhPXZvaWQgMD09PXM/WzAsMCwwXTpzLGg9aS5zdGQsYz12b2lkIDA9PT1oP1sxLDEsMV06aCxmPWkuc2NhbGUsbD12b2lkIDA9PT1mP1sxLDFdOmYsZD1pLnBvcyx2PXZvaWQgMD09PWQ/WzAsMF06ZCxnPWkuZmVlZFNoYXBlLHk9byhuLFwiaW1hZ2VcIiksYj15LnNoYXBlLHc9YlsyXSxfPWJbM107eS5zaGFwZT1bMSwxLHcsX107dmFyIEE9T2JqZWN0LmFzc2lnbih7fSx5KTtBLm5hbWU9SyxBLnNoYXBlPVsxLDMsZy5maCxnLmZ3XSxBLnBlcnNpc3RhYmxlPSExLGRlbGV0ZSBBLmRhdGE7dmFyIHg9T2JqZWN0LmFzc2lnbih7fSx5KTt4Lm5hbWU9Wix4LnNoYXBlPVsxLDEsZy5maCxnLmZ3XSx4LnBlcnNpc3RhYmxlPSExLGRlbGV0ZSB4LmRhdGEsdShuLFt4LEFdKTt2YXIgaz1yLmZpbmQoKGZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzO3JldHVybiBPYmplY3Qua2V5cyhlKS5maW5kKChmdW5jdGlvbih0KXtyZXR1cm5cImltYWdlXCI9PT1lW3RdWzBdfSkpfSkpLE89ay5pbnB1dHM7T2JqZWN0LmtleXMoTykuZm9yRWFjaCgoZnVuY3Rpb24odCl7XCJpbWFnZVwiPT09T1t0XVswXSYmKE9bdF1bMF09Syl9KSk7dmFyIFA9e2F0dHJzOnttZWFuOmEsc3RkOmN9LGlucHV0czp7WDpbWl19LG91dHB1dHM6e1k6W0tdfSx0eXBlOlwiZmVlZFBvc3RcIn0sVD17YXR0cnM6e21lYW46YSxzdGQ6YyxzY2FsZTpsLHBvczp2fSxpbnB1dHM6e1g6W1wiaW1hZ2VcIl19LG91dHB1dHM6e1k6W1pdfSx0eXBlOlwiaW1nRmVlZFwiLHVuaWZvcm06e3Vfc2NhbGU6e3R5cGU6bS51bmlmb3JtMmZ2LHZhbHVlOlsxLDFdfSx1X3Bvczp7dHlwZTptLnVuaWZvcm0yZnYsdmFsdWU6WzAsMF19LHVfa2VlcF9yYXRpbzp7dHlwZTptLnVuaWZvcm0xaSx2YWx1ZToxfX0saXNQYWNrZWQ6ITB9O3Iuc3BsaWNlKDEsMCxQKSxyLnNwbGljZSgxLDAsVCl9fSxlfShrKSxRPXtwcmVUcmFuc2Zvcm1zOltuZXcgUixuZXcgcSxuZXcgJF0sdHJhbnNmb3JtczpbbmV3IE4sbmV3IEZdLHBvc3RUcmFuc2Zvcm1zOltdfTt2YXIgdHQsZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTAscj1hcmd1bWVudHMubGVuZ3RoO2U8cjtlKyspdCs9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgbj1BcnJheSh0KSxpPTA7Zm9yKGU9MDtlPHI7ZSsrKWZvcih2YXIgcz1hcmd1bWVudHNbZV0sYT0wLG89cy5sZW5ndGg7YTxvO2ErKyxpKyspbltpXT1zW2FdO3JldHVybiBufTtmdW5jdGlvbiBydCh0LGUpe3JldHVybiB0JiZ0W2VdfHxbXX0hZnVuY3Rpb24odCl7dC5QcmVUcmFuc2Zvcm1zPVwicHJlVHJhbnNmb3Jtc1wiLHQuVHJhbnNmb3Jtcz1cInRyYW5zZm9ybXNcIix0LlBvc3RUcmFuc2Zvcm1zPVwicG9zdFRyYW5zZm9ybXNcIn0odHR8fCh0dD17fSkpO2NvbnN0IG50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMud2VpZ2h0TWFwPVtdLHRoaXMub3BzPVtdLHRoaXMudmFycz1bXSx0aGlzLmNvbmZpZz17fSx0aGlzLnR5cGU9eS5TaW5nbGVPdXRwdXQsdGhpcy5wbHVnaW5zPW51bGwsdGhpcy5vcHM9dC5vcHMsdGhpcy52YXJzPXQudmFycyx0aGlzLnR5cGU9ZS50eXBlfHx0aGlzLnR5cGUsdGhpcy5wbHVnaW5zPWUucGx1Z2lucyx0aGlzLmNvbmZpZz1lLHQuZmVlZFNoYXBlJiYodGhpcy5jb25maWcuZmVlZFNoYXBlPXQuZmVlZFNoYXBlKX1yZXR1cm4gdC5wcm90b3R5cGUuY3JlYXRlR3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVUcmFuc2Zvcm1zKCksdGhpcy5jcmVhdGVPcHNNYXAoKSx0aGlzLmFycmFuZ2VNYXAoKSx0aGlzLnBvc3RUcmFuc2Zvcm1zKCksdGhpcy53ZWlnaHRNYXB9LHQucHJvdG90eXBlLnByZVRyYW5zZm9ybXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2V0KFEucHJlVHJhbnNmb3JtcyxydCh0aGlzLnBsdWdpbnMsdHQuUHJlVHJhbnNmb3JtcykpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UudHJhbnNmb3JtKHQub3BzLHQudmFycyx0LmNvbmZpZyl9KSl9LHQucHJvdG90eXBlLnRyYW5zZm9ybXM9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO2V0KFEudHJhbnNmb3JtcyxydCh0aGlzLnBsdWdpbnMsdHQuVHJhbnNmb3JtcykpLmZvckVhY2goKGZ1bmN0aW9uKG4pe24udHJhbnNmb3JtKHQsci52YXJzLGUpfSkpfSx0LnByb3RvdHlwZS5wb3N0VHJhbnNmb3Jtcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7ZXQoUS5wb3N0VHJhbnNmb3JtcyxydCh0aGlzLnBsdWdpbnMsdHQuUG9zdFRyYW5zZm9ybXMpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnRyYW5zZm9ybSh0LndlaWdodE1hcCx0LnZhcnMsdC50eXBlKX0pKX0sdC5wcm90b3R5cGUuY3JlYXRlT3BzTWFwPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPHRoaXMub3BzLmxlbmd0aDtlKyspe3ZhciByPXQubGVuZ3RoLG49dGhpcy5vcHNbZV0saT1uZXcgeChuLHIpO3RoaXMudHJhbnNmb3JtcyhpLHQpLHQucHVzaChpKX10aGlzLndlaWdodE1hcD10fSx0LnByb3RvdHlwZS5hcnJhbmdlTWFwPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LGU9W10scj17fSxuPWZ1bmN0aW9uKG4pe2Zvcih2YXIgcz1pLndlaWdodE1hcFtuXSxhPTA7YTxzLm91dHB1dHNOYW1lLmxlbmd0aDthKyspe3ZhciBvPXMub3V0cHV0c05hbWVbYV07dFtvXT0hMH1lW25dPTAscltzLmlkXT1uLHMuaW5wdXRzTmFtZS5sZW5ndGg+MT9zLmlucHV0c05hbWUuZm9yRWFjaCgoZnVuY3Rpb24ocil7ITA9PT10W3JdJiZlW25dKyt9KSk6ZVtuXT1zLmlucHV0c05hbWUubGVuZ3RofSxpPXRoaXMscz0wO3M8dGhpcy53ZWlnaHRNYXAubGVuZ3RoO3MrKyluKHMpO3RoaXMudG9wb1NvcnQodGhpcy53ZWlnaHRNYXAsZSxyKX0sdC5wcm90b3R5cGUudG9wb1NvcnQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPVtdO24ucHVzaCh0WzBdKTtmb3IodmFyIGk9dC5zbGljZSgwKSxzPW51bGwsYT10WzBdO24ubGVuZ3RoPjA7KXtudWxsIT1zJiYodFtyW3MuaWRdXS5uZXh0PWEuaWQpLHM9YSxhPW4ucG9wKCl8fHt9O2Zvcih2YXIgbz0wO288YS5vdXRwdXRzTmFtZS5sZW5ndGg7bysrKWZvcih2YXIgdT0wO3U8aS5sZW5ndGg7dSsrKWZvcih2YXIgaD0wO2g8aVt1XS5pbnB1dHNOYW1lLmxlbmd0aDtoKyspaWYoaVt1XS5pbnB1dHNOYW1lW2hdPT09YS5vdXRwdXRzTmFtZVtvXSYmKGVbcltpW3VdLmlkXV0tLSwwPT09ZVtyW2lbdV0uaWRdXSkpe24ucHVzaCh0W3JbaVt1XS5pZF1dKSxpLnNwbGljZSh1LDEpLHUtLTticmVha319fSx0LnByb3RvdHlwZS5nZXRGZWVkRXhlY3V0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXAuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuXCJmZWVkXCI9PT10LnR5cGV9KSl9LHQucHJvdG90eXBlLmdldEZldGNoRXhlY3V0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXAuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuXCJmZXRjaFwiPT09dC50eXBlfSkpfSx0LnByb3RvdHlwZS5nZXRFeGVjdXRvckJ5SWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMud2VpZ2h0TWFwLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09dH0pKX0sdH0oKSxpdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vcHRzPXt9LHRoaXMuaXNQYWNrZWQ9ITEsdGhpcy5uYW1lPVwiXCIsdGhpcy50ZW5zb3JJZD1cIlwiLHRoaXMudG90YWw9MSx0aGlzLnNoYXBlPVtdLHRoaXMudW5mb3JtYXR0ZWRTaGFwZUxlbmd0aD0wLHRoaXMuc2hhcGVfdGV4dHVyZT1bXSx0aGlzLmV4Y2VlZE1heD0hMSx0aGlzLmRhdGE9bnVsbCx0aGlzLnBlcnNpc3RhYmxlPSExLHRoaXMuaW50ZXJwVHlwZT1cIk5FQVJFU1RcIix0aGlzLmRhdGFMYXlvdXQ9XCJcIix0aGlzLnJ1bnRpbWU9MCx0aGlzLmJpbmRpbmc9MDt2YXIgZT10LmlzUGFja2VkLHI9dm9pZCAwIT09ZSYmZSxuPXQubmFtZSxpPXQucnVudGltZSxzPXZvaWQgMD09PWk/MDppLGE9dC5wZXJzaXN0YWJsZSxvPXZvaWQgMCE9PWEmJmEsdT10LnR5cGUsaD10LmRhdGFMYXlvdXQsYz10LmludGVycFR5cGUscD12b2lkIDA9PT1jP1wiTkVBUkVTVFwiOmMsZj10LnNoYXBlLGw9dC5kYXRhLGQ9dC5iaW5kaW5nLHY9dm9pZCAwPT09ZD8wOmQ7dGhpcy5vcHRzPXQsdGhpcy5pc1BhY2tlZD1yLHRoaXMubmFtZT1uLHRoaXMucnVudGltZT1zLHRoaXMuYmluZGluZz12LHRoaXMucGVyc2lzdGFibGU9byx0aGlzLmludGVycFR5cGU9cCx0aGlzLnRlbnNvcklkPXUsdGhpcy5kYXRhTGF5b3V0PWgsdGhpcy51bmZvcm1hdHRlZFNoYXBlTGVuZ3RoPWYubGVuZ3RoLHRoaXMuc2hhcGU9SChmKSx0aGlzLnRvdGFsPXRoaXMuc2hhcGUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksdC5ub0xheW91dHx8bCYmbC5sZW5ndGgmJih0aGlzLmRhdGE9ZnVuY3Rpb24odCxlLHIsbil7aWYoXCJuaHdjXCI9PT1lKXt2YXIgaT1yWzBdLHM9clsxXSxhPXoodCxbaSxyWzJdLHJbM10scyoobj80OjEpXSk7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYSl9cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCl9KGwsdGhpcy5kYXRhTGF5b3V0LHRoaXMuc2hhcGUsdGhpcy5pc1BhY2tlZCksdC5kYXRhPW51bGwpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ3aWR0aF90ZXh0dXJlXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2hhcGVfdGV4dHVyZS5sZW5ndGg7cmV0dXJuIHRoaXMuc2hhcGVfdGV4dHVyZVt0LTFdfHwxfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImhlaWdodF90ZXh0dXJlXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2hhcGVfdGV4dHVyZS5sZW5ndGg7cmV0dXJuIHRoaXMuc2hhcGVfdGV4dHVyZVt0LTJdfHwxfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIndpZHRoX3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2hhcGUubGVuZ3RoO3JldHVybiB0aGlzLnNoYXBlW3QtMV19LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaGVpZ2h0X3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2hhcGUubGVuZ3RoO3JldHVybiB0aGlzLnNoYXBlW3QtMl19LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiY2hhbm5lbFwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNoYXBlLmxlbmd0aDtyZXR1cm4gdGhpcy5zaGFwZVt0LTNdfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImxlbmd0aF9zaGFwZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh8fDB9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibGVuZ3RoX3VuZm9ybWF0dGVkX3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuZm9ybWF0dGVkU2hhcGVMZW5ndGh8fDB9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidG90YWxfc2hhcGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG90YWx9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibnVtYmVyc19zaGFwZVwiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT10aGlzLnNoYXBlLmxlbmd0aCxyPTA7cjxlLTE7cisrKXt2YXIgbj10aGlzLnNoYXBlLnNsaWNlKHIrMSkucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSk7dC5wdXNoKG4pfXJldHVybiB0LnB1c2goMSksdH0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSx0fSgpLHN0PXthZGFwdFBhZGRpbmdzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucHJvY2Vzc2VkQXR0cnMpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvY2Vzc2VkQXR0cnMsdCkmJlwicGFkZGluZ3NcIj09PXQpe3ZhciBlPXRoaXMucHJvY2Vzc2VkQXR0cnNbdF0scj1lWzBdLG49ZVsxXTtyZXR1cm4gdm9pZCgwPT09ciYmMT09PW4mJih0aGlzLnByb2Nlc3NlZEF0dHJzW3RdWzFdPTApKX19LHNldEFkYXB0aXZlOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hZGFwdGl2ZSYmMj09PXRoaXMucHJvY2Vzc2VkQXR0cnMua3NpemUubGVuZ3RoJiYxPT09dGhpcy5wcm9jZXNzZWRBdHRycy5rc2l6ZVswXSYmMT09PXRoaXMucHJvY2Vzc2VkQXR0cnMua3NpemVbMV0mJih0aGlzLnByb2Nlc3NlZEF0dHJzLmFkYXB0aXZlPSExLHRoaXMucHJvY2Vzc2VkQXR0cnMuZ2xvYmFsX3Bvb2xpbmc9ITApfSxpc0dsb2JhbFBvb2xpbmc6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4scj0obnVsbD09PSh0PW51bGw9PWU/dm9pZCAwOmUuc2hhcGUpfHx2b2lkIDA9PT10P3ZvaWQgMDp0Lmxlbmd0aCl8fDA7cj4yJiZ0aGlzLnByb2Nlc3NlZEF0dHJzLmdsb2JhbF9wb29saW5nJiYodGhpcy5wcm9jZXNzZWRBdHRycy5rc2l6ZT1bZS5zaGFwZVtyLTJdLGUuc2hhcGVbci0xXV0pfSxzZXRQYWNrZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb2Nlc3NlZEF0dHJzLmlzcGFja2VkO3RoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4mJnQmJnRoaXMubmFtZS5pbmRleE9mKFwicG9vbFwiKT4tMSYmKHRoaXMubmFtZSs9XCJfd2lub2dyYWRcIil9LG1lcmdlQXR0cnM6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3NlZEF0dHJzPXRoaXMuc3ViQXR0cnMucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QuYXNzaWduKHQsZSl9KSx7fSl9LGlzQXBwbHlTZXBhcmFibGVDb252OmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNQYWNrZWRPcCl7dmFyIHQ9dGhpcy5wcm9jZXNzZWRBdHRycy5ncm91cHMsZT10aGlzLnRlbnNvckRhdGFNYXAuZmlsdGVyO2lmKFwiZGVwdGh3aXNlX2NvbnYyZFwiPT09dGhpcy5uYW1lJiYodGhpcy5uYW1lPVwiY29udjJkXCIpLGUpe3ZhciByPWUuc2hhcGUsbj1yWzBdLGk9clsxXTtuPT09dCYmMT09PWkmJih0aGlzLm5hbWUrPVwiX2RlcHRod2lzZVwiKX19fSxiYXRjaENvbXB1dGVDb252MmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnRlbnNvckRhdGFNYXAuZmlsdGVyLnNoYXBlWzFdO3RoaXMucHJvY2Vzc2VkQXR0cnMuZmlsdGVyX25lYXJlc3RfdmVjND00Kk1hdGguZmxvb3IodC80KSx0aGlzLnByb2Nlc3NlZEF0dHJzLmZpbHRlcl9yZW1haW5kZXJfdmVjND10JTR9LHByb2Nlc3NCaWFzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50ZW5zb3JEYXRhTWFwLmJpYXM7aWYodCYmdGhpcy5pc1BhY2tlZE9wKXt0LnBhY2tlZD0hMDt2YXIgZT10LnNoYXBlLHI9W2VbZS5sZW5ndGgtMV0vNCwxLDFdO3Quc2hhcGU9cn19LGlzQWRhcHRpdmVBdmc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnByb2Nlc3NlZEF0dHJzLGU9dC5hZGFwdGl2ZSxyPXQucG9vbGluZ190eXBlO2UmJlwiYXZnXCI9PT1yJiYodGhpcy5uYW1lKz1cIl9hdmdfYWRhcHRpdmVcIil9LGlzTWF4OmZ1bmN0aW9uKCl7dmFyIHQ9XCJtYXhcIj09PXRoaXMucHJvY2Vzc2VkQXR0cnMucG9vbGluZ190eXBlPzE6MDt0aGlzLnByb2Nlc3NlZEF0dHJzLnBvb2xpbmdfdHlwZT10LDE9PT10JiYodGhpcy5uYW1lKz1cIl9tYXhcIil9LHRyYW5zVG9QcmVsdTpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkQXR0cnMubXVsdGlfdmFsdWU9XCIwLjBcIix0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1cInByZWx1XCJ9LHRyYW5zVG9SZWx1NjpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkQXR0cnMubXVsdGlfdmFsdWU9dGhpcy5wcm9jZXNzZWRBdHRycy50aHJlc2hvbGQsdGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJyZWx1NlwifSx0cmFuc1RvSGFyZFNpZ21vaWQ6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3NlZEF0dHJzLm11bHRpX3ZhbHVlPXRoaXMucHJvY2Vzc2VkQXR0cnMuc2xvcGV8fC4yLHRoaXMucHJvY2Vzc2VkQXR0cnMuYmlhc192YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLm9mZnNldHx8LjUsdGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJoYXJkU2lnbW9pZFwifSx0cmFuc1RvTGVha3lyZWx1OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmFscGhhLHRoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPVwibGVha3lSZWx1XCIsdGhpcy5uYW1lPVwicmVsdVwifSx0cmFuc1RvUG93OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmZhY3Rvcnx8Mix0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1cInBvd19mdW5jXCIsdGhpcy5uYW1lPVwicG93XCJ9LHRyYW5zVG9TaWdtb2lkOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJzaWdtb2lkXCJ9LHRyYW5zVG9TcXJ0OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJzcXJ0XCJ9LHRyYW5zVG9UYW5oOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJ0YW5oX2Z1bmNcIn0sdHJhbnNUb0V4cDpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPVwiZXhwXCJ9LHRyYW5zVG9TY2FsZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJvY2Vzc2VkQXR0cnMuc2NhbGU7dGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT12b2lkIDAhPT10P3Q6MSx0aGlzLnByb2Nlc3NlZEF0dHJzLmJpYXNfdmFsdWU9dGhpcy5wcm9jZXNzZWRBdHRycy5iaWFzfHwwO3ZhciBlPXRoaXMucHJvY2Vzc2VkQXR0cnMuYmlhc19hZnRlcl9zY2FsZTt0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1lfHx2b2lkIDA9PT1lP1wic2NhbGVcIjpcInNjYWxlV2lkdGhCaWFzXCJ9LHNldEFjdGl2ZUZ1bmM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm5hbWUucmVwbGFjZShcImNvbnYyZC1lbGVtZW50d2lzZV9hZGQtXCIsXCJcIik7dGhpcy5wcm9jZXNzZWRBdHRycz1PYmplY3QuYXNzaWduKHthY3RpdmVfZnVuY3Rpb246XCJzY2FsZVwiLG11bHRpX3ZhbHVlOlwiMS4wXCIsYmlhc192YWx1ZTpcIjAuMFwiLGZ1c2VfcmVsdTohMX0sdGhpcy5wcm9jZXNzZWRBdHRycyksXCJsZWFreV9yZWx1XCI9PT10JiYodGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmFscGhhLHRoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPVwibGVha3lSZWx1XCIpfSxub3JtYWxpemVQZXJtOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50ZW5zb3JEYXRhTWFwLm9yaWdpbi5zaGFwZS5sZW5ndGgsZT10aGlzLnByb2Nlc3NlZEF0dHJzLmF4aXMscj1lLmxlbmd0aDtpZihyLXQ+MCYmKHI9KGU9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LTF9KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdD49MH0pKSkubGVuZ3RoKSxyPjQpdGhyb3cgRXJyb3IoXCJvcCB0cmFuc3BvZXMyIGF4aXMgbGVuZ3RoIGV4Y2VlZHMgbWF4aW11bSBsZW5ndGggNCwgZ2V0IFwiK3IpO2Zvcih2YXIgbj1uZXcgQXJyYXkocikuZmlsbCgwKSxpPTA7aTxyO2krKyluW2VbaV1dPWk7dmFyIHM9W107Zm9yKGk9MDtpPDQ7aSsrKXNbaV09bltpXXx8MDt0aGlzLnByb2Nlc3NlZEF0dHJzLnBlcm1fYXJyPXMsdGhpcy5wcm9jZXNzZWRBdHRycy5wZXJtX3NpemU9cn0sbm9ybWFsaXplRGltOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4uc2hhcGUsZT1IKHQpLHI9Ryh0LHRoaXMucHJvY2Vzc2VkQXR0cnMuYXhpcyksbj1bXSxpPTA7aTxlW3JdO2krKyluW2ldPWk7aWYodGhpcy5wcm9jZXNzZWRBdHRycy50YXJnZXRfbGVuZ3RoPW4ubGVuZ3RoLHRoaXMucHJvY2Vzc2VkQXR0cnMudGFyZ2V0X3ZhbHVlPW4sdGhpcy5wcm9jZXNzZWRBdHRycy5pbnB1dHNfZGltPWVbcl0sdGhpcy5wcm9jZXNzZWRBdHRycy5kaW09ciwwPT09dGhpcy5wcm9jZXNzZWRBdHRycy5udW0mJih0aGlzLnByb2Nlc3NlZEF0dHJzLm51bT1PYmplY3QudmFsdWVzKHRoaXMudGVuc29yRGF0YU1hcCkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm5cIm91dFwiPT09dC50ZW5zb3JOYW1lfSkpLmxlbmd0aHx8MSksXCJ3YXNtXCI9PT1wLmdldChcImJhY2tlbmRcIikpe3RoaXMucHJvY2Vzc2VkQXR0cnMuZm91cklucHV0cz0hMTt2YXIgcz10aGlzLnRlbnNvckRhdGFNYXAuY291bnRlcjtpZihzKXt2YXIgYT1IKHMuc2hhcGUpO3RoaXMucHJvY2Vzc2VkQXR0cnMuY291bnRlcl9udW09YVtyXX12YXIgbz10aGlzLnRlbnNvckRhdGFNYXAuYXBwZW5kZXI7aWYobyl7dmFyIHU9SChvLnNoYXBlKTt0aGlzLnByb2Nlc3NlZEF0dHJzLmFwcGVuZF9udW09dVtyXX12YXIgaD10aGlzLnRlbnNvckRhdGFNYXAuZm91cnRoO2lmKGgpe3RoaXMucHJvY2Vzc2VkQXR0cnMuZm91cklucHV0cz0hMDt2YXIgYz1IKGguc2hhcGUpO3RoaXMucHJvY2Vzc2VkQXR0cnMuZm91cnRoX251bT1jW3JdfX19LHByb2Nlc3NFbGVtZW50d2lzZUF4aXM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnRlbnNvckRhdGFNYXAub3JpZ2luLnNoYXBlLGU9dGhpcy50ZW5zb3JEYXRhTWFwLmNvdW50ZXIuc2hhcGUscj12b2lkIDA9PT10aGlzLnByb2Nlc3NlZEF0dHJzLmF4aXM/LTE6dGhpcy5wcm9jZXNzZWRBdHRycy5heGlzO3RoaXMucHJvY2Vzc2VkQXR0cnMuY291bnRlckxlbj1lLmxlbmd0aCxCKHQpPT09QihlKT8odGhpcy5wcm9jZXNzZWRBdHRycy5heGlzPTAsdGhpcy5wcm9jZXNzZWRBdHRycy5jb3VudGVyTGVuPTQpOigtMT09PXImJihyPXQubGVuZ3RoLWUubGVuZ3RoKSx0aGlzLnByb2Nlc3NlZEF0dHJzLmF4aXM9Ryh0LHIpKX0sZ2VuRWxlbWVudHdpc2VDb3VudGVyUG9zOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMucHJvY2Vzc2VkQXR0cnMsZT10LmNvdW50ZXJMZW4scj1bXCIwXCIsXCIwXCIsXCIwXCIsXCIwXCJdLG49dC5heGlzLGk9NC1lO2k8NDtpKyspcltpXT1cIm9Qb3NbXCIrbisrK1wiXVwiO3RoaXMucHJvY2Vzc2VkQXR0cnMuY291bnRlclBvcz1yLmpvaW4oXCIsXCIpfSxmbGF0dGVuU2hhcGU6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3QudmFsdWVzKHRoaXMudGVuc29yRGF0YU1hcCkuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGUubGVuZ3RoPjJ9KSk7aWYodCl7dmFyIGU9SCh0LnNoYXBlKTt0LnNoYXBlPVtlWzBdKmVbMl0sZVsxXSplWzNdXX19LHJlc2hhcGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnRlbnNvckRhdGFNYXAub3JpZ2luLGU9dGhpcy50ZW5zb3JEYXRhTWFwLmNvdW50ZXIscj10aGlzLnRlbnNvckRhdGFNYXAub3V0O2lmKGUuc2hhcGUubGVuZ3RoPnQuc2hhcGUubGVuZ3RoKXt2YXIgbj1lO2U9dCx0PW59aWYodC5zaGFwZS5sZW5ndGg+MiYmMj09PWUuc2hhcGUubGVuZ3RoKXt2YXIgaT1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PXQmJih0PVtdKSx2b2lkIDA9PT1lJiYoZT1bXSk7dmFyIHI9dC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pKTtyZXR1cm4gMT09PWUubGVuZ3RoP1sxLHJdOltlWzBdLHIvZVswXV19KHQuc2hhcGUsci5zaGFwZSk7dC5zaGFwZT1pfX0sY2hlY2tJc01lcmdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5uYW1lLnJlcGxhY2UoXCJjb252MmQtZWxlbWVudHdpc2VfYWRkLVwiLFwiXCIpO3RoaXMubmFtZT1cImNvbnYyZF9lbGVtZW50d2lzZV9hZGRcIixcImxlYWt5X3JlbHVcIj09PXQmJih0aGlzLnByb2Nlc3NlZEF0dHJzLmFscGhhJiYodGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmFscGhhKSx0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1cImxlYWt5UmVsdVwiKX19O3ZhciBhdD1mdW5jdGlvbigpe3JldHVybihhdD1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGUscj0xLG49YXJndW1lbnRzLmxlbmd0aDtyPG47cisrKWZvcih2YXIgaSBpbiBlPWFyZ3VtZW50c1tyXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxpKSYmKHRbaV09ZVtpXSk7cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2NvbnN0IG90PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixuLGkpe3RoaXMubmFtZT1cIlwiLHRoaXMuaXNQYWNrZWRPcD0hMSx0aGlzLnByb2Nlc3NlZEF0dHJzPXt9LHRoaXMuc3ViQXR0cnM9W10sdGhpcy51bmlmb3JtPW51bGwsdGhpcy5pbnB1dFRlbnNvcnM9W10sdGhpcy5vdXRwdXRUZW5zb3JzPVtdLHRoaXMuZGF0YUxheW91dD1cIlwiLHRoaXMuaUxheWVyPTAsdGhpcy5wcm9ncmFtPVtdLHRoaXMuaXNGaW5hbE9wPSExLHRoaXMuYnVmZmVyVHlwZT12LkZyYW1lQnVmZmVyLHRoaXMudGVuc29yRGF0YU1hcD17fSx0aGlzLnRlbnNvckRhdGE9W107dmFyIHM9dC50eXBlLGE9dC5pbnB1dHMsbz10Lm91dHB1dHMsdT10LmF0dHJzLGg9dC5pc1BhY2tlZCxjPXQuYnVmZmVyVHlwZSxwPXZvaWQgMD09PWM/di5GcmFtZUJ1ZmZlcjpjLGY9dC51bmlmb3JtLGw9dm9pZCAwPT09Zj9udWxsOmY7dGhpcy5tb2RlbE5hbWU9aSx0aGlzLnN1YkF0dHJzPXQuc3ViQXR0cnMsdGhpcy5uYW1lPXMsdGhpcy5pc1BhY2tlZE9wPWgsdGhpcy5idWZmZXJUeXBlPXAsdGhpcy5kYXRhTGF5b3V0PXIuZGF0YUxheW91dHx8XCJcIix0aGlzLmlMYXllcj1lLHRoaXMuaXNGaW5hbE9wPW4sdGhpcy51bmlmb3JtPWwsdGhpcy5pbml0RXh0ZW5kZWRBdHRycyh1KSx0aGlzLmNvbnN0cnVjdFRlbnNvckRhdGEoYSxvLHIudmFycyksdGhpcy5idWlsZFRlbnNvcigpO3ZhciBkPXRoaXMuYnVpbGRTaGFkZXJQYXJhbXMoKTt0aGlzLmJ1aWxkUHJvZ3JhbShkKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5pdEV4dGVuZGVkQXR0cnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkpe3ZhciByPXRbZV07dGhpcy5wcm9jZXNzZWRBdHRyc1tlXT1yfX0sdC5wcm90b3R5cGUuY29uc3RydWN0VGVuc29yRGF0YT1mdW5jdGlvbih0LGUscil7dmFyIG49dGhpcztPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdLmZvckVhY2goKGZ1bmN0aW9uKGkscyl7ZVt0XVtzXT1uLmdldFRlbnNvclZhcihpLHIpfSkpfSkpLE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV09W24uZ2V0VGVuc29yVmFyKHRbZV1bMF0scildfSkpO3ZhciBpPWZ1bmN0aW9uKHQpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXRyeXt2YXIgcj1lW3RdfHxbe31dLGk9cy5nZXRFeGFjdFRlbnNvck5hbWUodCxcIm91dHB1dFwiKTtpJiZyLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7dC50ZW5zb3JOYW1lPWksbi50ZW5zb3JEYXRhTWFwW2krXCJfXCIrZV09YXQoYXQoe30sdCkse3RlbnNvck5hbWU6aSxydW50aW1lOmV9KX0pKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpfX0scz10aGlzO2Zvcih2YXIgYSBpbiBlKWkoYSk7Zm9yKHZhciBhIGluIHQpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsYSkpe3ZhciBvPXRbYV0ubGVuZ3RoPjA/dFthXTpbe31dLHU9dGhpcy5nZXRFeGFjdFRlbnNvck5hbWUoYSxcImlucHV0XCIpO2lmKHUpe3ZhciBoPW9bMF07aC50ZW5zb3JOYW1lPXUsdGhpcy50ZW5zb3JEYXRhTWFwW3VdPWF0KGF0KHt9LGgpLHt0ZW5zb3JOYW1lOnV9KX19fSx0LnByb3RvdHlwZS5nZXRFeGFjdFRlbnNvck5hbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImlucHV0XCI9PT1lP3tpbnB1dDpcIm9yaWdpblwiLHg6XCJvcmlnaW5cIix5OlwiY291bnRlclwiLHc6XCJ3ZWlnaHRcIn1bdC50b0xvd2VyQ2FzZSgpXXx8dC50b0xvd2VyQ2FzZSgpOntvdXRwdXQ6XCJvdXRcIix5Olwib3V0XCIsb3V0Olwib3V0XCIsc2NhbGU6XCJzY2FsZVwiLGJpYXM6XCJiaWFzXCIsbWVhbjpcIm1lYW5cIix2YXJpYW5jZTpcInZhcmlhbmNlXCIsbWFzazpcIm91dFwiLGJveGVzOlwib3V0XCIsdmFyaWFuY2VzOlwib3V0XCJ9W3QudG9Mb3dlckNhc2UoKV19LHQucHJvdG90eXBlLmdldFRlbnNvclZhcj1mdW5jdGlvbih0LGUpe3ZhciByPW8oZSx0LnJlcGxhY2UoL19wYWNrZWQkLyxcIlwiKSk7cmV0dXJuIHImJnQuZW5kc1dpdGgoXCJfcGFja2VkXCIpP2Z1bmN0aW9uKHQsZSl7dmFyIHI9Mz09PXQuc2hhcGUubGVuZ3RoP1coWzFdLHQuc2hhcGUpOnQuc2hhcGUsbj1yWzBdLGk9clsxXSxzPXJbMl0sYT1yWzNdLG89T2JqZWN0LmFzc2lnbih7fSx0KTtpZihvLm5hbWU9ZSxvLnBhY2tlZD0hMSxpJTQ9PTApe3ZhciB1PWkvNDtvLnBhY2tlZD0hMCxvLnNoYXBlPVtuLHUscyxhXX1yZXR1cm4gb30ocix0KTpyfSx0LnByb3RvdHlwZS5idWlsZFByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMubmFtZSxuPWIuYmFja2VuZCtcIl9cIityLGk9Yi5vcFJlZ2lzdHJ5Lm9wc1tuXTt0cnl7aWYoIWkmJlwid2FzbVwiIT09cC5nZXQoXCJiYWNrZW5kXCIpKXRocm93IG5ldyBFcnJvcihcIlt1bnJlZ2lzdGVyZWQgb3BdIFwiK3IpO3ZhciBzPXRoaXMuaW5wdXRUZW5zb3JzO3RoaXMucHJvZ3JhbT10aGlzLm91dHB1dFRlbnNvcnMubWFwKChmdW5jdGlvbihyLG4pe3JldHVybiBiLmJhY2tlbmRJbnN0YW5jZS5jcmVhdGVQcm9ncmFtKHtvcDppLG91dFRlbnNvcjpyLGlucHV0VGVuc29yczpzLHNoYWRlclBhcmFtczp0W25dLHJ1bnRpbWU6bixpc0ZpbmFsT3A6ZS5pc0ZpbmFsT3B9KX0pKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpfX0sdC5wcm90b3R5cGUucHJvY2Vzc1RlbnNvckRhdGFBbmRBdHRycz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dHJ5e3RoaXMubmFtZS5pbmRleE9mKFwiY29udjJkLWVsZW1lbnR3aXNlX2FkZFwiKT4tMT90aGlzLm5hbWU9XCJjb252MmRfZWxlbWVudHdpc2VfYWRkXCI6dGhpcy5uYW1lLmluZGV4T2YoXCJtYXhfcG9vbDJkX3dpdGhfaW5kZXhcIik+LTEmJih0aGlzLm5hbWU9XCJwb29sMmRfbWF4XCIpO3ZhciBlPWIuYmFja2VuZCtcIl9cIit0aGlzLm5hbWU7KGIub3BSZWdpc3RyeS5vcHNbZV0mJmIub3BSZWdpc3RyeS5vcHNbZV0uYmVoYXZpb3JzfHxbXSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dHJ5e3N0W2VdLmNhbGwodCl9Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KX19KSl9Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KX19LHQucHJvdG90eXBlLmJ1aWxkVGVuc29yPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnByb2Nlc3NUZW5zb3JEYXRhQW5kQXR0cnMoKTt2YXIgZT1PYmplY3QudmFsdWVzKHRoaXMudGVuc29yRGF0YU1hcCk7ZS5mb3JFYWNoKChmdW5jdGlvbihlLHIpe3ZhciBuLGk9ZS50ZW5zb3JOYW1lLHM9bmV3IGl0KHt0eXBlOnQubW9kZWxOYW1lK1wiX1wiK2UubmFtZSxuYW1lOmksc2hhcGU6ZS5zaGFwZSxkYXRhOmUuZGF0YXx8bnVsbCxwZXJzaXN0YWJsZTplLnBlcnNpc3RhYmxlfHwhMSxpbnRlcnBUeXBlOmUuaW50ZXJwVHlwZXx8XCJORUFSRVNUXCIsaXNQYWNrZWQ6dC5pc1BhY2tlZE9wfHxlLnBhY2tlZHx8ITEsYmluZGluZzpyLG5vTGF5b3V0Om51bGw9PT0obj1iLmJhY2tlbmRJbnN0YW5jZSl8fHZvaWQgMD09PW4/dm9pZCAwOm4ubm9MYXlvdXQsZGF0YUxheW91dDp0LmRhdGFMYXlvdXQscnVudGltZTplLnJ1bnRpbWV8fDB9KTtcIm91dFwiPT09aT90Lm91dHB1dFRlbnNvcnMucHVzaChzKTp0LmlucHV0VGVuc29ycy5wdXNoKHMpLGUuc2hhcGU9cy5zaGFwZSxlLnRvdGFsPXMudG90YWx9KSksdGhpcy50ZW5zb3JEYXRhTWFwPW51bGwsdGhpcy50ZW5zb3JEYXRhPWV9LHQucHJvdG90eXBlLmJ1aWxkU2hhZGVyUGFyYW1zPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPVtdO3JldHVybiB0aGlzLm91dHB1dFRlbnNvcnMuZm9yRWFjaCgoZnVuY3Rpb24oKXt2YXIgcj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQucHJvY2Vzc2VkQXR0cnMpKTtlLnB1c2gocil9KSksZX0sdH0oKTt2YXIgdXQ9ZnVuY3Rpb24oKXtyZXR1cm4odXQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9MSxuPWFyZ3VtZW50cy5sZW5ndGg7cjxuO3IrKylmb3IodmFyIGkgaW4gZT1hcmd1bWVudHNbcl0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkmJih0W2ldPWVbaV0pO3JldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtjb25zdCBodD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnRhcmdldENvbnRleHQ9e30sdGhpcy5nYXBGaWxsV2l0aD1cIiNmZmZcIix0aGlzLm1lYW49WzAsMCwwXSx0aGlzLnN0ZD1bMSwxLDFdLHRoaXMuYmdyPSExLHRoaXMucGl4ZWxXaWR0aD0xLHRoaXMucGl4ZWxIZWlnaHQ9MSx0aGlzLmlucHV0RmVlZD1bXSx0aGlzLnRhcmdldENhbnZhcz1wLmdldChcImNhbnZhczJkXCIpfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMudGFyZ2V0Q29udGV4dD10aGlzLnRhcmdldENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIil9cmV0dXJuIHQucHJvdG90eXBlLnByb2Nlc3M9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWUuZmlsbCxpPWUubWVhbixzPWUuc3RkLGE9ZS5iZ3Isbz1lLmtlZXBSYXRpbyx1PXZvaWQgMD09PW98fG8saD1lLnNjYWxlLGM9dm9pZCAwPT09aD8wOmgscD1yLmZjLGY9dm9pZCAwPT09cD8zOnAsbD1yLmZoLGQ9ci5mdyx2PXQsZz17Z2FwRmlsbFdpdGg6bnx8dGhpcy5nYXBGaWxsV2l0aCxtZWFuOml8fHRoaXMubWVhbixzdGQ6c3x8dGhpcy5zdGQsYmdyOmF8fHRoaXMuYmdyLGtlZXBSYXRpbzp1LHNjYWxlOmMsdGFyZ2V0U2l6ZTp7d2lkdGg6ZCxoZWlnaHQ6bH0sdGFyZ2V0U2hhcGU6WzEsZixsLGRdfTtyZXR1cm4gdGhpcy5mcm9tUGl4ZWxzKHYsZyl8fFtdfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9W10sbj17Z2FwRmlsbFdpdGg6ZS5nYXBGaWxsV2l0aCxkeDowLGR5OjAsZFdpZHRoOmUudGFyZ2V0U2l6ZS53aWR0aCxkSGVpZ2h0OmUudGFyZ2V0U2l6ZS5oZWlnaHR9LGk9dCxzPXQucGF0aCYmdC53aWR0aCYmdC5oZWlnaHQ7aWYoIXMmJiEodCBpbnN0YW5jZW9mIEltYWdlQml0bWFwfHx0IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudHx8dCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpcmV0dXJuW3tkYXRhOnIsc2hhcGU6ZS5zaGFwZXx8ZS50YXJnZXRTaGFwZSxuYW1lOlwiaW1hZ2VcIixwZXJzaXN0YWJsZTohMH1dO3RoaXMucGl4ZWxXaWR0aD10Lm5hdHVyYWxXaWR0aHx8dC53aWR0aCx0aGlzLnBpeGVsSGVpZ2h0PXQubmF0dXJhbEhlaWdodHx8dC5oZWlnaHQ7dmFyIGE9cC5nZXQoXCJ3ZWJnbF9ncHVfcGlwZWxpbmVcIil8fGUud2ViZ2xGZWVkUHJvY2VzcztyZXR1cm4gdGhpcy5maXRUb1RhcmdldFNpemUocz9pLnBhdGg6aSxuLHV0KHV0KHt9LGUpLHtpbkdQVTphfSkpLHI9dGhpcy5nZXRJbWFnZURhdGEobiksYT9be2RhdGE6cj1GbG9hdDMyQXJyYXkuZnJvbShyLmRhdGEpLHNoYXBlOlsxLDEsbi5kSGVpZ2h0LG4uZFdpZHRoXSxuYW1lOlwiaW1hZ2VcIixwZXJzaXN0YWJsZTohMH1dOlt7ZGF0YTpyPXRoaXMuYWxsUmVzaGFwZVRvUkdCKHIsZSksc2hhcGU6ZS50YXJnZXRTaGFwZXx8ZS5zaGFwZSxuYW1lOlwiaW1hZ2VcIixwZXJzaXN0YWJsZTohMH1dfSx0LnByb3RvdHlwZS5hbGxSZXNoYXBlVG9SR0I9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9ZS5tZWFuLG49ZS5zdGQsaT1lLnRhcmdldFNoYXBlLHM9ZS5iZ3IsYT1lLm5vcm1hbGl6ZVR5cGUsbz12b2lkIDA9PT1hPzA6YSx1PWlbMV0saD1pWzJdLGM9aVszXSxwPXQuZGF0YXx8dCxmPW5ldyBGbG9hdDMyQXJyYXkoaCpjKnUpLGw9MCxkPTA7ZDxoOysrZClmb3IodmFyIHY9ZCpjLGc9MDtnPGM7KytnKWZvcih2YXIgbT12K2cseT0wO3k8dTsrK3kpe3ZhciBiPXM/NCptKygyLXkpOjQqbSt5O2ZbbF09MD09PW8/cFtiXS8yNTU6KHBbYl0tMTI4KS8xMjgsZltsXS09clt5XSxmW2xdLz1uW3ldLGwrK31yZXR1cm4geihmLFsxLGgsYyx1XSl9LHQucHJvdG90eXBlLmZpdFRvVGFyZ2V0U2l6ZT1mdW5jdGlvbih0LGUscil7dmFyIG49cnx8e30saT1uLmtlZXBSYXRpbyxzPXZvaWQgMD09PWl8fGksYT1uLmluR1BVLG89dm9pZCAwIT09YSYmYSx1PW4uc2NhbGUsaD12b2lkIDA9PT11PzA6dSxjPWUuZFdpZHRoLHA9ZS5kSGVpZ2h0LGY9bz90aGlzLnBpeGVsV2lkdGg6YyxsPW8/dGhpcy5waXhlbEhlaWdodDpwLGQ9bz90aGlzLnBpeGVsV2lkdGg6Yyx2PW8/dGhpcy5waXhlbEhlaWdodDpwLGc9MCxtPTA7aWYoaCl7aWYoZC1jPDB8fHYtcDwwKXRocm93IG5ldyBFcnJvcihcInNjYWxlIHNpemUgc21hbGxlciB0aGFuIHRhcmdldCBzaXplXCIpO3RoaXMucGl4ZWxXaWR0aD50aGlzLnBpeGVsSGVpZ2h0Pyh2PWgsZD1NYXRoLnJvdW5kKHYqdGhpcy5waXhlbFdpZHRoL3RoaXMucGl4ZWxIZWlnaHQpKTooZD1oLHY9TWF0aC5yb3VuZChkKnRoaXMucGl4ZWxIZWlnaHQvdGhpcy5waXhlbFdpZHRoKSksdGhpcy50YXJnZXRDYW52YXMud2lkdGg9Zj1kLHRoaXMudGFyZ2V0Q2FudmFzLmhlaWdodD1sPXYsZS5keD0oZC1jKS8yLGUuZHk9KHYtcCkvMn1lbHNlIHMmJihjL3AqdGhpcy5waXhlbEhlaWdodC90aGlzLnBpeGVsV2lkdGg+PTE/bz8oZj1NYXRoLnJvdW5kKHYqYy9wKSxnPU1hdGguZmxvb3IoKGYtZCkvMikpOihkPU1hdGgucm91bmQodip0aGlzLnBpeGVsV2lkdGgvdGhpcy5waXhlbEhlaWdodCksZz1NYXRoLmZsb29yKChjLWQpLzIpKTpvPyhsPU1hdGgucm91bmQoZCpwL2MpLG09TWF0aC5mbG9vcigobC12KS8yKSk6KHY9TWF0aC5yb3VuZChkKnRoaXMucGl4ZWxIZWlnaHQvdGhpcy5waXhlbFdpZHRoKSxtPU1hdGguZmxvb3IoKHAtdikvMikpKSx0aGlzLnRhcmdldENhbnZhcy53aWR0aD1lLmRXaWR0aD1mLHRoaXMudGFyZ2V0Q2FudmFzLmhlaWdodD1lLmRIZWlnaHQ9bDt0aGlzLnRhcmdldENvbnRleHQuZmlsbFN0eWxlPWUuZ2FwRmlsbFdpdGgsdGhpcy50YXJnZXRDb250ZXh0LmZpbGxSZWN0KDAsMCx0aGlzLnRhcmdldENhbnZhcy53aWR0aCx0aGlzLnRhcmdldENhbnZhcy5oZWlnaHQpLHRoaXMudGFyZ2V0Q29udGV4dC5kcmF3SW1hZ2UodCxnLG0sZCx2KX0sdC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZHgscj10LmR5LG49dC5kV2lkdGgsaT10LmRIZWlnaHQ7cmV0dXJuIHRoaXMudGFyZ2V0Q29udGV4dC5nZXRJbWFnZURhdGEoZSxyLG4saSl9LHQucHJvdG90eXBlLmNvdmVyPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBpPXIscz1uO3JldHVybiByL24qZS90Pj0xP2k9TWF0aC5yb3VuZChzKnQvZSk6cz1NYXRoLnJvdW5kKGkqZS90KSxbaS9yLHMvbl19LHR9KCk7dmFyIGN0PWZ1bmN0aW9uKCl7cmV0dXJuKGN0PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPTEsbj1hcmd1bWVudHMubGVuZ3RoO3I8bjtyKyspZm9yKHZhciBpIGluIGU9YXJndW1lbnRzW3JdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGkpJiYodFtpXT1lW2ldKTtyZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gcHQodCxlLHIpe2Zvcih2YXIgbj1bXSxpPTAscz10Lmxlbmd0aDtpPHM7aSsrKXt2YXIgYT10W2ldO2E+ZSYmbi5wdXNoKHtzY29yZTphLGl9KX1yZXR1cm4gbi5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBlLnNjb3JlLXQuc2NvcmV9KSkuc2xpY2UoMCxyKX1mdW5jdGlvbiBmdCh0KXt2YXIgZT10WzBdLHI9dFsxXSxuPXRbMl0saT10WzNdO3JldHVybiBuPGV8fGk8cj8wOihuLWUpKihpLXIpfWZ1bmN0aW9uIGx0KHQsZSl7aWYoZVswXT50WzJdfHxlWzJdPHRbMF18fGVbMV0+dFszXXx8ZVszXTx0WzFdKXJldHVybiAwO3ZhciByPWZ0KHQpLG49ZnQoZSksaT1mdW5jdGlvbih0LGUpe3ZhciByPXRbMF0sbj10WzFdLGk9dFsyXSxzPXRbM10sYT1lWzBdLG89ZVsxXSx1PWVbMl0saD1lWzNdLGM9TWF0aC5tYXgocixhKSxwPU1hdGgubWF4KG4sbyk7cmV0dXJuKE1hdGgubWluKGksdSktYykqKE1hdGgubWluKHMsaCktcCl9KHQsZSk7cmV0dXJuIGkvKHIrbi1pKX1jb25zdCBkdD17bXVsdGljbGFzc19ubXM6ZnVuY3Rpb24odCxlKXt2YXIgcj10WzBdLG49dm9pZCAwPT09cj9bXTpyLGk9dFsxXSxzPXZvaWQgMD09PWk/W106aSxhPVgobiksbz1YKHMpO2lmKCFhfHwhbylyZXR1cm5bXTtpZihhPWFbMF0sbz1vWzBdLCEoYSYmYS5sZW5ndGgmJm8mJm8ubGVuZ3RoKSlyZXR1cm5bXTtmb3IodmFyIHU9ZS5ubXNfdG9wX2ssaD12b2lkIDA9PT11PzEwMDp1LGM9ZS5ubXNfZXRhLHA9dm9pZCAwPT09Yz8xOmMsZj1lLmtlZXBfdG9wX2ssbD12b2lkIDA9PT1mPzEwMDpmLGQ9ZS5iYWNrZ3JvdW5kX2xhYmVsLHY9dm9pZCAwPT09ZD8wOmQsZz1lLm5tc190aHJlc2hvbGQsbT12b2lkIDA9PT1nPy4zOmcseT1lLnNjb3JlX3RocmVzaG9sZCxiPXZvaWQgMD09PXk/MDp5LHc9W10sXz0wLEE9by5sZW5ndGg7XzxBO18rKyl7dmFyIHg9W107aWYoXyE9PXYpe3ZhciBrPXB0KG9bX10sYixoKTtpZihrJiZrLmxlbmd0aCl7dmFyIE89ay5zaGlmdCgpLFA9YVtPLmldO2Zvcih4LnB1c2goY3QoY3Qoe30sTykse2JveDpQLGxhYmVsOl99KSk7ay5sZW5ndGg7KXt2YXIgVD1rLnNoaWZ0KCk7UD1hW1QuaV07Zm9yKHZhciBqPSEwLE09MCxFPXg7TTxFLmxlbmd0aDtNKyspaWYobHQoUCxFW01dLmJveCk+bSl7aj0hMTticmVha31qJiZ4LnB1c2goY3QoY3Qoe30sVCkse2JveDpQLGxhYmVsOl99KSksaiYmcDwxJiZtPi41JiYobSo9cCl9dz13LmNvbmNhdCh4KX19fXZhciBGPXcuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5zY29yZS10LnNjb3JlfSkpLnNsaWNlKDAsbCkuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5sYWJlbC1lLmxhYmVsfSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLHI9YXJndW1lbnRzLmxlbmd0aDtlPHI7ZSsrKXQrPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG49QXJyYXkodCksaT0wO2ZvcihlPTA7ZTxyO2UrKylmb3IodmFyIHM9YXJndW1lbnRzW2VdLGE9MCxvPXMubGVuZ3RoO2E8bzthKyssaSsrKW5baV09c1thXTtyZXR1cm4gbn0oW3QubGFiZWwsdC5zY29yZV0sdC5ib3gpfSkpO3JldHVybiBGJiZGLmxlbmd0aD9GOltdfX07dmFyIHZ0PWZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiBuZXcocnx8KHI9UHJvbWlzZSkpKChmdW5jdGlvbihpLHMpe2Z1bmN0aW9uIGEodCl7dHJ5e3Uobi5uZXh0KHQpKX1jYXRjaCh0KXtzKHQpfX1mdW5jdGlvbiBvKHQpe3RyeXt1KG4udGhyb3codCkpfWNhdGNoKHQpe3ModCl9fWZ1bmN0aW9uIHUodCl7dmFyIGU7dC5kb25lP2kodC52YWx1ZSk6KGU9dC52YWx1ZSxlIGluc3RhbmNlb2Ygcj9lOm5ldyByKChmdW5jdGlvbih0KXt0KGUpfSkpKS50aGVuKGEsbyl9dSgobj1uLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSkpfSxndD1mdW5jdGlvbih0LGUpe3ZhciByLG4saSxzLGE9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIHM9e25leHQ6bygwKSx0aHJvdzpvKDEpLHJldHVybjpvKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihzW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHM7ZnVuY3Rpb24gbyhzKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIGZ1bmN0aW9uKHMpe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDthOyl0cnl7aWYocj0xLG4mJihpPTImc1swXT9uLnJldHVybjpzWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sc1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYocz1bMiZzWzBdLGkudmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOmk9czticmVhaztjYXNlIDQ6cmV0dXJuIGEubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6YS5sYWJlbCsrLG49c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1hLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKChpPShpPWEudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pfHw2IT09c1swXSYmMiE9PXNbMF0pKXthPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighaXx8c1sxXT5pWzBdJiZzWzFdPGlbM10pKXthLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJmEubGFiZWw8aVsxXSl7YS5sYWJlbD1pWzFdLGk9czticmVha31pZihpJiZhLmxhYmVsPGlbMl0pe2EubGFiZWw9aVsyXSxhLm9wcy5wdXNoKHMpO2JyZWFrfWlbMl0mJmEub3BzLnBvcCgpLGEudHJ5cy5wb3AoKTtjb250aW51ZX1zPWUuY2FsbCh0LGEpfWNhdGNoKHQpe3M9WzYsdF0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLG9dKX19fTtjb25zdCBtdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5ydW5uZXJDb25maWc9e30sdGhpcy5pc1BhdXNlZD0hMSx0aGlzLm1vZGVsPXt9LHRoaXMud2VpZ2h0TWFwPVtdLHRoaXMuaXNFeGVjdXRlZD0hMSx0aGlzLnRlc3Q9ITEsdGhpcy5ncmFwaEdlbmVyYXRvcj17fSx0aGlzLm1lZGlhUHJvY2Vzc29yPW51bGwsdGhpcy5uZWVkUHJlaGVhdD0hMCx0aGlzLmZlZWRTaGFwZT17fSx0aGlzLnJ1bm5lckNvbmZpZz1PYmplY3QuYXNzaWduKHt9LHQpLHRoaXMubmVlZFByZWhlYXQ9dm9pZCAwPT09dC5uZWVkUHJlaGVhdHx8dC5uZWVkUHJlaGVhdCx0aGlzLm1vZGVsTmFtZT10Lm1vZGVsTmFtZXx8RGF0ZS5ub3coKS50b1N0cmluZygpLHRoaXMud2VpZ2h0TWFwPVtdLHAuc2V0KFwibnNcIixzKCkpLFwibm9kZVwiIT09cC5nZXQoXCJwbGF0Zm9ybVwiKSYmKHRoaXMubWVkaWFQcm9jZXNzb3I9bmV3IGh0KX1yZXR1cm4gdC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3JldHVybiB2dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGd0KHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGIuYmFja2VuZEluc3RhbmNlPyh0aGlzLmlzRXhlY3V0ZWQ9ITEsXCJ3YXNtXCIhPT1wLmdldChcImJhY2tlbmRcIik/WzMsMl06WzQsUHJvbWlzZS5hbGwoW3RoaXMubG9hZCgpLGIuYmFja2VuZEluc3RhbmNlLmluaXQoKV0pXSk6KGNvbnNvbGUuZXJyb3IoXCJFUlJPUjogSGF2ZW4ndCByZWdpc3RlciBiYWNrZW5kXCIpLFsyXSk7Y2FzZSAxOnJldHVybiBlLnNlbnQoKSxbMyw1XTtjYXNlIDI6cmV0dXJuWzQsYi5iYWNrZW5kSW5zdGFuY2UuaW5pdCgpXTtjYXNlIDM6cmV0dXJuIGUuc2VudCgpLFs0LHRoaXMubG9hZCgpXTtjYXNlIDQ6ZS5zZW50KCksZS5sYWJlbD01O2Nhc2UgNTpyZXR1cm4gdGhpcy5nZW5GZWVkRGF0YSgpLHRoaXMuZ2VuR3JhcGgoKSx0aGlzLmdlbk9wRGF0YSgpLFwid2FzbVwiIT09cC5nZXQoXCJiYWNrZW5kXCIpP1szLDddOih0aGlzLm1vZGVsPU9iamVjdC5hc3NpZ24odGhpcy5tb2RlbCx0aGlzLnJ1bm5lckNvbmZpZyksdD10aGlzLm1vZGVsLFs0LGIuYmFja2VuZEluc3RhbmNlLmluaXRXYXNtKHRoaXMubW9kZWwsdGhpcy53ZWlnaHRNYXApXSk7Y2FzZSA2OnJldHVybiB0LmluZGV4PWUuc2VudCgpLFsyLFtdXTtjYXNlIDc6cmV0dXJuIHRoaXMubmVlZFByZWhlYXQ/WzQsdGhpcy5wcmVoZWF0KCldOlszLDldO2Nhc2UgODpyZXR1cm5bMixlLnNlbnQoKV07Y2FzZSA5OnJldHVyblsyXX19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdnQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUscixuLGkscyxhLG87cmV0dXJuIGd0KHRoaXMsKGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5ydW5uZXJDb25maWcsZT10Lm1vZGVsUGF0aCxyPXQubW9kZWxPYmosbj12b2lkIDA9PT1yP251bGw6cixlPyhpPW5ldyBkKGUpLHM9dGhpcyxbNCxpLmxvYWQoKV0pOlszLDJdO2Nhc2UgMTpyZXR1cm4gcy5tb2RlbD11LnNlbnQoKSxbMywzXTtjYXNlIDI6KG51bGw9PW4/dm9pZCAwOm4ubW9kZWwpJiYobnVsbD09bj92b2lkIDA6bi5wYXJhbXMpJiYoYT1uLm1vZGVsLG89bi5wYXJhbXMsZC5hbGxvY2F0ZVBhcmFtc1ZhcihhLnZhcnMsbyksdGhpcy5tb2RlbD1hKSx1LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KSl9KSl9LHQucHJvdG90eXBlLmdlbkdyYXBoPWZ1bmN0aW9uKCl7dGhpcy5ncmFwaEdlbmVyYXRvcj1uZXcgbnQodGhpcy5tb2RlbCx0aGlzLnJ1bm5lckNvbmZpZyksdGhpcy53ZWlnaHRNYXA9dGhpcy5ncmFwaEdlbmVyYXRvci5jcmVhdGVHcmFwaCgpfSx0LnByb3RvdHlwZS5nZW5PcERhdGE9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9MDt0aGlzLndlaWdodE1hcC5mb3JFYWNoKChmdW5jdGlvbihyLG4pe3ZhciBpPXIudHlwZTtpZihcImZlZWRcIiE9PWkmJlwiZmV0Y2hcIiE9PWkpe2UrKzt2YXIgcz1uPT09dC53ZWlnaHRNYXAubGVuZ3RoLTIsYT1uZXcgb3QocixlLHQubW9kZWwscyx0Lm1vZGVsTmFtZSk7ci5vcERhdGE9YX19KSksYyh0aGlzLm1vZGVsKX0sdC5wcm90b3R5cGUucHJlaGVhdD1mdW5jdGlvbigpe3JldHVybiB2dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGd0KHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5jaGVja01vZGVsTG9hZGVkKCldO2Nhc2UgMTpyZXR1cm4gZS5zZW50KCksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgMjpyZXR1cm4gdD1lLnNlbnQoKSx0aGlzLmlzRXhlY3V0ZWQ9ITAsWzIsdF19fSkpfSkpfSx0LnByb3RvdHlwZS5jaGVja01vZGVsTG9hZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHZ0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gZ3QodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gMCE9PXRoaXMud2VpZ2h0TWFwLmxlbmd0aD9bMywyXTooY29uc29sZS5pbmZvKFwiSXQncyBiZXR0ZXIgdG8gcHJlaGVhdCB0aGUgbW9kZWwgYmVmb3JlIHJ1bm5pbmcuXCIpLFs0LHRoaXMubG9hZCgpXSk7Y2FzZSAxOnQuc2VudCgpLHRoaXMuZ2VuRmVlZERhdGEoKSx0aGlzLmdlbkdyYXBoKCksdGhpcy5nZW5PcERhdGEoKSx0aGlzLmlzRXhlY3V0ZWQ9ITEsdC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl19fSkpfSkpfSx0LnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZ0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgcixuLGk7cmV0dXJuIGd0KHRoaXMsKGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuaXNQYXVzZWR8fCF0aGlzLm1lZGlhUHJvY2Vzc29yP1syXToocj1bXSxyPXRoaXMucnVubmVyQ29uZmlnLndlYmdsRmVlZFByb2Nlc3M/W3RdOnRoaXMubWVkaWFQcm9jZXNzb3IucHJvY2Vzcyh0LHRoaXMucnVubmVyQ29uZmlnLHRoaXMuZmVlZFNoYXBlKSxuPVtdLFwid2FzbVwiIT09cC5nZXQoXCJiYWNrZW5kXCIpP1szLDNdOls0LGIuYmFja2VuZEluc3RhbmNlLnByZWRpY3QoclswXS5kYXRhLHRoaXMubW9kZWwuaW5kZXgpXSk7Y2FzZSAxOnJldHVybiBzLnNlbnQoKSxbNCx0aGlzLnJlYWQoKV07Y2FzZSAyOnJldHVybiBpPXMuc2VudCgpLG49dGhpcy5wb3N0UHJvY2VzcyhpKSxbMyw1XTtjYXNlIDM6cmV0dXJuIHRoaXMudXBkYXRlRmVlZERhdGEociksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgNDpuPXMuc2VudCgpLHMubGFiZWw9NTtjYXNlIDU6cmV0dXJuIHRoaXMuaXNFeGVjdXRlZD0hMCxbMixlP2Uobik6bl19fSkpfSkpfSx0LnByb3RvdHlwZS5wcmVkaWN0V2l0aEZlZWQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuO3JldHVybiB2dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGkscyxhLG8sdSxoLGMsZixsLGQsdixnO3JldHVybiBndCh0aGlzLChmdW5jdGlvbihtKXtzd2l0Y2gobS5sYWJlbCl7Y2FzZSAwOnJldHVybiBpPXRoaXMuZmVlZFNoYXBlLHM9aS5mYyxhPXZvaWQgMD09PXM/MzpzLG89aS5mdyx1PWkuZmgsQXJyYXkuaXNBcnJheSh0KT8obnVsbD09PShuPXRbMF0pfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmRhdGEpPygoZD10WzBdLmRhdGEpaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fCh0WzBdLmRhdGE9bmV3IEZsb2F0MzJBcnJheShkKSksaD10KTpoPVt7ZGF0YTpuZXcgRmxvYXQzMkFycmF5KHQpLHNoYXBlOnJ8fFsxLGEsdSxvXSxuYW1lOlwiaW1hZ2VcIixwZXJzaXN0YWJsZTohMH1dOihmPShjPXQpLndpZHRoLGw9Yy5oZWlnaHQsZD1jLmRhdGEsaD1be2RhdGE6bmV3IEZsb2F0MzJBcnJheShkKSxzaGFwZTpyfHxbMSxhLGx8fHUsZnx8b10sbmFtZTpcImltYWdlXCIscGVyc2lzdGFibGU6ITB9XSksdj1bXSxcIndhc21cIiE9PXAuZ2V0KFwiYmFja2VuZFwiKT9bMywzXTpbNCxiLmJhY2tlbmRJbnN0YW5jZS5wcmVkaWN0KGhbMF0uZGF0YSx0aGlzLm1vZGVsLmluZGV4KV07Y2FzZSAxOnJldHVybiBtLnNlbnQoKSxbNCx0aGlzLnJlYWQoKV07Y2FzZSAyOnJldHVybiBnPW0uc2VudCgpLHY9dGhpcy5wb3N0UHJvY2VzcyhnKSxbMyw1XTtjYXNlIDM6cmV0dXJuIHRoaXMudXBkYXRlRmVlZERhdGEoaCksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgNDp2PW0uc2VudCgpLG0ubGFiZWw9NTtjYXNlIDU6cmV0dXJuIHRoaXMuaXNFeGVjdXRlZD0hMCxbMixlP2Uodik6dl19fSkpfSkpfSx0LnByb3RvdHlwZS5nZW5GZWVkRGF0YT1mdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5ydW5uZXJDb25maWcscj1lLnR5cGUsbj1lLmZlZWRTaGFwZSxpPWUud2ViZ2xGZWVkUHJvY2Vzczt0aGlzLmZlZWRTaGFwZT10aGlzLm1vZGVsLmZlZWRTaGFwZXx8bjt2YXIgcyxhPXRoaXMuZmVlZFNoYXBlLGg9YS5mYyxjPXZvaWQgMD09PWg/MzpoLGY9YS5maCxsPWEuZncsZD10aGlzLm1vZGVsLnZhcnM7aWYocj09PXkuTXVsdGlwbGVJbnB1dCl7dmFyIHY9dGhpcy5tb2RlbC5vcHMmJnRoaXMubW9kZWwub3BzWzBdJiYobnVsbD09PSh0PXRoaXMubW9kZWwub3BzWzBdLmlucHV0cyl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuWCk7di5sZW5ndGg+MSYmKHM9di5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBlPW8oZCx0KSxyPWUuc2hhcGUucmV2ZXJzZSgpLG49clswXSxpPXJbMV0scz1yWzJdLGE9clszXSx1PXZvaWQgMD09PWE/MTphO3JldHVybiBlLmRhdGE9bmV3IEZsb2F0MzJBcnJheSh1KnMqaSpuKSxlfSkpKX1lbHNle3ZhciBnPVwid2FzbVwiIT09cC5nZXQoXCJiYWNrZW5kXCIpJiZpPzQ6YztzPW8oZCxcImltYWdlXCIpO3ZhciBtPXtuYW1lOlwiaW1hZ2VcIixzaGFwZTpbMSxnLGYsbF19O3M9T2JqZWN0LmFzc2lnbihtLHMse2RhdGE6bmV3IEZsb2F0MzJBcnJheShnKmYqbCkuZmlsbCgxKSxwZXJzaXN0YWJsZTohMH0pfXUoZCxzKX0sdC5wcm90b3R5cGUudXBkYXRlRmVlZERhdGE9ZnVuY3Rpb24odCl7dmFyIGU9dFswXSxyPXRoaXMud2VpZ2h0TWFwLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9wRGF0YT90Lm9wRGF0YS5pbnB1dFRlbnNvcnMuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudGVuc29ySWQuZW5kc1dpdGgoXCJfaW1hZ2VcIil9KSk6bnVsbH0pKSxuPXIub3BEYXRhLmlucHV0VGVuc29ycy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC50ZW5zb3JJZC5lbmRzV2l0aChcIl9pbWFnZVwiKX0pKTtuLmRhdGE9ZS5kYXRhO3ZhciBpPXRoaXMucnVubmVyQ29uZmlnLHM9aS53ZWJnbEZlZWRQcm9jZXNzLGE9dm9pZCAwIT09cyYmcyxvPWkua2VlcFJhdGlvLHU9dm9pZCAwPT09b3x8bztpZihhfHxwLmdldChcIndlYmdsX2dwdV9waXBlbGluZVwiKSl7dmFyIGg9ZS5zaGFwZXx8WzEsMSxlLmhlaWdodCxlLndpZHRoXSxjPW5ldyBVaW50OEFycmF5KGUuZGF0YXx8W10pO2lmKGUud2lkdGgmJmUuaGVpZ2h0JiYhZS5kYXRhKXt2YXIgZj1lLm5hdHVyYWxXaWR0aHx8ZS53aWR0aDtoPVsxLDEsZS5uYXR1cmFsSGVpZ2h0fHxlLmhlaWdodCxmXSxjPWV9dmFyIGw9bi5vcHRzO2wuc2hhcGU9aDt2YXIgZD1yLm9wRGF0YSx2PW5ldyBpdChsKTt2LmRhdGE9YyxkLmlucHV0VGVuc29ycz1bdl07dmFyIGc9aC5zbGljZSgtMiksbT1nWzBdLHk9Z1sxXSxiPWQub3V0cHV0VGVuc29yc1swXS5zaGFwZS5zbGljZSgtMiksdz1iWzBdLF89YlsxXSxBPXRoaXMubWVkaWFQcm9jZXNzb3IuY292ZXIoeSxtLF8sdyk7ci51bmlmb3JtLnVfc2NhbGUudmFsdWU9QSxyLnVuaWZvcm0udV9rZWVwX3JhdGlvLnZhbHVlPSt1fX0sdC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3JldHVybiB2dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gZ3QodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLmdyYXBoR2VuZXJhdG9yLmdldEZlZWRFeGVjdXRvcigpLHRoaXMuZXhlY3V0ZU9wKHQpLFs0LHRoaXMucmVhZCgpXTtjYXNlIDE6cmV0dXJuIGU9ci5zZW50KCksWzIsdGhpcy5wb3N0UHJvY2VzcyhlKV19fSkpfSkpfSx0LnByb3RvdHlwZS5wb3N0UHJvY2Vzcz1mdW5jdGlvbih0KXt2YXIgZT1cIndhc21cIj09PXAuZ2V0KFwiYmFja2VuZFwiKTtpZihwLmdldChcImRlYnVnXCIpKXJldHVybiB0O3ZhciByPXQsbj10aGlzLm1vZGVsLGk9bi5tdWx0aU91dHB1dHMscz1uLnBvc3RPcHM7aWYoaSlpZihlKXI9aS5tYXAoKGZ1bmN0aW9uKGUscil7dmFyIG47cmV0dXJuKG49e30pW2UubmFtZV09dFtyXSxufSkpO2Vsc2V7dmFyIGE9MDtyPWkubWFwKChmdW5jdGlvbihlKXt2YXIgcixuPWUuc2hhcGUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksaT10LnNsaWNlKGEsbithKTtyZXR1cm4gYSs9biwocj17fSlbZS5uYW1lXT1pLHJ9KSl9aWYoaSYmcyYmcy5sZW5ndGgpZm9yKHZhciBvPWZ1bmN0aW9uKHQsZSl7dmFyIG49c1t0XSxpPW4udHlwZSxhPW4uYXR0cnMsbz1uLmlucHV0cyx1PWR0W2ldO2lmKCF1KXJldHVybnt2YWx1ZTp2b2lkIDB9O3ZhciBoPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLHI9YXJndW1lbnRzLmxlbmd0aDtlPHI7ZSsrKXQrPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG49QXJyYXkodCksaT0wO2ZvcihlPTA7ZTxyO2UrKylmb3IodmFyIHM9YXJndW1lbnRzW2VdLGE9MCxvPXMubGVuZ3RoO2E8bzthKyssaSsrKW5baV09c1thXTtyZXR1cm4gbn0ociksYz1PYmplY3Qua2V5cyhvKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBlPW9bdF0scj1lLm5hbWUsbj1lLnNoYXBlLGk9aC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0W3JdfSkpO3JldHVybiBpJiZpWzBdJiZpWzBdW3JdP3tuYW1lOnQsdGVuc29ySWQ6cixkYXRhOmlbMF1bcl0sc2hhcGU6bn06KGNvbnNvbGUuZXJyb3IoXCLmnKrojrflj5bliLBcIityK1wi55qE5pWw5o2uXCIpLG51bGwpfSkpO3I9dShjLGEpfSx1PTAsaD1zLmxlbmd0aDt1PGg7dSsrKXt2YXIgYz1vKHUpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjKXJldHVybiBjLnZhbHVlfXJldHVybiByfSx0LnByb3RvdHlwZS5leGVjdXRlT3A9ZnVuY3Rpb24odCl7dmFyIGU7aWYoXCJmZXRjaFwiIT09dC50eXBlKWlmKFwiZmVlZFwiIT09dC50eXBlJiZ0LmV4ZWN1dGUodGhpcy5pc0V4ZWN1dGVkKSxwLmdldChcImRlYnVnXCIpJiYobnVsbD09PShlPXQub3BEYXRhKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5vdXRwdXRUZW5zb3JzKSYmdC5vcERhdGEub3V0cHV0VGVuc29yc1t0Lm9wRGF0YS5vdXRwdXRUZW5zb3JzLmxlbmd0aC0xXSYmdC5vcERhdGEub3V0cHV0VGVuc29yc1t0Lm9wRGF0YS5vdXRwdXRUZW5zb3JzLmxlbmd0aC0xXS50ZW5zb3JJZD09PXRoaXMubW9kZWxOYW1lK1wiX1wiKyhwLmdldChcIm5zXCIpLmxheWVyTmFtZXx8cC5nZXQoXCJsYXllck5hbWVcIikpKWNvbnNvbGUuaW5mbyh0Lm9wRGF0YS5uYW1lK1wiX1wiK3Qub3BEYXRhLmlMYXllcixcInJ1bm5lciBvcFwiKTtlbHNlIGlmKHQubmV4dCl7dmFyIHI9dC5uZXh0LG49dGhpcy5ncmFwaEdlbmVyYXRvci5nZXRFeGVjdXRvckJ5SWQocik7dGhpcy5leGVjdXRlT3Aobil9fSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHZ0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLHI7cmV0dXJuIGd0KHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5ncmFwaEdlbmVyYXRvci5nZXRGZXRjaEV4ZWN1dG9yKCksZT1vKHRoaXMubW9kZWwudmFycyx0LmlucHV0cy5YWzBdKSxyPXtuYW1lOmUubmFtZSxzaGFwZTp0LmF0dHJzLm9yaWdpbl9zaGFwZXx8ZS5zaGFwZSxpbmRleDp0aGlzLm1vZGVsLmluZGV4fSxbNCxiLmJhY2tlbmRJbnN0YW5jZS5yZWFkKHIpXTtjYXNlIDE6cmV0dXJuWzIsbi5zZW50KCldfX0pKX0pKX0sdC5wcm90b3R5cGUuc3RvcFByZWRpY3Q9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSEwfSx0fSgpLHl0PWZ1bmN0aW9uKCl7fX0sOTkzOigpPT57fX0sZT17fTtmdW5jdGlvbiByKG4pe2lmKGVbbl0pcmV0dXJuIGVbbl0uZXhwb3J0czt2YXIgaT1lW25dPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtuXShpLGkuZXhwb3J0cyxyKSxpLmV4cG9ydHN9cmV0dXJuIHIuZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKXIubyhlLG4pJiYhci5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sci5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksci5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxyLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIoOTk0KX0pKCl9KSk7Il0sInNvdXJjZVJvb3QiOiIifQ==